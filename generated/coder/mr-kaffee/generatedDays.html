<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: mr-kaffee</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_mr_kaffee">mr-kaffee</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_rust">Day 00: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world">Day 00: Hello World!</a>
<ul class="sectlevel4">
<li><a href="#_run_solutions_for_several_days">Run solutions for several days</a></li>
<li><a href="#_general_structure">General structure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_1_calorie_counting">Day 1: Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_input">Input</a></li>
<li><a href="#_star_1">Star 1</a></li>
<li><a href="#_star_2">Star 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
<li><a href="#_today_i_learned">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_2_rock_paper_scissors">Day 2: Rock Paper Scissors</a>
<ul class="sectlevel4">
<li><a href="#_input_2">Input</a></li>
<li><a href="#_star_1_2">Star 1</a></li>
<li><a href="#_star_2_2">Star 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
<li><a href="#_today_i_learned_2">Today I learned</a></li>
<li><a href="#_alternative_based_on_direct_calculations">Alternative based on direct calculations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_3_rucksack_reorganization">Day 3: Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_input_3">Input</a></li>
<li><a href="#_star_1_3">Star 1</a></li>
<li><a href="#_star_2_3">Star 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
<li><a href="#_today_i_learned_3">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_4_camp_cleanup">Day 4: Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_input_4">Input</a></li>
<li><a href="#_star_1_4">Star 1</a></li>
<li><a href="#_star_2_4">Star 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
<li><a href="#_today_i_learned_4">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_5_supply_stacks">Day 5: Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_input_5">Input</a></li>
<li><a href="#_star_1_5">Star 1</a></li>
<li><a href="#_star_2_5">Star 2</a></li>
<li><a href="#_tests_6">Tests</a></li>
<li><a href="#_today_i_learned_5">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_6_tuning_trouble">Day 6: Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_input_6">Input</a></li>
<li><a href="#_star_1_6">Star 1</a></li>
<li><a href="#_star_2_6">Star 2</a></li>
<li><a href="#_alternative">Alternative</a></li>
<li><a href="#_tests_7">Tests</a></li>
<li><a href="#_today_i_learned_6">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_7_no_space_left_on_device">Day 7: No Space Left On Device</a>
<ul class="sectlevel4">
<li><a href="#_input_7">Input</a></li>
<li><a href="#_star_1_7">Star 1</a></li>
<li><a href="#_star_2_7">Star 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_mr_kaffee"><a class="anchor" href="#_mr_kaffee"></a><a class="link" href="#_mr_kaffee">mr-kaffee</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars0.githubusercontent.com/u/73745454?v=4" alt="73745454?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>mr-kaffee</strong><br>
Peter Wieland<br>
Github: <a href="https://github.com/mr-kaffee">mr-kaffee</a>,
Strava: <a href="https://www.strava.com/athletes/89256720">Peter Wieland</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a regular SW coder. Each year in december, I code AoC puzzle solutions. This year, for the 3rd year in a row, I&#8217;ll go with Rust.</p>
</div>
<div class="paragraph">
<p>In my professional career, I used to do lots of Java and MATLAB coding, yet, this feels like very long time ago.</p>
</div>
<div class="paragraph">
<p>If I do not code or work, I enjoy <a href="https://www.strava.com/athletes/89256720">cycling</a> on or off roads, with or without electric support.</p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_rust"><a class="anchor" href="#_day_00_rust"></a><a class="link" href="#_day_00_rust">Day 00: rust</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world"><a class="anchor" href="#_day_00_hello_world"></a><a class="link" href="#_day_00_hello_world">Day 00: Hello World!</a></h4>
<div class="paragraph">
<p>It&#8217;ll be the 3rd year of <a href="https://www.rust-lang.org/">Rust</a> solutions for the 2022 edition of
<a href="https://adventofcode.com/2021">Advent of Code</a></p>
</div>
<div class="paragraph">
<p>I created a little solution infrastrucutre (which resides in the <code>aoc</code> subfolder of <code>day00/rust/mr-kaffee</code>) I want to use in my solutions, and a small application that creates templates and downloads puzzle inputs (which resides in the <code>template</code> subfolder of <code>day00/rust/mr-kaffee</code>).</p>
</div>
<div class="paragraph">
<p>Other than that, my challenges are again to create solutions that perform well and that do not use external dependencies (the latter constraint is not applied for the Day 0 Hello World Example, which I also use to run all my solutions in a row).</p>
</div>
<div class="sect4">
<h5 id="_run_solutions_for_several_days"><a class="anchor" href="#_run_solutions_for_several_days"></a><a class="link" href="#_run_solutions_for_several_days">Run solutions for several days</a></h5>
<div class="paragraph">
<p>The Day 0 application can be used to run several of my solutions (they will be added as I create them) using <code>cargo run --release -- -d &lt;from&gt;..=&lt;to&gt;</code> or <code>cargo --run --release -- -d a,b,c,&#8230;&#8203;</code> where <code>a</code>, <code>b</code>, <code>c</code>, &#8230;&#8203; are numbers of specific days to run. If the <code>-d</code> argument is omitted, all solutions are run.</p>
</div>
</div>
<div class="sect4">
<h5 id="_general_structure"><a class="anchor" href="#_general_structure"></a><a class="link" href="#_general_structure">General structure</a></h5>
<div class="paragraph">
<p>My solutions will be implemented in a <code>src/lib.rs</code> file and generally have the structure detailed below. This is most probably a bit of an overhead, but fun to write and a learning opportunity for me.</p>
</div>
<div class="sect5">
<h6 id="_the_puzzle_definition"><a class="anchor" href="#_the_puzzle_definition"></a><a class="link" href="#_the_puzzle_definition">The Puzzle definition</a></h6>
<div class="paragraph">
<p>This is a function returing an instance of <code>mr_kaffee_aoc::Puzzle</code> which defines metadata, input data, references to solver functions and expected solutions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn puzzle() -&gt; Puzzle&lt;'static, PuzzleData, usize, usize, usize, usize&gt; {
    Puzzle {
        year: 2022,
        day: 0,
        input: include_str!("../input.txt"),
        star1: Some(Star {
            name: "Hello World example",
            f: &amp;star_1,
            exp: Some(0),
        }),
        star2: None,
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_data_structures"><a class="anchor" href="#_data_structures"></a><a class="link" href="#_data_structures">Data Structures</a></h6>
<div class="paragraph">
<p>This includes the code to parse the input data</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct PuzzleData {
    input: &amp;'static str,
}

impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
    type Error = Infallible;

    fn try_from(input: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Self { input })
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_the_solver_functions"><a class="anchor" href="#_the_solver_functions"></a><a class="link" href="#_the_solver_functions">The solver functions</a></h6>
<div class="paragraph">
<p>The main solver functions plus potentially helper functions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    println!("{}", data.input);
    0
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_tests"><a class="anchor" href="#_tests"></a><a class="link" href="#_tests">Tests</a></h6>
<div class="paragraph">
<p>Tests, in particular code to execute the test cases typically defined in the puzzles</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use mr_kaffee_aoc::GenericPuzzle;

    use super::*;

    #[test]
    pub fn test_something() {
        let puzzle = puzzle();
        assert!(puzzle.solve_handle_err());
    }
}</code></pre>
</div>
</div>
<a id="day01" />
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_1_calorie_counting"><a class="anchor" href="#_day_1_calorie_counting"></a><a class="link" href="#_day_1_calorie_counting">Day 1: Calorie Counting</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/1">AoC|2022|1</a>.</p>
</div>
<div class="paragraph">
<p>Nothing very interesting today.</p>
</div>
<div class="sect4">
<h5 id="_input"><a class="anchor" href="#_input"></a><a class="link" href="#_input">Input</a></h5>
<div class="paragraph">
<p>Parse everything in a vec of sums (initially I used a vec of vecs; since individual elements are never needed sums are enough)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::num::ParseIntError;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub calories: Vec&lt;usize&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = ParseIntError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.split("\n\n")
                .map(|elf| elf.lines().map(|l| l.parse::&lt;usize&gt;()).sum())
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|calories| Self { calories })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1"><a class="anchor" href="#_star_1"></a><a class="link" href="#_star_1">Star 1</a></h5>
<div class="paragraph">
<p>Just find the biggest sum (I use <code>fold</code> instead of <code>max</code> to not handle the <code>Option::None</code> case)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.calories.iter().fold(0, |mx, &amp;cal| mx.max(cal))
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2"><a class="anchor" href="#_star_2"></a><a class="link" href="#_star_2">Star 2</a></h5>
<div class="paragraph">
<p>Sum the three biggest sums. First solution used <code>Vec::sort</code>. New solution does not use any sorting and should be <code>O(n)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.calories
        .iter()
        .fold([0; 3], |mut mx, &amp;cal| {
            if cal &gt; mx[0] {
                mx[2] = mx[1];
                mx[1] = mx[0];
                mx[0] = cal;
            } else if cal &gt; mx[1] {
                mx[2] = mx[1];
                mx[1] = cal;
            } else if cal &gt; mx[2] {
                mx[2] = cal;
            }
            mx
        })
        .iter()
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_2"><a class="anchor" href="#_tests_2"></a><a class="link" href="#_tests_2">Tests</a></h5>
<div class="paragraph">
<p>No tests today. It was too simple.</p>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned"><a class="anchor" href="#_today_i_learned"></a><a class="link" href="#_today_i_learned">Today I learned</a></h5>
<div class="paragraph">
<p>Not so much. My template works.</p>
</div>
<div class="paragraph">
<p>Iterating/refactoring the solution, I learned that <code>std::iter::Sum</code> has an implementation <code>impl&lt;T, U, E&gt; Sum&lt;Result&lt;U, E&gt;&gt; for Result&lt;T, E&gt;</code>.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_2_rock_paper_scissors"><a class="anchor" href="#_day_2_rock_paper_scissors"></a><a class="link" href="#_day_2_rock_paper_scissors">Day 2: Rock Paper Scissors</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/2">AoC|2022|2</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_2"><a class="anchor" href="#_input_2"></a><a class="link" href="#_input_2">Input</a></h5>
<div class="paragraph">
<p>I have two enums to parse the first column (A, B, C to <code>RockPaperScissors</code>) and the second column (X, Y, Z to <code>XYZ</code>).</p>
</div>
<div class="paragraph">
<p>It would have been much simpler to parse both into 0, 1, 2 and than use some simple formulas later on (which I did as an alternative, see below), but my solution fails gracefully if something unexpected comes in the input ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum RockPaperScissors {
        Rock,
        Paper,
        Scissors,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum XYZ {
        X,
        Y,
        Z,
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        pub strategy: Vec&lt;(RockPaperScissors, XYZ)&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = String;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(|l| {
                    l.split_once(' ')
                        .ok_or_else(|| format!("Could not parse line '{l}'"))
                        .and_then(|(a, b)| {
                            match a {
                                "A" =&gt; Ok(RockPaperScissors::Rock),
                                "B" =&gt; Ok(RockPaperScissors::Paper),
                                "C" =&gt; Ok(RockPaperScissors::Scissors),
                                _ =&gt; Err(format!("Expected one of A, B, C, found '{a}'")),
                            }
                            .and_then(|a| match b {
                                "X" =&gt; Ok((a, XYZ::X)),
                                "Y" =&gt; Ok((a, XYZ::Y)),
                                "Z" =&gt; Ok((a, XYZ::Z)),
                                _ =&gt; Err(format!("Expected one of X, Y, Z, found '{b}'")),
                            })
                        })
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|strategy| Self { strategy })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_2"><a class="anchor" href="#_star_1_2"></a><a class="link" href="#_star_1_2">Star 1</a></h5>
<div class="paragraph">
<p>For star 1 I directly convert `XYZ`s to `RockPaperScissors&#8217; using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn to_rock_paper_scissors(&amp;self) -&gt; RockPaperScissors {
        match self {
            XYZ::X =&gt; RockPaperScissors::Rock,
            XYZ::Y =&gt; RockPaperScissors::Paper,
            XYZ::Z =&gt; RockPaperScissors::Scissors,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scores are calculated with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn result(&amp;self, other: &amp;Self) -&gt; usize {
        match (self, other) {
            (RockPaperScissors::Rock, RockPaperScissors::Rock) =&gt; 1 + 3,
            (RockPaperScissors::Rock, RockPaperScissors::Paper) =&gt; 1 + 0,
            (RockPaperScissors::Rock, RockPaperScissors::Scissors) =&gt; 1 + 6,
            (RockPaperScissors::Paper, RockPaperScissors::Rock) =&gt; 2 + 6,
            (RockPaperScissors::Paper, RockPaperScissors::Paper) =&gt; 2 + 3,
            (RockPaperScissors::Paper, RockPaperScissors::Scissors) =&gt; 2 + 0,
            (RockPaperScissors::Scissors, RockPaperScissors::Rock) =&gt; 3 + 0,
            (RockPaperScissors::Scissors, RockPaperScissors::Paper) =&gt; 3 + 6,
            (RockPaperScissors::Scissors, RockPaperScissors::Scissors) =&gt; 3 + 3,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the solution is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.strategy
        .iter()
        .map(|(a, b)| b.to_rock_paper_scissors().result(a))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_2"><a class="anchor" href="#_star_2_2"></a><a class="link" href="#_star_2_2">Star 2</a></h5>
<div class="paragraph">
<p>I was expecting an optimization for the second part of the kind, "Figure out what X, Y, Z need to be so you end up with the highest score possible" or "&#8230;&#8203; so that you end up with the lowest score possible that with more than 50% wins". Maybe that would have been too much for day 2.</p>
</div>
<div class="paragraph">
<p>The scores are still calculated in the same way but the conversion is now done using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn for_result(&amp;self, opponent: &amp;RockPaperScissors) -&gt; RockPaperScissors {
        match (&amp;self, opponent) {
            (XYZ::X, RockPaperScissors::Rock) =&gt; RockPaperScissors::Scissors,
            (XYZ::X, RockPaperScissors::Paper) =&gt; RockPaperScissors::Rock,
            (XYZ::X, RockPaperScissors::Scissors) =&gt; RockPaperScissors::Paper,
            (XYZ::Y, _) =&gt; *opponent,
            (XYZ::Z, RockPaperScissors::Rock) =&gt; RockPaperScissors::Paper,
            (XYZ::Z, RockPaperScissors::Paper) =&gt; RockPaperScissors::Scissors,
            (XYZ::Z, RockPaperScissors::Scissors) =&gt; RockPaperScissors::Rock,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.strategy
        .iter()
        .map(|(a, b)| b.for_result(a).result(a))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_3"><a class="anchor" href="#_tests_3"></a><a class="link" href="#_tests_3">Tests</a></h5>
<div class="paragraph">
<p>I made a mistake in my scoring function in the first place. So I wrote tests this time to debug this&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"A Y
B X
C Z"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(15, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(12, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_2"><a class="anchor" href="#_today_i_learned_2"></a><a class="link" href="#_today_i_learned_2">Today I learned</a></h5>
<div class="paragraph">
<p>I think it was the first time I used <code>Result::and_then</code> in a (maybe) meaningful way.</p>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_based_on_direct_calculations"><a class="anchor" href="#_alternative_based_on_direct_calculations"></a><a class="link" href="#_alternative_based_on_direct_calculations">Alternative based on direct calculations</a></h5>
<div class="paragraph">
<p>I could not stop myself from implementing an alternative solution using direct calculations. Run the alternative solution with <code>cargo run --release --features modulo</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        // 0 rock
        // 1 paper
        // 2 scissor
        // (rock - paper + 1) % 3 = 0
        // (rock - rock + 1) % 3 = 1
        // (rock - scissor + 1) % 3 = 2
        data.strategy
            .iter()
            .map(|(a, b)| ((b + 4 - a) % 3) * 3 + (b + 1))
            .sum()
    }

    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        // 0 rock, 1 paper, 2 scissor
        // 0 loose, 1 draw, 2 win
        // to loose, subtract 1 (% 3), to win add 1 (% 3)
        // play (a + b - 1) % 3 -&gt; add this in formula for first star
        data.strategy
            .iter()
            .map(|(a, b)| b * 3 + (a + b + 2) % 3 + 1)
            .sum()
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>I also implemented a parse function which does not check any inputs and will probably result in panics if something unexpected is in the input (to parse without error handling run <code>cargo run --release --features unchecked_parse</code>; this will automatically use the direct calculation variant)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = String;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            if cfg!(feature = "unchecked_parse") {
                Ok(Self {
                    strategy: s
                        .lines()
                        .map(str::as_bytes)
                        .map(|bytes| ((bytes[0] - b'A') as usize, (bytes[2] - b'X') as usize))
                        .collect(),
                })
            } else {
                s.lines()
                    .map(|l| {
                        l.split_once(' ')
                            .ok_or_else(|| format!("Could not parse line '{l}'"))
                            .and_then(|(a, b)| {
                                match a {
                                    "A" =&gt; Ok(0),
                                    "B" =&gt; Ok(1),
                                    "C" =&gt; Ok(2),
                                    _ =&gt; Err(format!("Expected one of A, B, C, found '{a}'")),
                                }
                                .and_then(|a| match b {
                                    "X" =&gt; Ok((a, 0)),
                                    "Y" =&gt; Ok((a, 1)),
                                    "Z" =&gt; Ok((a, 2)),
                                    _ =&gt; Err(format!("Expected one of X, Y, Z, found '{b}'")),
                                })
                            })
                    })
                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                    .map(|strategy| Self { strategy })
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interestingly, not doing any error handling in parsing the input does not lead to any measurable speed-up. Maybe this is because the overall solution time is so small, that the differences are not distinguishable from noise?</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_3_rucksack_reorganization"><a class="anchor" href="#_day_3_rucksack_reorganization"></a><a class="link" href="#_day_3_rucksack_reorganization">Day 3: Rucksack Reorganization</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/3">AoC|2022|3</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_3"><a class="anchor" href="#_input_3"></a><a class="link" href="#_input_3">Input</a></h5>
<div class="paragraph">
<p>I parse the input directly into a vec of vecs of bytes, each representing the priority of the items contained in the rucksacks.</p>
</div>
<div class="paragraph">
<p>I was tempted to think about using sets for quicker <code>contains</code> operations, but given the size of the problem, this is most likely not worth it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub rucksacks: Vec&lt;Vec&lt;u8&gt;&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = &amp;'static str;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(|l| {
                    l.as_bytes()
                        .iter()
                        .map(|&amp;b| match b {
                            b'a'..=b'z' =&gt; Ok(b - b'a' + 1),
                            b'A'..=b'Z' =&gt; Ok(b - b'A' + 27),
                            _ =&gt; Err("Unexpected bytes in input"),
                        })
                        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|rucksacks| Self { rucksacks })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_3"><a class="anchor" href="#_star_1_3"></a><a class="link" href="#_star_1_3">Star 1</a></h5>
<div class="paragraph">
<p>Star 1 is about finding the item in the first compartment (first half) of the rucksack, which is also contained in the secod half.</p>
</div>
<div class="paragraph">
<p>Some simplifications work because / if the input is correct.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I assume that a common item always exists and therefore do not limit the search to the first half (it will stop once an item is found, which will be in the first half)</p>
</li>
<li>
<p>The <code>find</code> function returns an <code>Option</code>. If there were any <code>None</code> values, they would be simply discarded using <code>filter_map</code> (actually, for part 1, there can be no <code>None</code> values, because search is not stopped in the first half, so the first element of the second half would be found, if there is no common element between first and second half. so a simple <code>unwrap</code> would work as well).</p>
</li>
<li>
<p>The <code>chunks_exact</code> function makes sure that every chunk has exactly three elements. If the overall number of rucksacks was not a multiple of three, the remaining rucksacks would simply be discarded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I use a <code>fold</code> instead of <code>sum</code> to do type conversion on the fly (<code>u8</code> would not be big enough to hold the sum).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.rucksacks
        .iter()
        .filter_map(|rucksack| {
            rucksack
                .iter()
                .find(|item| rucksack.as_slice()[rucksack.len() / 2..].contains(item))
        })
        .fold(0usize, |sum, item| sum + *item as usize)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_3"><a class="anchor" href="#_star_2_3"></a><a class="link" href="#_star_2_3">Star 2</a></h5>
<div class="paragraph">
<p>Star 2 is a simple modification, where we look for items that are common for groups of three consecutive rucksacks</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.rucksacks
        .chunks_exact(3)
        .filter_map(|group| {
            group[0]
                .iter()
                .find(|item| group[1].contains(item) &amp;&amp; group[2].contains(item))
        })
        .fold(0usize, |sum, item| sum + *item as usize)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_4"><a class="anchor" href="#_tests_4"></a><a class="link" href="#_tests_4">Tests</a></h5>
<div class="paragraph">
<p>Tests use the example given in the puzzle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(157, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(70, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_3"><a class="anchor" href="#_today_i_learned_3"></a><a class="link" href="#_today_i_learned_3">Today I learned</a></h5>
<div class="paragraph">
<p>... that sometimes it is as simple as it appears at first view.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_4_camp_cleanup"><a class="anchor" href="#_day_4_camp_cleanup"></a><a class="link" href="#_day_4_camp_cleanup">Day 4: Camp Cleanup</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/4">AoC|2022|4</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_4"><a class="anchor" href="#_input_4"></a><a class="link" href="#_input_4">Input</a></h5>
<div class="paragraph">
<p>Today, input parsing was the biggest challenge. Mainly because I decided to not use <code>unwrap</code> but try some proper error handling and to avoid intermediate <code>collect</code> calls. Until I figured out that the code is much simplified if I create a separate function to parse a single line (because <code>?</code> can be used in that function but not in a clojure within an iterator&#8217;s <code>map</code> function), I had to use a lot of <code>and_then</code>, <code>map</code>, <code>map_error</code>, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So here is my parsing functions (admittedly not how it looked like when I submitted my results)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use mr_kaffee_aoc::err::PuzzleError;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub range_pairs: Vec&lt;((usize, usize), (usize, usize))&gt;,
    }

    fn parse_pair(line: &amp;str) -&gt; Result&lt;((usize, usize), (usize, usize)), PuzzleError&gt; {
        let mut iter = line.split(|c: char| c == '-' || c == ',');
        Ok((
            (
                iter.next()
                    .ok_or_else(|| format!("Missing start 1 '{line}'"))?
                    .parse()?,
                iter.next()
                    .ok_or_else(|| format!("Missing end 1 in '{line}'"))?
                    .parse()?,
            ),
            (
                iter.next()
                    .ok_or_else(|| format!("Missing start 2 in '{line}'"))?
                    .parse()?,
                iter.next()
                    .ok_or_else(|| format!("Missing end 2 in '{line}'"))?
                    .parse()?,
            ),
        ))
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = PuzzleError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(parse_pair)
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|range_pairs| Self { range_pairs })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_4"><a class="anchor" href="#_star_1_4"></a><a class="link" href="#_star_1_4">Star 1</a></h5>
<div class="paragraph">
<p>The actual solution is simple for part 1 &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    // count how often one range is contained in the other
    data.range_pairs
        .iter()
        .filter(|((start1, end1), (start2, end2))| {
            (start1 &lt;= start2 &amp;&amp; end2 &lt;= end1) || (start2 &lt;= start1 &amp;&amp; end1 &lt;= end2)
        })
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_4"><a class="anchor" href="#_star_2_4"></a><a class="link" href="#_star_2_4">Star 2</a></h5>
<div class="paragraph">
<p>... as well as for part 2 (I was afraid to be asked to look for overlaps across pairs in part 2 &#8230;&#8203;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    // count how often ranges overlap, i.e., start of one range is contained in the other range
    data.range_pairs
        .iter()
        .filter(|((start1, end1), (start2, end2))| {
            (start1 &lt;= start2 &amp;&amp; start2 &lt;= end1) || (start2 &lt;= start1 &amp;&amp; start1 &lt;= end2)
        })
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_5"><a class="anchor" href="#_tests_5"></a><a class="link" href="#_tests_5">Tests</a></h5>
<div class="paragraph">
<p>Today I even did test-driven development in the sense that I did not write any functional code before I had a failing test case ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;
    use mr_kaffee_aoc::err::PuzzleError;

    const CONTENT: &amp;str = r#"2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8"#;

    #[test]
    pub fn test_star_1() -&gt; Result&lt;(), PuzzleError&gt; {
        let data = PuzzleData::try_from(CONTENT)?;
        assert_eq!(2, star_1(&amp;data));
        Ok(())
    }

    #[test]
    pub fn test_star_2() -&gt; Result&lt;(), PuzzleError&gt; {
        let data = PuzzleData::try_from(CONTENT)?;
        assert_eq!(4, star_2(&amp;data));
        Ok(())
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_4"><a class="anchor" href="#_today_i_learned_4"></a><a class="link" href="#_today_i_learned_4">Today I learned</a></h5>
<div class="paragraph">
<p><code>and_then</code> - <code>map</code> - <code>and_then</code> - <code>map</code> - <code>map_err</code> &#8230;&#8203; is all not needed if some parsing functionality for one line is moved to a separate function where the <code>?</code> shortcut operator can be used for error propagation and conversion</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_5_supply_stacks"><a class="anchor" href="#_day_5_supply_stacks"></a><a class="link" href="#_day_5_supply_stacks">Day 5: Supply Stacks</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/5">AoC|2022|5</a>.</p>
</div>
<div class="paragraph">
<p>Today, there where two main challenges for me:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parsing the input</p>
</li>
<li>
<p>Rust&#8217;s mutability &amp; borrowing concept for part 2</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In addition, it turns out quite complicated to handle possible errors (all kind of invalid moves, empty stacks at end of moves, &#8230;&#8203;). All this effort for code that is never used, because the puzzle inputs are well-formed. I think I will stop this excercise and use plain <code>unwrap</code> again for subsequent days.</p>
</div>
<div class="sect4">
<h5 id="_input_5"><a class="anchor" href="#_input_5"></a><a class="link" href="#_input_5">Input</a></h5>
<div class="paragraph">
<p>Today, it was not just "process input line by line", but in the end almost &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>First, I split the input in one part describing the stacks and a second part describing the moves. Parsing the moves in tuples <code>(n, from, to)</code> is easy. I make the <code>from</code> and <code>to</code> parts zero-based on the fly.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks of crates is a bit more tricky. I did not (could not) use a simple iterator / collect scheme but allocated the stacks upfront and than process line by line starting at the last and pushing elements on the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use mr_kaffee_aoc::err::PuzzleError;

    #[derive(Debug, PartialEq, Eq)]
    pub struct PuzzleData {
        stacks: Vec&lt;Vec&lt;char&gt;&gt;,
        moves: Vec&lt;(usize, usize, usize)&gt;,
    }

    fn parse_move(line: &amp;str, len: usize) -&gt; Result&lt;(usize, usize, usize), PuzzleError&gt; {
        let mut parts = line.split(" ");

        parts.next(); // skip "move"
        let n = parts
            .next()
            .ok_or_else(|| format!("Missing number in move '{line}'"))?
            .parse::&lt;usize&gt;()?;
        parts.next(); // skip "from"
        let from = parts
            .next()
            .ok_or_else(|| format!("Missing from in move '{line}'"))?
            .parse::&lt;usize&gt;()?
            - 1;
        parts.next(); // skip "to"
        let to = parts
            .next()
            .ok_or_else(|| format!("Missing to in move '{line}'"))?
            .parse::&lt;usize&gt;()?
            - 1;

        if from &gt;= len || to &gt;= len {
            Err(format!("Invalid move: '{line}', &lt;from&gt;, &lt;to&gt; &lt;= {len} required.").into())
        } else if from == to {
            Err(format!("Invalid move: '{line}', &lt;from&gt; != &lt;to&gt; required.").into())
        } else {
            Ok((n, from, to))
        }
    }

    fn parse_crate_layer(stacks: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, line: &amp;str) {
        for (k, item) in line
            .chars()
            .skip(1)
            .step_by(4)
            .enumerate()
            .filter(|(_, item)| *item != ' ')
        {
            while k &gt;= stacks.len() {
                stacks.push(Vec::new());
            }
            stacks[k].push(item);
        }
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = PuzzleError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            let (stacks_part, moves_part) = s
                .split_once("\n\n")
                .ok_or("Could not separate crates from moves")?;

            let mut stacks: Vec&lt;Vec&lt;char&gt;&gt; = vec![];
            for line in stacks_part.lines().rev().skip(1) {
                parse_crate_layer(&amp;mut stacks, line);
            }

            let moves = moves_part
                .lines()
                .map(|line| parse_move(line, stacks.len()))
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

            Ok(PuzzleData { stacks, moves })
        }
    }

    impl PuzzleData {
        /// get moves
        pub fn moves(&amp;self) -&gt; &amp;[(usize, usize, usize)] {
            &amp;self.moves
        }

        /// get cloned crates
        pub fn stacks(&amp;self) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {
            self.stacks.clone()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_5"><a class="anchor" href="#_star_1_5"></a><a class="link" href="#_star_1_5">Star 1</a></h5>
<div class="paragraph">
<p>This is straight forward. Just process move by move, and pop from one stack / push to the other stack the correct number of times.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn msg(stacks: &amp;[Vec&lt;char&gt;]) -&gt; Result&lt;String, PuzzleError&gt; {
    stacks
        .iter()
        .map(|c| {
            c.last().ok_or_else(|| {
                PuzzleError::from(format!(
                    "Can't construct message. Empty stack in {stacks:?}"
                ))
            })
        })
        .collect()
}

pub fn star_1(data: &amp;PuzzleData) -&gt; Result&lt;String, PuzzleError&gt; {
    let mut stacks = data.stacks();
    for (n, from, to) in data.moves() {
        for _ in 0..*n {
            let item = stacks[*from]
                .pop()
                .ok_or_else(|| format!("Tried to pop from empty stack {from}, stacks: {stacks:?}"))?;
            stacks[*to].push(item);
        }
    }

    msg(&amp;stacks)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_5"><a class="anchor" href="#_star_2_5"></a><a class="link" href="#_star_2_5">Star 2</a></h5>
<div class="paragraph">
<p>This is slightly more tricky. Now we have to pop a complete pack of items and push that on top of another stack preserving the order.</p>
</div>
<div class="paragraph">
<p>The challenging part of it is that Rust does not allow mutable references to two items in a vec at the same time. My first solution used intermediate storage. My current solution uses <code>slice::split_at_mut</code> to circumvent this (speed-up by a factor 3 to 4 for part 2 compared to intermediate storage). The code gets a bit complicated though&#8201;&#8212;&#8201;I extracted the complicated part to a function <code>mut_references</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn mut_references&lt;T&gt;(v: &amp;mut Vec&lt;T&gt;, idx1: usize, idx2: usize) -&gt; (&amp;mut T, &amp;mut T) {
    if idx1 &gt; idx2 {
        let (left, right) = v.split_at_mut(idx1);
        (&amp;mut right[0], &amp;mut left[idx2])
    } else {
        let (left, right) = v.split_at_mut(idx2);
        (&amp;mut left[idx1], &amp;mut right[0])
    }
}

pub fn star_2(data: &amp;PuzzleData) -&gt; Result&lt;String, PuzzleError&gt; {
    let mut stacks = data.stacks();
    for (n, from, to) in data.moves() {
        // I need a mutable reference to the from and the to part at the same time
        // to avoid creating intermediate storage
        let (source, dest) = mut_references(&amp;mut stacks, *from, *to);

        let len = source.len();
        if *n &gt; len {
            return Err(format!(
                "Trying to pop {n} elements from stack {from} containing {len}, stacks: {stacks:?}"
            )
            .into());
        }
        for item in source.drain(len - n..) {
            dest.push(item);
        }
    }

    msg(&amp;stacks)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_6"><a class="anchor" href="#_tests_6"></a><a class="link" href="#_tests_6">Tests</a></h5>
<div class="paragraph">
<p>And there are some tests.</p>
</div>
<div class="paragraph">
<p>Since parsing was not totally obvious, I did an additional test for this part &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"    [D]
[N] [C]
[Z] [M] [P]
 1   2   3

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2"#;

    #[test]
    pub fn test_parse() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(
            vec![vec!['Z', 'N'], vec!['M', 'C', 'D'], vec!['P']],
            data.stacks()
        );
        assert_eq!(&amp;[(1, 1, 0), (3, 0, 2), (2, 1, 0), (1, 0, 1)], data.moves());
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!("CMZ", star_1(&amp;data).unwrap());
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!("MCD", star_2(&amp;data).unwrap());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_5"><a class="anchor" href="#_today_i_learned_5"></a><a class="link" href="#_today_i_learned_5">Today I learned</a></h5>
<div class="paragraph">
<p>How to mutably access two elements of one vec in Rust.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_6_tuning_trouble"><a class="anchor" href="#_day_6_tuning_trouble"></a><a class="link" href="#_day_6_tuning_trouble">Day 6: Tuning Trouble</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/6">AoC|2022|6</a>.</p>
</div>
<div class="paragraph">
<p>Today I totally screwed up for the second star for no specific reason :(</p>
</div>
<div class="paragraph">
<p>Too little sleep probably.</p>
</div>
<div class="sect4">
<h5 id="_input_6"><a class="anchor" href="#_input_6"></a><a class="link" href="#_input_6">Input</a></h5>
<div class="paragraph">
<p>I parse the input directly into a slice of bytes. That should be very cheap&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::convert::Infallible;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub stream: &amp;'static [u8],
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = Infallible;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            Ok(PuzzleData {
                stream: s.trim().as_bytes(),
            })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_6"><a class="anchor" href="#_star_1_6"></a><a class="link" href="#_star_1_6">Star 1</a></h5>
<div class="paragraph">
<p>Hand-crafted solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let (k, _) = data
        .stream
        .windows(4)
        .enumerate()
        .find(|(_, s)| match s {
            &amp;[a, b, c, d] =&gt; a != b &amp;&amp; a != c &amp;&amp; a != d &amp;&amp; b != c &amp;&amp; b != d &amp;&amp; c != d,
            _ =&gt; unreachable!(),
        })
        .unwrap();

    k + 4
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_6"><a class="anchor" href="#_star_2_6"></a><a class="link" href="#_star_2_6">Star 2</a></h5>
<div class="paragraph">
<p>Solution with a bit of iterators.</p>
</div>
<div class="paragraph">
<p>It feels bad to search the same thing again and again. If a duplicate is found in a window, the search could skip everything until the character just after the first occurance of the duplicate. I implemented this as an alternative (see below)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let (k, _) = data
        .stream
        .windows(14)
        .enumerate()
        .find(|(_, w)| {
            w.iter()
                .enumerate()
                .skip(1)
                .all(|(p, c1)| w.iter().take(p).all(|c2| c1 != c2))
        })
        .unwrap();
    k + 14
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative"><a class="anchor" href="#_alternative"></a><a class="link" href="#_alternative">Alternative</a></h5>
<div class="paragraph">
<p>As an alternative, I implemented a generic solution which skips parts of the search already covered. Interestingly, this solution tends to be slightly slower (the difference is close to measurement noise in my not very professional time measurements)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn find_distinct(stream: &amp;[u8], n: usize) -&gt; usize {
    let mut k = 0;
    while k &lt; stream.len() - n {
        match (k + 1..k + n).find(|p| stream[*p..k + n].contains(&amp;stream[*p - 1])) {
            Some(q) =&gt; k = q,
            None =&gt; return k + n,
        }
    }

    panic!("No solution.");
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_7"><a class="anchor" href="#_tests_7"></a><a class="link" href="#_tests_7">Tests</a></h5>
<div class="paragraph">
<p>Tests for all variants</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"mjqjpqmgbljsphdztnvjfqwrcgsmlb"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(7, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(19, star_2(&amp;data));
    }

    #[test]
    pub fn test_find_distinct() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(7, find_distinct(data.stream, 4));
        assert_eq!(19, find_distinct(data.stream, 14));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_6"><a class="anchor" href="#_today_i_learned_6"></a><a class="link" href="#_today_i_learned_6">Today I learned</a></h5>
<div class="paragraph">
<p>Take a second cup of coffee before solving the puzzle, don&#8217;t forget to wear glasses, and</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is cool to not allocate any intermediate storage but work directly on byte slices.</p>
</li>
<li>
<p>it is possible to destructure slices with <code>match</code></p>
</li>
</ul>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_7_no_space_left_on_device"><a class="anchor" href="#_day_7_no_space_left_on_device"></a><a class="link" href="#_day_7_no_space_left_on_device">Day 7: No Space Left On Device</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/7">AoC|2022|7</a>.</p>
</div>
<div class="paragraph">
<p>When reading the puzzle today, I thought it would get complicated. Finally, it was quite straight-forward.</p>
</div>
<div class="sect4">
<h5 id="_input_7"><a class="anchor" href="#_input_7"></a><a class="link" href="#_input_7">Input</a></h5>
<div class="paragraph">
<p>The description asks for recursion / recursive data structures, which I find a pain in Rust. My solution is to create a vec of <code>Directory</code> elements. Each directory contains references to children and the parent directory as index to this vec.</p>
</div>
<div class="paragraph">
<p>The directories are created by processing the input line by line. When an <code>ls</code> command yields a directory, a new <code>Directory</code> element is added, its index is added to the children to of the current directory and its parent is set to the current directorie&#8217;s index.</p>
</div>
<div class="paragraph">
<p>File sizes are directly summed up (initially, child files were stored in a vec, but once part 2 was unveiled, it was clear that the sum is the only thing needed)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::{collections::HashMap, convert::Infallible};

    #[derive(Debug)]
    pub struct Directory {
        parent: Option&lt;usize&gt;,
        children: HashMap&lt;&amp;'static str, usize&gt;,
        size: usize,
    }

    impl Directory {
        fn new(parent: Option&lt;usize&gt;) -&gt; Self {
            Self {
                parent,
                children: HashMap::new(),
                size: 0,
            }
        }

        pub fn total_size(&amp;self, dirs: &amp;[Directory]) -&gt; usize {
            self.size
                + self
                    .children
                    .values()
                    .map(|idx| dirs[*idx].total_size(dirs))
                    .sum::&lt;usize&gt;()
        }
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        dirs: Vec&lt;Directory&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = Infallible;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            let mut dirs = vec![Directory::new(None)];

            let mut current = 0;
            for line in s.lines() {
                match line {
                    "$ cd /" =&gt; current = 0,
                    "$ cd .." =&gt; current = dirs[current].parent.unwrap(),
                    "$ ls" =&gt; (),
                    _ if line.starts_with("$ cd ") =&gt; {
                        current = dirs[current].children[line.strip_prefix("$ cd ").unwrap()];
                    }
                    _ if line.starts_with("dir ") =&gt; {
                        let dir = dirs.len();
                        dirs.push(Directory::new(Some(current)));
                        dirs[current]
                            .children
                            .insert(line.strip_prefix("dir ").unwrap(), dir);
                    }
                    _ =&gt; {
                        let (size, _) = line.split_once(" ").unwrap();
                        dirs[current].size += size.parse::&lt;usize&gt;().unwrap();
                    }
                }
            }

            Ok(Self { dirs })
        }
    }

    impl PuzzleData {
        /// immutable access to directories as slice
        pub fn dirs(&amp;self) -&gt; &amp;[Directory] {
            &amp;self.dirs
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_7"><a class="anchor" href="#_star_1_7"></a><a class="link" href="#_star_1_7">Star 1</a></h5>
<div class="paragraph">
<p>Simple iter - filter - fold</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.dirs()
        .iter()
        .filter_map(|d| {
            let s = d.total_size(data.dirs());
            if s &lt;= 100000 {
                Some(s)
            } else {
                None
            }
        })
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_7"><a class="anchor" href="#_star_2_7"></a><a class="link" href="#_star_2_7">Star 2</a></h5>
<div class="paragraph">
<p>Another simple iter - filter - fold</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let required = data.dirs()[0].total_size(data.dirs()) - 40_000_000;

    data.dirs()
        .iter()
        .filter_map(|d| {
            let s = d.total_size(data.dirs());
            if s &gt;= required {
                Some(s)
            } else {
                None
            }
        })
        .fold(usize::MAX, |mn, s| mn.min(s))
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_8"><a class="anchor" href="#_tests_8"></a><a class="link" href="#_tests_8">Tests</a></h5>
<div class="paragraph">
<p>The standard tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(95_437, star_1(&amp;data))
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(24_933_642, star_2(&amp;data))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>