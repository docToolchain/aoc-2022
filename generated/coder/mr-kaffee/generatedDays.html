<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: mr-kaffee</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_mr_kaffee">mr-kaffee</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_rust">Day 00: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world">Day 00: Hello World!</a>
<ul class="sectlevel4">
<li><a href="#_run_solutions_for_several_days">Run solutions for several days</a></li>
<li><a href="#_general_structure">General structure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_1_calorie_counting">Day 1: Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_input">Input</a></li>
<li><a href="#_star_1">Star 1</a></li>
<li><a href="#_star_2">Star 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
<li><a href="#_today_i_learned">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_2_rock_paper_scissors">Day 2: Rock Paper Scissors</a>
<ul class="sectlevel4">
<li><a href="#_input_2">Input</a></li>
<li><a href="#_star_1_2">Star 1</a></li>
<li><a href="#_star_2_2">Star 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
<li><a href="#_today_i_learned_2">Today I learned</a></li>
<li><a href="#_alternative_based_on_direct_calculations">Alternative based on direct calculations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_3_rucksack_reorganization">Day 3: Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_input_3">Input</a></li>
<li><a href="#_star_1_3">Star 1</a></li>
<li><a href="#_star_2_3">Star 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
<li><a href="#_today_i_learned_3">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_4_camp_cleanup">Day 4: Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_input_4">Input</a></li>
<li><a href="#_star_1_4">Star 1</a></li>
<li><a href="#_star_2_4">Star 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
<li><a href="#_today_i_learned_4">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_5_supply_stacks">Day 5: Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_input_5">Input</a></li>
<li><a href="#_star_1_5">Star 1</a></li>
<li><a href="#_star_2_5">Star 2</a></li>
<li><a href="#_tests_6">Tests</a></li>
<li><a href="#_today_i_learned_5">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_6_tuning_trouble">Day 6: Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_input_6">Input</a></li>
<li><a href="#_star_1_6">Star 1</a></li>
<li><a href="#_star_2_6">Star 2</a></li>
<li><a href="#_alternative">Alternative</a></li>
<li><a href="#_tests_7">Tests</a></li>
<li><a href="#_today_i_learned_6">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_7_no_space_left_on_device">Day 7: No Space Left On Device</a>
<ul class="sectlevel4">
<li><a href="#_input_7">Input</a></li>
<li><a href="#_star_1_7">Star 1</a></li>
<li><a href="#_star_2_7">Star 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_rust">Day 08: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_8_treetop_tree_house">Day 8: Treetop Tree House</a>
<ul class="sectlevel4">
<li><a href="#_input_8">Input</a></li>
<li><a href="#_star_1_8">Star 1</a></li>
<li><a href="#_star_2_8">Star 2</a></li>
<li><a href="#_tests_9">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_rust">Day 09: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_9_rope_bridge">Day 9: Rope Bridge</a>
<ul class="sectlevel4">
<li><a href="#_input_9">Input</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_tests_10">Tests</a></li>
<li><a href="#_today_i_learned_7">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_rust">Day 10: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a>
<ul class="sectlevel4">
<li><a href="#_input_10">Input</a></li>
<li><a href="#_star_1_9">Star 1</a></li>
<li><a href="#_star_2_9">Star 2</a></li>
<li><a href="#_tests_11">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_rust">Day 11: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_11_monkey_in_the_middle">Day 11: Monkey in the Middle</a>
<ul class="sectlevel4">
<li><a href="#_input_11">Input</a></li>
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_tests_12">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_12_rust">Day 12: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_12_hill_climbing_algorithm">Day 12: Hill Climbing Algorithm</a>
<ul class="sectlevel4">
<li><a href="#_input_12">Input</a></li>
<li><a href="#_star_1_10">Star 1</a></li>
<li><a href="#_star_2_10">Star 2</a></li>
<li><a href="#_tests_13">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_13_rust">Day 13: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_13_distress_signal">Day 13: Distress Signal</a>
<ul class="sectlevel4">
<li><a href="#_input_13">Input</a></li>
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_star_1_11">Star 1</a></li>
<li><a href="#_star_2_11">Star 2</a></li>
<li><a href="#_tests_14">Tests</a></li>
<li><a href="#_alternative_without_using_heap">Alternative without using heap</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_14_rust">Day 14: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_14_regolith_reservoir">Day 14: Regolith Reservoir</a>
<ul class="sectlevel4">
<li><a href="#_input_14">Input</a></li>
<li><a href="#_star_1_12">Star 1</a></li>
<li><a href="#_star_2_12">Star 2</a></li>
<li><a href="#_tests_15">Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_mr_kaffee"><a class="anchor" href="#_mr_kaffee"></a><a class="link" href="#_mr_kaffee">mr-kaffee</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars0.githubusercontent.com/u/73745454?v=4" alt="73745454?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>mr-kaffee</strong><br>
Peter Wieland<br>
Github: <a href="https://github.com/mr-kaffee">mr-kaffee</a>,
Strava: <a href="https://www.strava.com/athletes/89256720">Peter Wieland</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a regular SW coder. Each year in december, I code AoC puzzle solutions. This year, for the 3rd year in a row, I&#8217;ll go with Rust.</p>
</div>
<div class="paragraph">
<p>In my professional career, I used to do lots of Java and MATLAB coding, yet, this feels like very long time ago.</p>
</div>
<div class="paragraph">
<p>If I do not code or work, I enjoy <a href="https://www.strava.com/athletes/89256720">cycling</a> on or off roads, with or without electric support.</p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_rust"><a class="anchor" href="#_day_00_rust"></a><a class="link" href="#_day_00_rust">Day 00: rust</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world"><a class="anchor" href="#_day_00_hello_world"></a><a class="link" href="#_day_00_hello_world">Day 00: Hello World!</a></h4>
<div class="paragraph">
<p>It&#8217;ll be the 3rd year of <a href="https://www.rust-lang.org/">Rust</a> solutions for the 2022 edition of
<a href="https://adventofcode.com/2021">Advent of Code</a></p>
</div>
<div class="paragraph">
<p>I created a little solution infrastructure (which resides in the <code>aoc</code> subfolder of <code>day00/rust/mr-kaffee</code>) I want to use in my solutions.</p>
</div>
<div class="paragraph">
<p>My day00 solution can be used to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>run all or some of the solutions (<code>cargo run --release -- run -y 2022 -d 1..=25</code> or <code>cargo run --release -- run -y 2022 -d 1,3,7</code> or simply <code>cargo run --release</code> to run everything)</p>
</li>
<li>
<p>init new days from a template (use batch file <code>init.bat &lt;day&gt;</code> or <code>cargo run --release -- init &#8230;&#8203;</code>)</p>
</li>
<li>
<p>submit results (use batch file <code>submit.bat &lt;day&gt; &lt;part&gt;</code> or <code>cargo run --release -- submit &#8230;&#8203;</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than that, my challenges are again to create solutions that perform well and that do not use external dependencies (the latter constraint is not applied for the Day 0 Hello World Example, which I also use to run all my solutions in a row).</p>
</div>
<div class="sect4">
<h5 id="_run_solutions_for_several_days"><a class="anchor" href="#_run_solutions_for_several_days"></a><a class="link" href="#_run_solutions_for_several_days">Run solutions for several days</a></h5>

</div>
<div class="sect4">
<h5 id="_general_structure"><a class="anchor" href="#_general_structure"></a><a class="link" href="#_general_structure">General structure</a></h5>
<div class="paragraph">
<p>My solutions will be implemented in a <code>src/lib.rs</code> file and generally have the structure detailed below. This is most probably a bit of an overhead, but fun to write and a learning opportunity for me.</p>
</div>
<div class="sect5">
<h6 id="_the_puzzle_definition"><a class="anchor" href="#_the_puzzle_definition"></a><a class="link" href="#_the_puzzle_definition">The Puzzle definition</a></h6>
<div class="paragraph">
<p>This is a function returning a <code>mr_kaffee_aoc::Puzzle</code> struct which defines metadata, input data, references to solver functions and expected solutions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn puzzle() -&gt; Puzzle&lt;'static, PuzzleData, usize, usize, usize, usize&gt; {
    Puzzle {
        year: 2022,
        day: 0,
        input: include_str!("../input.txt"),
        star1: Some(Star {
            name: "Hello World example",
            f: &amp;star_1,
            exp: Some(0),
        }),
        star2: None,
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_data_structures"><a class="anchor" href="#_data_structures"></a><a class="link" href="#_data_structures">Data Structures</a></h6>
<div class="paragraph">
<p>This includes the code to parse the input data</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct PuzzleData {
    input: &amp;'static str,
}

impl From&lt;&amp;'static str&gt; for PuzzleData {
    fn from(input: &amp;'static str) -&gt; Self {
        Self { input }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_the_solver_functions"><a class="anchor" href="#_the_solver_functions"></a><a class="link" href="#_the_solver_functions">The solver functions</a></h6>
<div class="paragraph">
<p>The main solver functions plus potentially helper functions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    println!("{}", data.input);
    0
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_tests"><a class="anchor" href="#_tests"></a><a class="link" href="#_tests">Tests</a></h6>
<div class="paragraph">
<p>Tests, in particular code to execute the test cases typically defined in the puzzles</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;
    use mr_kaffee_aoc::GenericPuzzle;

    #[test]
    pub fn test_something() {
        let puzzle = puzzle();
        assert!(puzzle.solve_handle_err());
    }
}</code></pre>
</div>
</div>
<a id="day01" />
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_1_calorie_counting"><a class="anchor" href="#_day_1_calorie_counting"></a><a class="link" href="#_day_1_calorie_counting">Day 1: Calorie Counting</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/1">AoC|2022|1</a>.</p>
</div>
<div class="paragraph">
<p>Nothing very interesting today.</p>
</div>
<div class="sect4">
<h5 id="_input"><a class="anchor" href="#_input"></a><a class="link" href="#_input">Input</a></h5>
<div class="paragraph">
<p>Parse everything in a vec of sums (initially I used a vec of vecs; since individual elements are never needed sums are enough)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::num::ParseIntError;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub calories: Vec&lt;usize&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = ParseIntError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.split("\n\n")
                .map(|elf| elf.lines().map(|l| l.parse::&lt;usize&gt;()).sum())
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|calories| Self { calories })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1"><a class="anchor" href="#_star_1"></a><a class="link" href="#_star_1">Star 1</a></h5>
<div class="paragraph">
<p>Just find the biggest sum (I use <code>fold</code> instead of <code>max</code> to not handle the <code>Option::None</code> case)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.calories.iter().fold(0, |mx, &amp;cal| mx.max(cal))
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2"><a class="anchor" href="#_star_2"></a><a class="link" href="#_star_2">Star 2</a></h5>
<div class="paragraph">
<p>Sum the three biggest sums. First solution used <code>Vec::sort</code>. New solution does not use any sorting and should be <code>O(n)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.calories
        .iter()
        .fold([0; 3], |mut mx, &amp;cal| {
            if cal &gt; mx[0] {
                mx[2] = mx[1];
                mx[1] = mx[0];
                mx[0] = cal;
            } else if cal &gt; mx[1] {
                mx[2] = mx[1];
                mx[1] = cal;
            } else if cal &gt; mx[2] {
                mx[2] = cal;
            }
            mx
        })
        .iter()
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_2"><a class="anchor" href="#_tests_2"></a><a class="link" href="#_tests_2">Tests</a></h5>
<div class="paragraph">
<p>No tests today. It was too simple.</p>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned"><a class="anchor" href="#_today_i_learned"></a><a class="link" href="#_today_i_learned">Today I learned</a></h5>
<div class="paragraph">
<p>Not so much. My template works.</p>
</div>
<div class="paragraph">
<p>Iterating/refactoring the solution, I learned that <code>std::iter::Sum</code> has an implementation <code>impl&lt;T, U, E&gt; Sum&lt;Result&lt;U, E&gt;&gt; for Result&lt;T, E&gt;</code>.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_2_rock_paper_scissors"><a class="anchor" href="#_day_2_rock_paper_scissors"></a><a class="link" href="#_day_2_rock_paper_scissors">Day 2: Rock Paper Scissors</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/2">AoC|2022|2</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_2"><a class="anchor" href="#_input_2"></a><a class="link" href="#_input_2">Input</a></h5>
<div class="paragraph">
<p>I have two enums to parse the first column (A, B, C to <code>RockPaperScissors</code>) and the second column (X, Y, Z to <code>XYZ</code>).</p>
</div>
<div class="paragraph">
<p>It would have been much simpler to parse both into 0, 1, 2 and than use some simple formulas later on (which I did as an alternative, see below), but my solution fails gracefully if something unexpected comes in the input ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum RockPaperScissors {
        Rock,
        Paper,
        Scissors,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum XYZ {
        X,
        Y,
        Z,
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        pub strategy: Vec&lt;(RockPaperScissors, XYZ)&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = String;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(|l| {
                    l.split_once(' ')
                        .ok_or_else(|| format!("Could not parse line '{l}'"))
                        .and_then(|(a, b)| {
                            match a {
                                "A" =&gt; Ok(RockPaperScissors::Rock),
                                "B" =&gt; Ok(RockPaperScissors::Paper),
                                "C" =&gt; Ok(RockPaperScissors::Scissors),
                                _ =&gt; Err(format!("Expected one of A, B, C, found '{a}'")),
                            }
                            .and_then(|a| match b {
                                "X" =&gt; Ok((a, XYZ::X)),
                                "Y" =&gt; Ok((a, XYZ::Y)),
                                "Z" =&gt; Ok((a, XYZ::Z)),
                                _ =&gt; Err(format!("Expected one of X, Y, Z, found '{b}'")),
                            })
                        })
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|strategy| Self { strategy })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_2"><a class="anchor" href="#_star_1_2"></a><a class="link" href="#_star_1_2">Star 1</a></h5>
<div class="paragraph">
<p>For star 1 I directly convert `XYZ`s to `RockPaperScissors&#8217; using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn to_rock_paper_scissors(&amp;self) -&gt; RockPaperScissors {
        match self {
            XYZ::X =&gt; RockPaperScissors::Rock,
            XYZ::Y =&gt; RockPaperScissors::Paper,
            XYZ::Z =&gt; RockPaperScissors::Scissors,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scores are calculated with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn result(&amp;self, other: &amp;Self) -&gt; usize {
        match (self, other) {
            (RockPaperScissors::Rock, RockPaperScissors::Rock) =&gt; 1 + 3,
            (RockPaperScissors::Rock, RockPaperScissors::Paper) =&gt; 1 + 0,
            (RockPaperScissors::Rock, RockPaperScissors::Scissors) =&gt; 1 + 6,
            (RockPaperScissors::Paper, RockPaperScissors::Rock) =&gt; 2 + 6,
            (RockPaperScissors::Paper, RockPaperScissors::Paper) =&gt; 2 + 3,
            (RockPaperScissors::Paper, RockPaperScissors::Scissors) =&gt; 2 + 0,
            (RockPaperScissors::Scissors, RockPaperScissors::Rock) =&gt; 3 + 0,
            (RockPaperScissors::Scissors, RockPaperScissors::Paper) =&gt; 3 + 6,
            (RockPaperScissors::Scissors, RockPaperScissors::Scissors) =&gt; 3 + 3,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the solution is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.strategy
        .iter()
        .map(|(a, b)| b.to_rock_paper_scissors().result(a))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_2"><a class="anchor" href="#_star_2_2"></a><a class="link" href="#_star_2_2">Star 2</a></h5>
<div class="paragraph">
<p>I was expecting an optimization for the second part of the kind, "Figure out what X, Y, Z need to be so you end up with the highest score possible" or "&#8230;&#8203; so that you end up with the lowest score possible that with more than 50% wins". Maybe that would have been too much for day 2.</p>
</div>
<div class="paragraph">
<p>The scores are still calculated in the same way but the conversion is now done using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn for_result(&amp;self, opponent: &amp;RockPaperScissors) -&gt; RockPaperScissors {
        match (&amp;self, opponent) {
            (XYZ::X, RockPaperScissors::Rock) =&gt; RockPaperScissors::Scissors,
            (XYZ::X, RockPaperScissors::Paper) =&gt; RockPaperScissors::Rock,
            (XYZ::X, RockPaperScissors::Scissors) =&gt; RockPaperScissors::Paper,
            (XYZ::Y, _) =&gt; *opponent,
            (XYZ::Z, RockPaperScissors::Rock) =&gt; RockPaperScissors::Paper,
            (XYZ::Z, RockPaperScissors::Paper) =&gt; RockPaperScissors::Scissors,
            (XYZ::Z, RockPaperScissors::Scissors) =&gt; RockPaperScissors::Rock,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.strategy
        .iter()
        .map(|(a, b)| b.for_result(a).result(a))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_3"><a class="anchor" href="#_tests_3"></a><a class="link" href="#_tests_3">Tests</a></h5>
<div class="paragraph">
<p>I made a mistake in my scoring function in the first place. So I wrote tests this time to debug this&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"A Y
B X
C Z"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(15, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(12, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_2"><a class="anchor" href="#_today_i_learned_2"></a><a class="link" href="#_today_i_learned_2">Today I learned</a></h5>
<div class="paragraph">
<p>I think it was the first time I used <code>Result::and_then</code> in a (maybe) meaningful way.</p>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_based_on_direct_calculations"><a class="anchor" href="#_alternative_based_on_direct_calculations"></a><a class="link" href="#_alternative_based_on_direct_calculations">Alternative based on direct calculations</a></h5>
<div class="paragraph">
<p>I could not stop myself from implementing an alternative solution using direct calculations. Run the alternative solution with <code>cargo run --release --features modulo</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        // 0 rock
        // 1 paper
        // 2 scissor
        // (rock - paper + 1) % 3 = 0
        // (rock - rock + 1) % 3 = 1
        // (rock - scissor + 1) % 3 = 2
        data.strategy
            .iter()
            .map(|(a, b)| ((b + 4 - a) % 3) * 3 + (b + 1))
            .sum()
    }

    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        // 0 rock, 1 paper, 2 scissor
        // 0 loose, 1 draw, 2 win
        // to loose, subtract 1 (% 3), to win add 1 (% 3)
        // play (a + b - 1) % 3 -&gt; add this in formula for first star
        data.strategy
            .iter()
            .map(|(a, b)| b * 3 + (a + b + 2) % 3 + 1)
            .sum()
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>I also implemented a parse function which does not check any inputs and will probably result in panics if something unexpected is in the input (to parse without error handling run <code>cargo run --release --features unchecked_parse</code>; this will automatically use the direct calculation variant)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = String;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            if cfg!(feature = "unchecked_parse") {
                Ok(Self {
                    strategy: s
                        .lines()
                        .map(str::as_bytes)
                        .map(|bytes| ((bytes[0] - b'A') as usize, (bytes[2] - b'X') as usize))
                        .collect(),
                })
            } else {
                s.lines()
                    .map(|l| {
                        l.split_once(' ')
                            .ok_or_else(|| format!("Could not parse line '{l}'"))
                            .and_then(|(a, b)| {
                                match a {
                                    "A" =&gt; Ok(0),
                                    "B" =&gt; Ok(1),
                                    "C" =&gt; Ok(2),
                                    _ =&gt; Err(format!("Expected one of A, B, C, found '{a}'")),
                                }
                                .and_then(|a| match b {
                                    "X" =&gt; Ok((a, 0)),
                                    "Y" =&gt; Ok((a, 1)),
                                    "Z" =&gt; Ok((a, 2)),
                                    _ =&gt; Err(format!("Expected one of X, Y, Z, found '{b}'")),
                                })
                            })
                    })
                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                    .map(|strategy| Self { strategy })
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interestingly, not doing any error handling in parsing the input does not lead to any measurable speed-up. Maybe this is because the overall solution time is so small, that the differences are not distinguishable from noise?</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_3_rucksack_reorganization"><a class="anchor" href="#_day_3_rucksack_reorganization"></a><a class="link" href="#_day_3_rucksack_reorganization">Day 3: Rucksack Reorganization</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/3">AoC|2022|3</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_3"><a class="anchor" href="#_input_3"></a><a class="link" href="#_input_3">Input</a></h5>
<div class="paragraph">
<p>I parse the input directly into a vec of vecs of bytes, each representing the priority of the items contained in the rucksacks.</p>
</div>
<div class="paragraph">
<p>I was tempted to think about using sets for quicker <code>contains</code> operations, but given the size of the problem, this is most likely not worth it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub rucksacks: Vec&lt;Vec&lt;u8&gt;&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = &amp;'static str;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(|l| {
                    l.as_bytes()
                        .iter()
                        .map(|&amp;b| match b {
                            b'a'..=b'z' =&gt; Ok(b - b'a' + 1),
                            b'A'..=b'Z' =&gt; Ok(b - b'A' + 27),
                            _ =&gt; Err("Unexpected bytes in input"),
                        })
                        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|rucksacks| Self { rucksacks })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_3"><a class="anchor" href="#_star_1_3"></a><a class="link" href="#_star_1_3">Star 1</a></h5>
<div class="paragraph">
<p>Star 1 is about finding the item in the first compartment (first half) of the rucksack, which is also contained in the secod half.</p>
</div>
<div class="paragraph">
<p>Some simplifications work because / if the input is correct.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I assume that a common item always exists and therefore do not limit the search to the first half (it will stop once an item is found, which will be in the first half)</p>
</li>
<li>
<p>The <code>find</code> function returns an <code>Option</code>. If there were any <code>None</code> values, they would be simply discarded using <code>filter_map</code> (actually, for part 1, there can be no <code>None</code> values, because search is not stopped in the first half, so the first element of the second half would be found, if there is no common element between first and second half. so a simple <code>unwrap</code> would work as well).</p>
</li>
<li>
<p>The <code>chunks_exact</code> function makes sure that every chunk has exactly three elements. If the overall number of rucksacks was not a multiple of three, the remaining rucksacks would simply be discarded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I use a <code>fold</code> instead of <code>sum</code> to do type conversion on the fly (<code>u8</code> would not be big enough to hold the sum).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.rucksacks
        .iter()
        .filter_map(|rucksack| {
            rucksack
                .iter()
                .find(|item| rucksack.as_slice()[rucksack.len() / 2..].contains(item))
        })
        .fold(0usize, |sum, item| sum + *item as usize)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_3"><a class="anchor" href="#_star_2_3"></a><a class="link" href="#_star_2_3">Star 2</a></h5>
<div class="paragraph">
<p>Star 2 is a simple modification, where we look for items that are common for groups of three consecutive rucksacks</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.rucksacks
        .chunks_exact(3)
        .filter_map(|group| {
            group[0]
                .iter()
                .find(|item| group[1].contains(item) &amp;&amp; group[2].contains(item))
        })
        .fold(0usize, |sum, item| sum + *item as usize)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_4"><a class="anchor" href="#_tests_4"></a><a class="link" href="#_tests_4">Tests</a></h5>
<div class="paragraph">
<p>Tests use the example given in the puzzle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(157, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(70, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_3"><a class="anchor" href="#_today_i_learned_3"></a><a class="link" href="#_today_i_learned_3">Today I learned</a></h5>
<div class="paragraph">
<p>... that sometimes it is as simple as it appears at first view.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_4_camp_cleanup"><a class="anchor" href="#_day_4_camp_cleanup"></a><a class="link" href="#_day_4_camp_cleanup">Day 4: Camp Cleanup</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/4">AoC|2022|4</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_4"><a class="anchor" href="#_input_4"></a><a class="link" href="#_input_4">Input</a></h5>
<div class="paragraph">
<p>Today, input parsing was the biggest challenge. Mainly because I decided to not use <code>unwrap</code> but try some proper error handling and to avoid intermediate <code>collect</code> calls. Until I figured out that the code is much simplified if I create a separate function to parse a single line (because <code>?</code> can be used in that function but not in a clojure within an iterator&#8217;s <code>map</code> function), I had to use a lot of <code>and_then</code>, <code>map</code>, <code>map_error</code>, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So here is my parsing functions (admittedly not how it looked like when I submitted my results)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use mr_kaffee_aoc::err::PuzzleError;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub range_pairs: Vec&lt;((usize, usize), (usize, usize))&gt;,
    }

    fn parse_pair(line: &amp;str) -&gt; Result&lt;((usize, usize), (usize, usize)), PuzzleError&gt; {
        let mut iter = line.split(|c: char| c == '-' || c == ',');
        Ok((
            (
                iter.next()
                    .ok_or_else(|| format!("Missing start 1 '{line}'"))?
                    .parse()?,
                iter.next()
                    .ok_or_else(|| format!("Missing end 1 in '{line}'"))?
                    .parse()?,
            ),
            (
                iter.next()
                    .ok_or_else(|| format!("Missing start 2 in '{line}'"))?
                    .parse()?,
                iter.next()
                    .ok_or_else(|| format!("Missing end 2 in '{line}'"))?
                    .parse()?,
            ),
        ))
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = PuzzleError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(parse_pair)
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|range_pairs| Self { range_pairs })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_4"><a class="anchor" href="#_star_1_4"></a><a class="link" href="#_star_1_4">Star 1</a></h5>
<div class="paragraph">
<p>The actual solution is simple for part 1 &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    // count how often one range is contained in the other
    data.range_pairs
        .iter()
        .filter(|((start1, end1), (start2, end2))| {
            (start1 &lt;= start2 &amp;&amp; end2 &lt;= end1) || (start2 &lt;= start1 &amp;&amp; end1 &lt;= end2)
        })
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_4"><a class="anchor" href="#_star_2_4"></a><a class="link" href="#_star_2_4">Star 2</a></h5>
<div class="paragraph">
<p>... as well as for part 2 (I was afraid to be asked to look for overlaps across pairs in part 2 &#8230;&#8203;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    // count how often ranges overlap, i.e., start of one range is contained in the other range
    data.range_pairs
        .iter()
        .filter(|((start1, end1), (start2, end2))| {
            (start1 &lt;= start2 &amp;&amp; start2 &lt;= end1) || (start2 &lt;= start1 &amp;&amp; start1 &lt;= end2)
        })
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_5"><a class="anchor" href="#_tests_5"></a><a class="link" href="#_tests_5">Tests</a></h5>
<div class="paragraph">
<p>Today I even did test-driven development in the sense that I did not write any functional code before I had a failing test case ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;
    use mr_kaffee_aoc::err::PuzzleError;

    const CONTENT: &amp;str = r#"2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8"#;

    #[test]
    pub fn test_star_1() -&gt; Result&lt;(), PuzzleError&gt; {
        let data = PuzzleData::try_from(CONTENT)?;
        assert_eq!(2, star_1(&amp;data));
        Ok(())
    }

    #[test]
    pub fn test_star_2() -&gt; Result&lt;(), PuzzleError&gt; {
        let data = PuzzleData::try_from(CONTENT)?;
        assert_eq!(4, star_2(&amp;data));
        Ok(())
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_4"><a class="anchor" href="#_today_i_learned_4"></a><a class="link" href="#_today_i_learned_4">Today I learned</a></h5>
<div class="paragraph">
<p><code>and_then</code> - <code>map</code> - <code>and_then</code> - <code>map</code> - <code>map_err</code> &#8230;&#8203; is all not needed if some parsing functionality for one line is moved to a separate function where the <code>?</code> shortcut operator can be used for error propagation and conversion</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_5_supply_stacks"><a class="anchor" href="#_day_5_supply_stacks"></a><a class="link" href="#_day_5_supply_stacks">Day 5: Supply Stacks</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/5">AoC|2022|5</a>.</p>
</div>
<div class="paragraph">
<p>Today, there where two main challenges for me:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parsing the input</p>
</li>
<li>
<p>Rust&#8217;s mutability &amp; borrowing concept for part 2</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In addition, it turns out quite complicated to handle possible errors (all kind of invalid moves, empty stacks at end of moves, &#8230;&#8203;). All this effort for code that is never used, because the puzzle inputs are well-formed. I think I will stop this excercise and use plain <code>unwrap</code> again for subsequent days.</p>
</div>
<div class="sect4">
<h5 id="_input_5"><a class="anchor" href="#_input_5"></a><a class="link" href="#_input_5">Input</a></h5>
<div class="paragraph">
<p>Today, it was not just "process input line by line", but in the end almost &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>First, I split the input in one part describing the stacks and a second part describing the moves. Parsing the moves in tuples <code>(n, from, to)</code> is easy. I make the <code>from</code> and <code>to</code> parts zero-based on the fly.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks of crates is a bit more tricky. I did not (could not) use a simple iterator / collect scheme but allocated the stacks upfront and than process line by line starting at the last and pushing elements on the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use mr_kaffee_aoc::err::PuzzleError;

    #[derive(Debug, PartialEq, Eq)]
    pub struct PuzzleData {
        stacks: Vec&lt;Vec&lt;char&gt;&gt;,
        moves: Vec&lt;(usize, usize, usize)&gt;,
    }

    fn parse_move(line: &amp;str, len: usize) -&gt; Result&lt;(usize, usize, usize), PuzzleError&gt; {
        let mut parts = line.split(" ");

        parts.next(); // skip "move"
        let n = parts
            .next()
            .ok_or_else(|| format!("Missing number in move '{line}'"))?
            .parse::&lt;usize&gt;()?;
        parts.next(); // skip "from"
        let from = parts
            .next()
            .ok_or_else(|| format!("Missing from in move '{line}'"))?
            .parse::&lt;usize&gt;()?
            - 1;
        parts.next(); // skip "to"
        let to = parts
            .next()
            .ok_or_else(|| format!("Missing to in move '{line}'"))?
            .parse::&lt;usize&gt;()?
            - 1;

        if from &gt;= len || to &gt;= len {
            Err(format!("Invalid move: '{line}', &lt;from&gt;, &lt;to&gt; &lt;= {len} required.").into())
        } else if from == to {
            Err(format!("Invalid move: '{line}', &lt;from&gt; != &lt;to&gt; required.").into())
        } else {
            Ok((n, from, to))
        }
    }

    fn parse_crate_layer(stacks: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, line: &amp;str) {
        for (k, item) in line
            .chars()
            .skip(1)
            .step_by(4)
            .enumerate()
            .filter(|(_, item)| *item != ' ')
        {
            while k &gt;= stacks.len() {
                stacks.push(Vec::new());
            }
            stacks[k].push(item);
        }
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = PuzzleError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            let (stacks_part, moves_part) = s
                .split_once("\n\n")
                .ok_or("Could not separate crates from moves")?;

            let mut stacks: Vec&lt;Vec&lt;char&gt;&gt; = vec![];
            for line in stacks_part.lines().rev().skip(1) {
                parse_crate_layer(&amp;mut stacks, line);
            }

            let moves = moves_part
                .lines()
                .map(|line| parse_move(line, stacks.len()))
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

            Ok(PuzzleData { stacks, moves })
        }
    }

    impl PuzzleData {
        /// get moves
        pub fn moves(&amp;self) -&gt; &amp;[(usize, usize, usize)] {
            &amp;self.moves
        }

        /// get cloned crates
        pub fn stacks(&amp;self) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {
            self.stacks.clone()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_5"><a class="anchor" href="#_star_1_5"></a><a class="link" href="#_star_1_5">Star 1</a></h5>
<div class="paragraph">
<p>This is straight forward. Just process move by move, and pop from one stack / push to the other stack the correct number of times.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn msg(stacks: &amp;[Vec&lt;char&gt;]) -&gt; Result&lt;String, PuzzleError&gt; {
    stacks
        .iter()
        .map(|c| {
            c.last().ok_or_else(|| {
                PuzzleError::from(format!(
                    "Can't construct message. Empty stack in {stacks:?}"
                ))
            })
        })
        .collect()
}

pub fn star_1(data: &amp;PuzzleData) -&gt; Result&lt;String, PuzzleError&gt; {
    let mut stacks = data.stacks();
    for (n, from, to) in data.moves() {
        for _ in 0..*n {
            let item = stacks[*from]
                .pop()
                .ok_or_else(|| format!("Tried to pop from empty stack {from}, stacks: {stacks:?}"))?;
            stacks[*to].push(item);
        }
    }

    msg(&amp;stacks)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_5"><a class="anchor" href="#_star_2_5"></a><a class="link" href="#_star_2_5">Star 2</a></h5>
<div class="paragraph">
<p>This is slightly more tricky. Now we have to pop a complete pack of items and push that on top of another stack preserving the order.</p>
</div>
<div class="paragraph">
<p>The challenging part of it is that Rust does not allow mutable references to two items in a vec at the same time. My first solution used intermediate storage. My current solution uses <code>slice::split_at_mut</code> to circumvent this (speed-up by a factor 3 to 4 for part 2 compared to intermediate storage). The code gets a bit complicated though&#8201;&#8212;&#8201;I extracted the complicated part to a function <code>mut_references</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn mut_references&lt;T&gt;(v: &amp;mut Vec&lt;T&gt;, idx1: usize, idx2: usize) -&gt; (&amp;mut T, &amp;mut T) {
    if idx1 &gt; idx2 {
        let (left, right) = v.split_at_mut(idx1);
        (&amp;mut right[0], &amp;mut left[idx2])
    } else {
        let (left, right) = v.split_at_mut(idx2);
        (&amp;mut left[idx1], &amp;mut right[0])
    }
}

pub fn star_2(data: &amp;PuzzleData) -&gt; Result&lt;String, PuzzleError&gt; {
    let mut stacks = data.stacks();
    for (n, from, to) in data.moves() {
        // I need a mutable reference to the from and the to part at the same time
        // to avoid creating intermediate storage
        let (source, dest) = mut_references(&amp;mut stacks, *from, *to);

        let len = source.len();
        if *n &gt; len {
            return Err(format!(
                "Trying to pop {n} elements from stack {from} containing {len}, stacks: {stacks:?}"
            )
            .into());
        }
        for item in source.drain(len - n..) {
            dest.push(item);
        }
    }

    msg(&amp;stacks)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_6"><a class="anchor" href="#_tests_6"></a><a class="link" href="#_tests_6">Tests</a></h5>
<div class="paragraph">
<p>And there are some tests.</p>
</div>
<div class="paragraph">
<p>Since parsing was not totally obvious, I did an additional test for this part &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"    [D]
[N] [C]
[Z] [M] [P]
 1   2   3

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2"#;

    #[test]
    pub fn test_parse() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(
            vec![vec!['Z', 'N'], vec!['M', 'C', 'D'], vec!['P']],
            data.stacks()
        );
        assert_eq!(&amp;[(1, 1, 0), (3, 0, 2), (2, 1, 0), (1, 0, 1)], data.moves());
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!("CMZ", star_1(&amp;data).unwrap());
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!("MCD", star_2(&amp;data).unwrap());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_5"><a class="anchor" href="#_today_i_learned_5"></a><a class="link" href="#_today_i_learned_5">Today I learned</a></h5>
<div class="paragraph">
<p>How to mutably access two elements of one vec in Rust.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_6_tuning_trouble"><a class="anchor" href="#_day_6_tuning_trouble"></a><a class="link" href="#_day_6_tuning_trouble">Day 6: Tuning Trouble</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/6">AoC|2022|6</a>.</p>
</div>
<div class="paragraph">
<p>Today I totally screwed up for the second star for no specific reason :(</p>
</div>
<div class="paragraph">
<p>Too little sleep probably.</p>
</div>
<div class="sect4">
<h5 id="_input_6"><a class="anchor" href="#_input_6"></a><a class="link" href="#_input_6">Input</a></h5>
<div class="paragraph">
<p>I parse the input directly into a slice of bytes. That should be very cheap&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::convert::Infallible;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub stream: &amp;'static [u8],
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = Infallible;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            Ok(PuzzleData {
                stream: s.trim().as_bytes(),
            })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_6"><a class="anchor" href="#_star_1_6"></a><a class="link" href="#_star_1_6">Star 1</a></h5>
<div class="paragraph">
<p>Hand-crafted solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let (k, _) = data
        .stream
        .windows(4)
        .enumerate()
        .find(|(_, s)| match s {
            &amp;[a, b, c, d] =&gt; a != b &amp;&amp; a != c &amp;&amp; a != d &amp;&amp; b != c &amp;&amp; b != d &amp;&amp; c != d,
            _ =&gt; unreachable!(),
        })
        .unwrap();

    k + 4
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_6"><a class="anchor" href="#_star_2_6"></a><a class="link" href="#_star_2_6">Star 2</a></h5>
<div class="paragraph">
<p>Solution with a bit of iterators.</p>
</div>
<div class="paragraph">
<p>It feels bad to search the same thing again and again. If a duplicate is found in a window, the search could skip everything until the character just after the first occurance of the duplicate. I implemented this as an alternative (see below)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let (k, _) = data
        .stream
        .windows(14)
        .enumerate()
        .find(|(_, w)| {
            w.iter()
                .enumerate()
                .skip(1)
                .all(|(p, c1)| w.iter().take(p).all(|c2| c1 != c2))
        })
        .unwrap();
    k + 14
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative"><a class="anchor" href="#_alternative"></a><a class="link" href="#_alternative">Alternative</a></h5>
<div class="paragraph">
<p>As an alternative, I implemented a generic solution which skips parts of the search already covered. Interestingly, this solution tends to be slightly slower (the difference is close to measurement noise in my not very professional time measurements)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn find_distinct(stream: &amp;[u8], n: usize) -&gt; usize {
    let mut k = 0;
    while k &lt; stream.len() - n {
        match (k + 1..k + n).find(|p| stream[*p..k + n].contains(&amp;stream[*p - 1])) {
            Some(q) =&gt; k = q,
            None =&gt; return k + n,
        }
    }

    panic!("No solution.");
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_7"><a class="anchor" href="#_tests_7"></a><a class="link" href="#_tests_7">Tests</a></h5>
<div class="paragraph">
<p>Tests for all variants</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"mjqjpqmgbljsphdztnvjfqwrcgsmlb"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(7, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(19, star_2(&amp;data));
    }

    #[test]
    pub fn test_find_distinct() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(7, find_distinct(data.stream, 4));
        assert_eq!(19, find_distinct(data.stream, 14));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_6"><a class="anchor" href="#_today_i_learned_6"></a><a class="link" href="#_today_i_learned_6">Today I learned</a></h5>
<div class="paragraph">
<p>Take a second cup of coffee before solving the puzzle, don&#8217;t forget to wear glasses, and</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is cool to not allocate any intermediate storage but work directly on byte slices.</p>
</li>
<li>
<p>it is possible to destructure slices with <code>match</code></p>
</li>
</ul>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_7_no_space_left_on_device"><a class="anchor" href="#_day_7_no_space_left_on_device"></a><a class="link" href="#_day_7_no_space_left_on_device">Day 7: No Space Left On Device</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/7">AoC|2022|7</a>.</p>
</div>
<div class="paragraph">
<p>When reading the puzzle today, I thought it would get complicated. Finally, it was quite straight-forward.</p>
</div>
<div class="sect4">
<h5 id="_input_7"><a class="anchor" href="#_input_7"></a><a class="link" href="#_input_7">Input</a></h5>
<div class="paragraph">
<p>The description asks for recursion / recursive data structures, which I find a pain in Rust. My solution is to create a vec of <code>Directory</code> elements. Each directory contains references to children and the parent directory as index to this vec.</p>
</div>
<div class="paragraph">
<p>The directories are created by processing the input line by line. When an <code>ls</code> command yields a directory, a new <code>Directory</code> element is added, its index is added to the children to of the current directory and its parent is set to the current directorie&#8217;s index.</p>
</div>
<div class="paragraph">
<p>File sizes are directly summed up (initially, child files were stored in a vec, but once part 2 was unveiled, it was clear that the sum is the only thing needed)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::{collections::HashMap, convert::Infallible};

    #[derive(Debug)]
    pub struct Directory {
        parent: Option&lt;usize&gt;,
        children: HashMap&lt;&amp;'static str, usize&gt;,
        size: usize,
    }

    impl Directory {
        fn new(parent: Option&lt;usize&gt;) -&gt; Self {
            Self {
                parent,
                children: HashMap::new(),
                size: 0,
            }
        }

        pub fn total_size(&amp;self, dirs: &amp;[Directory]) -&gt; usize {
            self.size
                + self
                    .children
                    .values()
                    .map(|idx| dirs[*idx].total_size(dirs))
                    .sum::&lt;usize&gt;()
        }
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        dirs: Vec&lt;Directory&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = Infallible;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            let mut dirs = vec![Directory::new(None)];

            let mut current = 0;
            for line in s.lines() {
                match line {
                    "$ cd /" =&gt; current = 0,
                    "$ cd .." =&gt; current = dirs[current].parent.unwrap(),
                    "$ ls" =&gt; (),
                    _ if line.starts_with("$ cd ") =&gt; current = dirs[current].children[&amp;line[5..]],
                    _ if line.starts_with("dir ") =&gt; {
                        let dir = dirs.len();
                        dirs.push(Directory::new(Some(current)));
                        dirs[current].children.insert(&amp;line[4..], dir);
                    }
                    _ =&gt; {
                        dirs[current].size +=
                            line[..line.find(' ').unwrap()].parse::&lt;usize&gt;().unwrap();
                    }
                }
            }

            Ok(Self { dirs })
        }
    }

    impl PuzzleData {
        /// immutable access to directories as slice
        pub fn dirs(&amp;self) -&gt; &amp;[Directory] {
            &amp;self.dirs
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_7"><a class="anchor" href="#_star_1_7"></a><a class="link" href="#_star_1_7">Star 1</a></h5>
<div class="paragraph">
<p>Simple iter - filter - fold</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.dirs()
        .iter()
        .map(|d| d.total_size(data.dirs()))
        .filter(|&amp;s| s &lt;= 100_000)
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_7"><a class="anchor" href="#_star_2_7"></a><a class="link" href="#_star_2_7">Star 2</a></h5>
<div class="paragraph">
<p>Another simple iter - filter - fold</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let required = data.dirs()[0].total_size(data.dirs()) - 40_000_000;

    data.dirs()
        .iter()
        .map(|d| d.total_size(data.dirs()))
        .filter(|&amp;s| s &gt;= required)
        .fold(usize::MAX, |mn, s| mn.min(s))
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_8"><a class="anchor" href="#_tests_8"></a><a class="link" href="#_tests_8">Tests</a></h5>
<div class="paragraph">
<p>The standard tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(95_437, star_1(&amp;data))
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(24_933_642, star_2(&amp;data))
    }
}</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_rust"><a class="anchor" href="#_day_08_rust"></a><a class="link" href="#_day_08_rust">Day 08: rust</a></h3>
<div class="sect3">
<h4 id="_day_8_treetop_tree_house"><a class="anchor" href="#_day_8_treetop_tree_house"></a><a class="link" href="#_day_8_treetop_tree_house">Day 8: Treetop Tree House</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/8">AoC|2022|8</a>.</p>
</div>
<div class="paragraph">
<p>I took a moment to put my brain in the condition to think in the 2D grid&#8230;&#8203;</p>
</div>
<div class="sect4">
<h5 id="_input_8"><a class="anchor" href="#_input_8"></a><a class="link" href="#_input_8">Input</a></h5>
<div class="paragraph">
<p>I directly use the bytes from the input. I scan for the first occurrence of a line break. Its index is the width of the grid. The <code>PuzzleData</code> struct&#8217;s implementation has an additional field for the <code>height</code> of the grid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub trees: &amp;'static [u8],
        pub w: usize,
        pub h: usize,
    }

    impl From&lt;&amp;'static str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'static str) -&gt; Self {
            let trees = s.as_bytes();
            let w = s.find('\n').unwrap();
            let h = trees.len() / (w + 1);
            Self { trees, w, h }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_8"><a class="anchor" href="#_star_1_8"></a><a class="link" href="#_star_1_8">Star 1</a></h5>
<div class="paragraph">
<p>The function <code>is_visible</code> verifies in all four directions (left, right, top, bottom), that all trees up to the boundary are smaller. It stops after one such direction is found.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn is_visible(&amp;self, x: usize, y: usize) -&gt; bool {
        let h = self.trees[x + (self.w + 1) * y];

        let fx = |x_: usize| self.trees[x_ + (self.w + 1) * y] &lt; h;
        let fy = |y_: usize| self.trees[x + (self.w + 1) * y_] &lt; h;

        (0..x).all(fx) || (x + 1..self.w).all(fx) || (0..y).all(fy) || (y + 1..self.h).all(fy)
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then I count in the <code>star_1</code> function, how many trees are visible. For a tree on the boundary, <code>is_visible</code> always returns true, so no need to handle the boundary separately.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    (0..data.w)
        .map(|x| (0..data.h).filter(|&amp;y| data.is_visible(x, y)).count())
        .sum::&lt;usize&gt;()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_8"><a class="anchor" href="#_star_2_8"></a><a class="link" href="#_star_2_8">Star 2</a></h5>
<div class="paragraph">
<p>Similar to star 1. This time, I use the function <code>scenic_score</code> to calculate the scenic score of each tree and the function <code>star_2</code> to find the maximum.</p>
</div>
<div class="paragraph">
<p>In the scenic score calculations, different to the visibility check, the traversal order matters. For left and top directions, the direction is reversed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn scenic_score(&amp;self, x: usize, y: usize) -&gt; usize {
        let h = self.trees[x + (self.w + 1) * y];

        let fx = |&amp;x_: &amp;usize| self.trees[x_ + (self.w + 1) * y] &gt;= h;
        let fy = |&amp;y_: &amp;usize| self.trees[x + (self.w + 1) * y_] &gt;= h;

        (x - (0..x).rev().find(fx).unwrap_or(0))
            * ((x + 1..self.w).find(fx).unwrap_or(self.w - 1) - x)
            * (y - (0..y).rev().find(fy).unwrap_or(0))
            * ((y + 1..self.h).find(fy).unwrap_or(self.h - 1) - y)
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    (0..data.w)
        .map(|x| (0..data.h).map(|y| data.scenic_score(x, y)).max().unwrap())
        .max()
        .unwrap()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_9"><a class="anchor" href="#_tests_9"></a><a class="link" href="#_tests_9">Tests</a></h5>
<div class="paragraph">
<p>Tests for <code>star_1</code>, <code>scenic_score</code> and <code>star_2</code> functions based on example defined in puzzle description.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"30373
25512
65332
33549
35390
"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(21, star_1(&amp;data));
    }

    #[test]
    pub fn test_scenic_score() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(4, data.scenic_score(2, 1));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(8, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_rust"><a class="anchor" href="#_day_09_rust"></a><a class="link" href="#_day_09_rust">Day 09: rust</a></h3>
<div class="sect3">
<h4 id="_day_9_rope_bridge"><a class="anchor" href="#_day_9_rope_bridge"></a><a class="link" href="#_day_9_rope_bridge">Day 9: Rope Bridge</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/9">AoC|2022|9</a>.</p>
</div>
<div class="paragraph">
<p>Knots are moving around, following each other. The difficulty is to figure out where you have your off by one errors or similar. In the end, I had a print function showing current configurations to debug my code (because it actually looks nice, you may want to have a look at the output with <code>cargo test test_star_2 -- --nocapture</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Print knots for debugging purposes
///
/// Knots are printed by consecutive letters `a`, `b`, ... starting with the head at `a`
///
/// If a knot sits on a spot which is already seen, it is represented by a capital letter `A`, `B`, ...
///
/// The start is indicated by `$` if no knot is located at the start
///
/// Spots that have been seen and where currently no knot is located are shown as `#`
///
/// If several knots sit on top of each other, the first one in the chain is shown.
pub fn print(
    rx: RangeInclusive&lt;isize&gt;,
    ry: RangeInclusive&lt;isize&gt;,
    knots: &amp;[(isize, isize)],
    ((dx, dy), s): ((isize, isize), usize),
    seen: &amp;HashSet&lt;(isize, isize)&gt;,
) {
    println!("\nAfter moving {s} times by ({dx}, {dy}):");
    for y in ry {
        for x in rx.clone() {
            let seen = seen.contains(&amp;(x, y));
            match knots
                .iter()
                .enumerate()
                .find(|(_, (xn, yn))| *xn == x &amp;&amp; *yn == y)
            {
                Some((v, _)) if seen =&gt; print!("{}", (b'A' + v as u8) as char),
                Some((v, _)) =&gt; print!("{}", (b'a' + v as u8) as char),
                None if x == 0 &amp;&amp; y == 0 =&gt; print!("$"),
                _ if seen =&gt; print!("#"),
                _ =&gt; print!("\u{00b7}"),
            }
        }
        println!();
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_input_9"><a class="anchor" href="#_input_9"></a><a class="link" href="#_input_9">Input</a></h5>
<div class="paragraph">
<p>I parse the input in a vec of tuples <code>((dx, dy), s)</code> where <code>dx</code> and <code>dy</code> are the horizontal / vertical unit step changes and <code>s</code> is the number of steps.</p>
</div>
<div class="paragraph">
<p>Not allocating extra memory for today&#8217;s input parsing is not for me ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        moves: Vec&lt;((isize, isize), usize)&gt;,
    }

    impl From&lt;&amp;str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;str) -&gt; Self {
            Self {
                moves: s
                    .lines()
                    .map(|l| match (l.as_bytes()[0], l[2..].parse().unwrap()) {
                        (b'U', s) =&gt; ((0, -1), s),
                        (b'D', s) =&gt; ((0, 1), s),
                        (b'L', s) =&gt; ((-1, 0), s),
                        (b'R', s) =&gt; ((1, 0), s),
                        _ =&gt; panic!("No valid move: {l}"),
                    })
                    .collect(),
            }
        }
    }

    impl PuzzleData {
        pub fn moves(&amp;self) -&gt; &amp;[((isize, isize), usize)] {
            &amp;self.moves
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>After a little bit of refactoring, one solution works for both parts today. The solve function is called with the total number of knots (including head) as a parameter.</p>
</div>
<div class="paragraph">
<p>In each step, it updates the head and then all subsequent knots ony by one.</p>
</div>
<div class="paragraph">
<p>The debug function parameter is a clojure that is called after each move for debugging purposes. In the actual solution, an empty function is used. In the test cases, the <code>print</code> function is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solve&lt;F&gt;(data: &amp;PuzzleData, n: usize, debug: F) -&gt; usize
where
    F: Fn(&amp;[(isize, isize)], ((isize, isize), usize), &amp;HashSet&lt;(isize, isize)&gt;) -&gt; (),
{
    let mut seen: HashSet&lt;(isize, isize)&gt; = HashSet::from([(0, 0)]);
    let mut knots: Vec&lt;(isize, isize)&gt; = vec![(0, 0); n];

    for ((dx, dy), s) in data.moves() {
        for _ in 0..*s {
            knots[0].0 += *dx;
            knots[0].1 += *dy;

            for k in 1..n {
                let dx = knots[k].0 - knots[k - 1].0;
                let dy = knots[k].1 - knots[k - 1].1;

                knots[k].0 += (dx &lt; -1 || (dx == -1 &amp;&amp; dy.abs() &gt; 1)) as isize
                    - (dx &gt; 1 || (dx == 1 &amp;&amp; dy.abs() &gt; 1)) as isize;

                knots[k].1 += (dy &lt; -1 || (dy == -1 &amp;&amp; dx.abs() &gt; 1)) as isize
                    - (dy &gt; 1 || (dy == 1 &amp;&amp; dx.abs() &gt; 1)) as isize;
            }

            seen.insert(knots[n - 1]);
        }

        debug(&amp;knots, ((*dx, *dy), *s), &amp;seen);
    }

    seen.len()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_10"><a class="anchor" href="#_tests_10"></a><a class="link" href="#_tests_10">Tests</a></h5>
<div class="paragraph">
<p>The usual tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
"#;

    const CONTENT_2: &amp;str = r#"R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
"#;

    #[test]
    pub fn test_try_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(
            13,
            solve(&amp;data, 2, |knots, mv, seen| print(
                0..=5,
                -5..=0,
                knots,
                mv,
                seen
            ))
        );
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(1, solve(&amp;data, 10, |_, _, _| ()));

        let data = PuzzleData::from(CONTENT_2);
        assert_eq!(
            36,
            solve(&amp;data, 10, |knots, mv, seen| print(
                -11..=14,
                -15..=5,
                knots,
                mv,
                seen
            ))
        );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_7"><a class="anchor" href="#_today_i_learned_7"></a><a class="link" href="#_today_i_learned_7">Today I learned</a></h5>
<div class="paragraph">
<p>That sometimes it is helpful to write <code>as _</code> to give the rust compiler a hint to perform type coercion. Although in the end, I did not use it in my solution.</p>
</div>
<div class="paragraph">
<p>And, today for the first time, I used my scripted solution to submit results. Not because it is faster (who cares about a few seconds) but because it is fun.</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_rust"><a class="anchor" href="#_day_10_rust"></a><a class="link" href="#_day_10_rust">Day 10: rust</a></h3>
<div class="sect3">
<h4 id="_day_10_cathode_ray_tube"><a class="anchor" href="#_day_10_cathode_ray_tube"></a><a class="link" href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/10">AoC|2022|10</a>.</p>
</div>
<div class="paragraph">
<p>Today is about a simple CPU which is used to control a simple display (a cathode-ray tube)</p>
</div>
<div class="sect4">
<h5 id="_input_10"><a class="anchor" href="#_input_10"></a><a class="link" href="#_input_10">Input</a></h5>
<div class="paragraph">
<p>Parsing the input is straight forward. Each line represents either an <code>addx</code> operation or a <code>noop</code> operation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub enum Instr {
        NoOp,
        AddX(isize),
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        instructions: Vec&lt;Instr&gt;,
    }

    impl From&lt;&amp;'static str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'static str) -&gt; Self {
            Self {
                instructions: s
                    .lines()
                    .map(|l| match l {
                        "noop" =&gt; Instr::NoOp,
                        _ =&gt; Instr::AddX(l[5..].parse().unwrap()),
                    })
                    .collect(),
            }
        }
    }

    impl PuzzleData {
        pub fn instructions(&amp;self) -&gt; &amp;[Instr] {
            &amp;&amp;self.instructions
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_9"><a class="anchor" href="#_star_1_9"></a><a class="link" href="#_star_1_9">Star 1</a></h5>
<div class="paragraph">
<p>I created a small model of the CPU:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct Cpu {
    instructions: Vec&lt;Instr&gt;,
    pointer: usize,
    cycle: usize,
    timer: usize,
    x: isize,
}

impl Cpu {
    pub fn init(instructions: &amp;[Instr]) -&gt; Self {
        let mut cpu = Self {
            instructions: Vec::from(instructions),
            pointer: 0,
            cycle: 0,
            timer: 0,
            x: 1,
        };

        // set initial timer if required
        if let Instr::AddX(_) = cpu.instructions[0] {
            cpu.timer = 1;
        }

        cpu
    }

    pub fn step(&amp;mut self) {
        // should not be called if no more instructions
        assert!(self.pointer &lt; self.instructions.len(), "Cpu halted");

        if self.timer &gt; 0 {
            // only decrement timer
            self.timer -= 1;
        } else {
            // apply increment
            if let Instr::AddX(inc) = self.instructions[self.pointer] {
                self.x += inc;
            }

            // increment pointer
            self.pointer += 1;

            // set timer if required
            if self.pointer &lt; self.instructions.len() {
                if let Instr::AddX(_) = self.instructions[self.pointer] {
                    self.timer = 1;
                }
            }
        }

        // increment cycle counter
        self.cycle += 1;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most difficult part was to read the puzzle description carefully. Specifically the part were it says to calculate the signal strength <strong>during</strong> and not <strong>after</strong> the 20th, 60th, &#8230;&#8203; cycle.</p>
</div>
<div class="paragraph">
<p>The rest was just applying the instructions giving in the puzzle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; isize {
    let mut cpu = Cpu::init(data.instructions());

    // we first look during 20th cycle, i.e., after 19th cycle
    for _ in 0..19 {
        cpu.step();
    }
    let mut v = (cpu.cycle as isize + 1) * cpu.x;

    // 5 blocks of 40 cycles
    for _ in 0..5 {
        for _ in 0..40 {
            cpu.step();
        }
        v += (cpu.cycle as isize + 1) * cpu.x;
    }

    v
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_9"><a class="anchor" href="#_star_2_9"></a><a class="link" href="#_star_2_9">Star 2</a></h5>
<div class="paragraph">
<p>Again, reading carefully is important. I did not get the meaning of</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this system, there is no such thing as "vertical position"</pre>
</div>
</div>
<div class="paragraph">
<p>After having that fixed, it was again straight forward. It somehow feels incorrect to manually read the "LCD" to produce the result to enter at the website, hence I created a little helper which recognizes the letters. Since there is nothing to recognize for the sample data, I put the recognition in a separate function to still be able to run my code on the examples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solve_2(data: &amp;PuzzleData) -&gt; [u8; 240] {
    const W: usize = 40;
    const H: usize = 6;

    // initialize lcd with new lines, W + 1 to keep new lines at the and
    let mut lcd = [b'.'; W * H];

    let mut cpu = Cpu::init(data.instructions());
    for row in 0..H {
        for col in 0..W {
            lcd[col as usize + W * row] = if (cpu.x - 1..=cpu.x + 1).contains(&amp;(col as _)) {
                LIT as u8
            } else {
                DARK as u8
            };
            cpu.step();
        }
    }

    lcd
}

pub fn star_2(data: &amp;PuzzleData) -&gt; String {
    solve_2(data).decode(0).unwrap()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_11"><a class="anchor" href="#_tests_11"></a><a class="link" href="#_tests_11">Tests</a></h5>
<div class="paragraph">
<p>A bit of tests, as usual &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_try_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(13_140, star_1(&amp;data));
    }

    #[test]
    pub fn test_solve_2() {
        let data = PuzzleData::from(CONTENT);
        let b = solve_2(&amp;data);
        let mut s = String::with_capacity(41 * 6);
        for row in 0..6 {
            for col in 0..40 {
                s.push(b[col + 40 * row] as _);
            }
            s.push('\n');
        }
        assert_eq!(EXP_2, s);
    }

    #[test]
    pub fn test_simple() {
        let data = PuzzleData::from(CONTENT_SIMPLE);
        let mut cpu = Cpu::init(data.instructions());
        let r = (0..5)
            .map(|_| {
                cpu.step();
                cpu.x
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();
        let exp: &amp;[isize] = &amp;[1, 1, 4, 4, -1];
        assert_eq!(exp, r);
    }

    const CONTENT_SIMPLE: &amp;str = r#"noop
addx 3
addx -5"#;

    const EXP_2: &amp;str = r"##..##..##..##..##..##..##..##..##..##..
###...###...###...###...###...###...###.
####....####....####....####....####....
#####.....#####.....#####.....#####.....
######......######......######......####
#######.......#######.......#######.....
";

    const CONTENT: &amp;str = r#"addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
"#;
}</code></pre>
</div>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_rust"><a class="anchor" href="#_day_11_rust"></a><a class="link" href="#_day_11_rust">Day 11: rust</a></h3>
<div class="sect3">
<h4 id="_day_11_monkey_in_the_middle"><a class="anchor" href="#_day_11_monkey_in_the_middle"></a><a class="link" href="#_day_11_monkey_in_the_middle">Day 11: Monkey in the Middle</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/11">AoC|2022|11</a>.</p>
</div>
<div class="paragraph">
<p>It was quite tedious today for me to create the solution.</p>
</div>
<div class="paragraph">
<p>I liked the twist in part 2. Since each monkey does a modulo <code>test</code> before passing on the item, we can safely do a modulo with the product of all tests of all monkeys to keep the numbers small. Still took me a while to complete part two because I just replaced the <code>/ 3</code> from the first part with <code>/ mod</code> in the second part which is obviously not the same as <code>% mod</code>. And I have to confess that my first attempt was to use 128bit numbers.</p>
</div>
<div class="sect4">
<h5 id="_input_11"><a class="anchor" href="#_input_11"></a><a class="link" href="#_input_11">Input</a></h5>
<div class="paragraph">
<p>Parsing was a pain today. I almost regret my decision to not use external dependencies (and thus not use Regex) &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub enum Operation {
        Plus(usize),
        Times(usize),
        Square,
        Double,
    }

    impl Operation {
        pub fn apply(&amp;self, item: usize) -&gt; usize {
            match self {
                Operation::Plus(v) =&gt; item + v,
                Operation::Times(v) =&gt; item * v,
                Operation::Square =&gt; item * item,
                Operation::Double =&gt; item + item,
            }
        }
    }

    #[derive(Debug, PartialEq, Eq, Clone)]
    pub struct Monkey {
        pub worries: Vec&lt;usize&gt;,
        pub upd: Operation,
        pub test: usize,
        pub if_true: usize,
        pub if_false: usize,
    }

    impl From&lt;&amp;'static str&gt; for Monkey {
        fn from(monkey: &amp;'static str) -&gt; Self {
            let words = monkey.split_ascii_whitespace();

            let mut words = words.skip(4); // Monkey &lt;id&gt;: Starting items:

            let mut worries = Vec::new();
            let mut word = words.next().unwrap();
            while word != "Operation:" {
                worries.push(word.trim_end_matches(',').parse().unwrap());
                word = words.next().unwrap();
            }

            let mut words = words.skip(3); // new = old

            let upd = match (words.next().unwrap(), words.next().unwrap()) {
                ("*", "old") =&gt; Operation::Square,
                ("+", "old") =&gt; Operation::Double,
                ("*", v) =&gt; Operation::Times(v.parse().unwrap()),
                ("+", v) =&gt; Operation::Plus(v.parse().unwrap()),
                _ =&gt; unreachable!(),
            };

            let mut words = words.skip(3); // Test: divisible by

            let test = words.next().unwrap().parse().unwrap();

            let mut words = words.skip(5); // If true: throw to monkey

            let if_true = words.next().unwrap().parse().unwrap();

            let mut words = words.skip(5); // If false: throw to monkey

            let if_false = words.next().unwrap().parse().unwrap();

            Self {
                worries,
                upd,
                test,
                if_true,
                if_false,
            }
        }
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        monkeys: Vec&lt;Monkey&gt;,
    }

    impl From&lt;&amp;'static str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'static str) -&gt; Self {
            Self {
                monkeys: s.split("\n\n").map(Monkey::from).collect(),
            }
        }
    }

    impl PuzzleData {
        pub fn monkeys(&amp;self) -&gt; &amp;[Monkey] {
            &amp;self.monkeys
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution_2"><a class="anchor" href="#_solution_2"></a><a class="link" href="#_solution_2">Solution</a></h5>
<div class="paragraph">
<p>Here is my solution for both parts. The <code>solve</code> function is called with <code>div = 3</code> for the first part and <code>div = 1</code> for the second.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn round(monkeys: &amp;mut Vec&lt;Monkey&gt;, counts: &amp;mut Vec&lt;usize&gt;, div: usize, m: usize) {
    for id in 0..monkeys.len() {
        counts[id] += monkeys[id].worries.len();
        for k in 0..monkeys[id].worries.len() {
            let worry = (monkeys[id].upd.apply(monkeys[id].worries[k]) / div) % m;
            let target = if worry % monkeys[id].test == 0 {
                monkeys[id].if_true
            } else {
                monkeys[id].if_false
            };
            monkeys[target].worries.push(worry);
        }
        monkeys[id].worries.clear();
    }
}

pub fn solve(data: &amp;PuzzleData, div: usize, rounds: usize) -&gt; usize {
    let mut monkeys = Vec::from(data.monkeys());
    let mut counts = vec![0; monkeys.len()];
    let m = monkeys.iter().map(|monkey| monkey.test).product();

    for _ in 0..rounds {
        round(&amp;mut monkeys, &amp;mut counts, div, m);
    }

    counts.sort_unstable();

    counts.pop().unwrap() as usize * counts.pop().unwrap() as usize
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_12"><a class="anchor" href="#_tests_12"></a><a class="link" href="#_tests_12">Tests</a></h5>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>and the tests</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"Monkey 0:
Starting items: 79, 98
Operation: new = old * 19
Test: divisible by 23
  If true: throw to monkey 2
  If false: throw to monkey 3

Monkey 1:
Starting items: 54, 65, 75, 74
Operation: new = old + 6
Test: divisible by 19
  If true: throw to monkey 2
  If false: throw to monkey 0

Monkey 2:
Starting items: 79, 60, 97
Operation: new = old * old
Test: divisible by 13
  If true: throw to monkey 1
  If false: throw to monkey 3

Monkey 3:
Starting items: 74
Operation: new = old + 3
Test: divisible by 17
  If true: throw to monkey 0
  If false: throw to monkey 1
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_round() {
        let data = PuzzleData::from(CONTENT);
        let mut monkeys = Vec::from(data.monkeys());
        let mut counts = vec![0; monkeys.len()];
        round(&amp;mut monkeys, &amp;mut counts, 3, usize::MAX);
        assert_eq!(vec![20, 23, 27, 26], monkeys[0].worries);
        assert_eq!(vec![2080, 25, 167, 207, 401, 1046], monkeys[1].worries);
        assert!(monkeys[2].worries.is_empty());
        assert!(monkeys[3].worries.is_empty());
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(10605, solve(&amp;data, 3, 20));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);

        assert_eq!(4 * 6, solve(&amp;data, 1, 1));
        assert_eq!(99 * 103, solve(&amp;data, 1, 20));

        assert_eq!(2_713_310_158, solve(&amp;data, 1, 10_000));
    }
}</code></pre>
</div>
</div>
<a id="day12" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_12_rust"><a class="anchor" href="#_day_12_rust"></a><a class="link" href="#_day_12_rust">Day 12: rust</a></h3>
<div class="sect3">
<h4 id="_day_12_hill_climbing_algorithm"><a class="anchor" href="#_day_12_hill_climbing_algorithm"></a><a class="link" href="#_day_12_hill_climbing_algorithm">Day 12: Hill Climbing Algorithm</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/12">AoC|2022|12</a>.</p>
</div>
<div class="paragraph">
<p>The first path finding challenge in 2022&#8217;s AoC edition ;)</p>
</div>
<div class="sect4">
<h5 id="_input_12"><a class="anchor" href="#_input_12"></a><a class="link" href="#_input_12">Input</a></h5>
<div class="paragraph">
<p>I parse the input into a grid of bytes stored in a vec and additionally determine the starting position, the target position and the width of the grid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub grid: Vec&lt;u8&gt;,
        pub width: usize,
        pub start: usize,
        pub target: usize,
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            let width = s.find('\n').unwrap();

            let mut grid: Vec&lt;_&gt; = s
                .as_bytes()
                .iter()
                .cloned()
                .filter(|b| *b != b'\n')
                .collect();
            let start = grid.iter().position(|&amp;b| b == b'S').unwrap();
            let target = grid.iter().position(|&amp;b| b == b'E').unwrap();

            grid[start] = b'a';
            grid[target] = b'z';

            Self {
                grid,
                width,
                start,
                target,
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_10"><a class="anchor" href="#_star_1_10"></a><a class="link" href="#_star_1_10">Star 1</a></h5>
<div class="paragraph">
<p>The shortest path is found by a breadth first traversal.</p>
</div>
<div class="paragraph">
<p>The function <code>shortest_path</code> returns an option with a <code>None</code> value in case no path is found. My initial version just panicked in that case which turned out to not be good enough for part 2.</p>
</div>
<div class="paragraph">
<p>Today, I made the baddest mistake ever: I put the wrong number in my test (32 instead of 31) and was trying to figure out for quite some while where I inserted an off-by-one error in my code until I figured that my expected value was wrong.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn shortest_path(data: &amp;PuzzleData, start: usize) -&gt; Option&lt;usize&gt; {
    let mut queue = VecDeque::new();
    queue.push_back((0, start));

    let mut seen = vec![false; data.grid.len()];
    seen[start] = true;

    let height = data.grid.len() / data.width;

    while let Some((steps, pos)) = queue.pop_front() {
        if pos == data.target {
            return Some(steps);
        }

        let x = pos % data.width;
        let y = pos / data.width;

        for (chk, nxt) in [
            (x &gt; 0, pos as isize - 1),
            (x &lt; data.width - 1, pos as isize + 1),
            (y &gt; 0, pos as isize - data.width as isize),
            (y &lt; height - 1, pos as isize + data.width as isize),
        ] {
            if chk &amp;&amp; !seen[nxt as usize] &amp;&amp; data.grid[nxt as usize] &lt;= data.grid[pos] + 1 {
                queue.push_back((steps + 1, nxt as _));
                seen[nxt as usize] = true;
            }
        }
    }

    None
}

pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    shortest_path(data, data.start).unwrap()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_10"><a class="anchor" href="#_star_2_10"></a><a class="link" href="#_star_2_10">Star 2</a></h5>
<div class="paragraph">
<p>Just perform shortest path calculation for all possible starting positions (that was my solution to submit the answer)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2_original(data: &amp;PuzzleData) -&gt; usize {
    (0..data.grid.len())
        .filter(|&amp;k| data.grid[k] == b'a')
        .filter_map(|start| shortest_path(data, start))
        .min()
        .unwrap()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then I realized it is much simpler if I just reverse the search direction and look for the shortest path from the target to any 'a'. So I did that to have another sub 1ms solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn shortest_path_2&lt;F, G&gt;(data: &amp;PuzzleData, start: usize, reached: F, check: G) -&gt; Option&lt;usize&gt;
where
    F: Fn(usize) -&gt; bool,
    G: Fn(u8, u8) -&gt; bool,
{
    let mut queue = VecDeque::new();
    queue.push_back((0, start));

    let mut seen = vec![false; data.grid.len()];
    seen[start] = true;

    let height = data.grid.len() / data.width;

    while let Some((steps, pos)) = queue.pop_front() {
        if reached(pos) {
            return Some(steps);
        }

        let x = pos % data.width;
        let y = pos / data.width;

        for (chk, nxt) in [
            (x &gt; 0, pos as isize - 1),
            (x &lt; data.width - 1, pos as isize + 1),
            (y &gt; 0, pos as isize - data.width as isize),
            (y &lt; height - 1, pos as isize + data.width as isize),
        ] {
            if chk &amp;&amp; !seen[nxt as usize] &amp;&amp; check(data.grid[pos], data.grid[nxt as usize]) {
                queue.push_back((steps + 1, nxt as _));
                seen[nxt as usize] = true;
            }
        }
    }

    None
}

pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    shortest_path_2(
        data,
        data.target,
        |pos| data.grid[pos] == b'a',
        |f, t| f &lt;= t + 1,
    )
    .unwrap()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>shortest_path_2</code> function is generic to also work for part 1, but I did not change it in my code. Here is how to call it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-rust" data-lang="rust">shortest_path_2(data, data.start, |pos| pos == data.target, |f, t| t &lt;= f + 1).unwrap()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_13"><a class="anchor" href="#_tests_13"></a><a class="link" href="#_tests_13">Tests</a></h5>
<div class="paragraph">
<p>And the mandatory tests. But be careful, if a test of the type <code>expected == actual</code> fails, there are two possible reasons: <code>actual</code> can be wrong or <code>expected</code> can be wrong.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(8, data.width);
        assert_eq!(0, data.start);
        assert_eq!(21, data.target);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(31, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(29, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day13" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_13_rust"><a class="anchor" href="#_day_13_rust"></a><a class="link" href="#_day_13_rust">Day 13: rust</a></h3>
<div class="sect3">
<h4 id="_day_13_distress_signal"><a class="anchor" href="#_day_13_distress_signal"></a><a class="link" href="#_day_13_distress_signal">Day 13: Distress Signal</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/13">AoC|2022|13</a>.</p>
</div>
<div class="paragraph">
<p>My initial solution was based on "If the input looks like a tree structure, parse it into a tree structure!"</p>
</div>
<div class="sect4">
<h5 id="_input_13"><a class="anchor" href="#_input_13"></a><a class="link" href="#_input_13">Input</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub mod input {
        use super::node::Node;

        pub struct PuzzleData {
            pub nodes: Vec&lt;Node&gt;,
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
            fn from(s: &amp;'a str) -&gt; Self {
                Self {
                    nodes: s
                        .lines()
                        .filter(|l| !l.is_empty())
                        .map(|l| Node::from(l))
                        .collect(),
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution_3"><a class="anchor" href="#_solution_3"></a><a class="link" href="#_solution_3">Solution</a></h5>
<div class="paragraph">
<p>The whole work for the solution is in the recursive <code>Node</code> enum modeling the trees represented by the puzzle input with its implementation. Namely recursive parsing in the <code>parse</code> function and comparison in the <code>Ord</code> trait implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub mod node {
        //! Tree structure for recursive lists from puzzle
        use std::cmp::Ordering;

        #[derive(Debug, Eq, PartialEq, Clone)]
        pub enum Node {
            List(Box&lt;[Node]&gt;),
            Value(usize),
        }

        impl std::fmt::Display for Node {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                match self {
                    Node::List(list) =&gt; {
                        '['.fmt(f)?;
                        for n in list.iter().take(1) {
                            n.fmt(f)?;
                        }
                        for n in list.iter().skip(1) {
                            ','.fmt(f)?;
                            n.fmt(f)?;
                        }
                        ']'.fmt(f)?;
                    }
                    Node::Value(value) =&gt; value.fmt(f)?,
                }

                Ok(())
            }
        }

        impl&lt;T&gt; From&lt;T&gt; for Node
        where
            T: AsRef&lt;[u8]&gt;,
        {
            fn from(s: T) -&gt; Self {
                Self::parse(s.as_ref(), 0).0
            }
        }

        impl Ord for Node {
            fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
                match (self, other) {
                    (Node::List(lhs), Node::List(rhs)) =&gt; {
                        for k in 0..lhs.len().min(rhs.len()) {
                            let o = lhs[k].cmp(&amp;rhs[k]);
                            if o != Ordering::Equal {
                                return o;
                            }
                        }
                        lhs.len().cmp(&amp;rhs.len())
                    }
                    (Node::Value(lhs), Node::Value(rhs)) =&gt; lhs.cmp(rhs),
                    (_, Node::Value(rhs)) =&gt; self.cmp(&amp;Node::List(vec![Node::Value(*rhs)].into())),
                    (Node::Value(lhs), _) =&gt; Node::List(vec![Node::Value(*lhs)].into()).cmp(other),
                }
            }
        }

        impl PartialOrd for Node {
            fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
                Some(self.cmp(other))
            }
        }

        impl Node {
            fn parse(s: &amp;[u8], pos: usize) -&gt; (Self, usize) {
                if s[pos] == b'[' &amp;&amp; s[pos + 1] == b']' {
                    // handle empty list separately
                    (Self::List(vec![].into()), 2)
                } else if s[pos] == b'[' {
                    let mut v = Vec::new();
                    let mut len = 1;
                    loop {
                        let (n, l) = Self::parse(s, pos + len);
                        v.push(n);
                        len += l + 1;
                        if s[pos + len - 1] == b']' {
                            break;
                        }
                    }
                    (Self::List(v.into()), len)
                } else {
                    let mut v = 0;
                    let mut len = 0;
                    while pos + len &lt; s.len() &amp;&amp; s[pos + len] &gt;= b'0' &amp;&amp; s[pos + len] &lt;= b'9' {
                        v = v * 10 + (s[pos + len] - b'0') as usize;
                        len += 1;
                    }
                    (Self::Value(v), len)
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_11"><a class="anchor" href="#_star_1_11"></a><a class="link" href="#_star_1_11">Star 1</a></h5>
<div class="paragraph">
<p>Do the pairwise comparisons.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        data.nodes
            .iter()
            .step_by(2)
            .zip(data.nodes.iter().skip(1).step_by(2))
            .enumerate()
            .filter(|(_, (a, b))| a.cmp(b) != Ordering::Greater)
            .fold(0, |s, (k, _)| s + k + 1)
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_11"><a class="anchor" href="#_star_2_11"></a><a class="link" href="#_star_2_11">Star 2</a></h5>
<div class="paragraph">
<p>Find the position of the divider packets after sorting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        let mut v = data.nodes.clone();
        v.push(Node::from("[[2]]"));
        v.push(Node::from("[[6]]"));
        v.sort_unstable();

        let a = v.iter().position(|n| n == &amp;Node::from("[[2]]")).unwrap();
        let b = v.iter().position(|n| n == &amp;Node::from("[[6]]")).unwrap();

        (a + 1) * (b + 1)
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_14"><a class="anchor" href="#_tests_14"></a><a class="link" href="#_tests_14">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree::node::Node;

        #[test]
        pub fn test_parse() {
            let s = "[1,[2,[3,[4,[5,6,7]]]],8,9]";
            let n = Node::from(s);
            println!("{n:?}");
            assert_eq!(s, n.to_string());
        }

        #[test]
        pub fn test_cmp() {
            let nodes = PuzzleData::from(CONTENT).nodes;
            let cmp = nodes
                .iter()
                .step_by(2)
                .zip(nodes.iter().skip(1).step_by(2))
                .map(|(a, b)| a.cmp(b))
                .collect::&lt;Vec&lt;_&gt;&gt;();
            println!("{cmp:?}");
            assert_eq!(
                vec![
                    Ordering::Less,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Greater
                ],
                cmp
            );
        }

        #[test]
        pub fn test_star_1() {
            assert_eq!(13, star_1(&amp;PuzzleData::from(CONTENT)))
        }

        #[test]
        pub fn test_star_2() {
            assert_eq!(140, star_2(&amp;PuzzleData::from(CONTENT)))
        }

        const CONTENT: &amp;str = r#"[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
"#;
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_without_using_heap"><a class="anchor" href="#_alternative_without_using_heap"></a><a class="link" href="#_alternative_without_using_heap">Alternative without using heap</a></h5>
<div class="paragraph">
<p>Later on, I thought it should be possible to implement a solution that does not require any heap allocations by directly iterating on the input data. I added this in a variant of my solution in <code>mod iter</code>. You can run this variant using <code>cargo run --release --features no-heap</code>. Interestingly it is not really performing any better than the original solution. The advantage for the second part is probably mainly caused by avoiding to sort.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod iter {
    use self::node::List;
    use self::{input::PuzzleData, node::Node};
    use mr_kaffee_aoc::{Puzzle, Star};
    use std::cmp::Ordering;

    /// the puzzle
    pub fn puzzle() -&gt; Puzzle&lt;'static, PuzzleData&lt;'static&gt;, usize, usize, usize, usize&gt; {
        Puzzle {
            year: 2022,
            day: 13,
            input: include_str!("../input.txt"),
            star1: Some(Star {
                name: "Star 1",
                f: &amp;star_1,
                exp: Some(5_675),
            }),
            star2: Some(Star {
                name: "Star 2",
                f: &amp;star_2,
                exp: Some(20_383),
            }),
        }
    }

    pub mod input {
        pub struct PuzzleData&lt;'a&gt; {
            pub input: &amp;'a str,
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData&lt;'a&gt; {
            fn from(input: &amp;'a str) -&gt; Self {
                Self { input }
            }
        }
    }

    pub mod node {
        use std::cmp::Ordering;

        #[derive(Debug, Clone)]
        pub struct List&lt;'a&gt; {
            data: &amp;'a [u8],
            pos: usize,
        }

        #[derive(Debug)]
        pub enum Node&lt;'a&gt; {
            List(List&lt;'a&gt;),
            Value(usize),
        }

        impl&lt;'a&gt; std::fmt::Display for Node&lt;'a&gt; {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                match self {
                    Node::List(list) =&gt; list.fmt(f),
                    Node::Value(value) =&gt; value.fmt(f),
                }
            }
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Node&lt;'a&gt; {
            fn from(s: &amp;'a str) -&gt; Self {
                if s.starts_with('[') {
                    Self::List(List::from(s))
                } else {
                    Self::Value(s.parse().unwrap())
                }
            }
        }

        impl&lt;'a&gt; std::fmt::Display for List&lt;'a&gt; {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                let mut level = 1;
                '['.fmt(f)?;
                for &amp;b in &amp;self.data[self.pos..] {
                    level = match b {
                        b'[' =&gt; level + 1,
                        b']' =&gt; level - 1,
                        _ =&gt; level,
                    };
                    (b as char).fmt(f)?;
                    if level == 0 {
                        break;
                    }
                }
                Ok(())
            }
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for List&lt;'a&gt; {
            fn from(s: &amp;'a str) -&gt; Self {
                let data = s.as_bytes();
                assert_eq!(data[0], b'[');
                Self { data, pos: 1 }
            }
        }

        impl&lt;'a&gt; Iterator for List&lt;'a&gt; {
            type Item = Node&lt;'a&gt;;

            fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
                if self.pos &gt;= self.data.len() || self.data[self.pos] == b']' {
                    None
                } else if self.data[self.pos] == b'[' {
                    self.pos += 1;
                    let nxt = Self::Item::List(List {
                        pos: self.pos,
                        data: self.data,
                    });

                    let mut level = 1;
                    while level &gt; 0 {
                        if self.data[self.pos] == b'[' {
                            level += 1
                        } else if self.data[self.pos] == b']' {
                            level -= 1
                        }
                        self.pos += 1;
                    }
                    if self.pos &lt; self.data.len() &amp;&amp; self.data[self.pos] == b',' {
                        self.pos += 1;
                    }

                    Some(nxt)
                } else {
                    let mut v = 0;
                    while self.data[self.pos] &gt;= b'0' &amp;&amp; self.data[self.pos] &lt;= b'9' {
                        v = 10 * v + (self.data[self.pos] - b'0') as usize;
                        self.pos += 1;
                    }
                    if self.data[self.pos] == b',' {
                        self.pos += 1;
                    }

                    Some(Self::Item::Value(v))
                }
            }
        }

        impl&lt;'a&gt; Ord for Node&lt;'a&gt; {
            fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
                match (self, other) {
                    (Node::Value(lhs), Node::Value(rhs)) =&gt; lhs.cmp(rhs),
                    (Node::List(lhs), Node::List(rhs)) =&gt; {
                        let (mut lhs, mut rhs) = (lhs.clone(), rhs.clone());
                        let (mut exhausted, mut ord) = (false, Ordering::Equal);
                        while (false, Ordering::Equal) == (exhausted, ord) {
                            (exhausted, ord) = match (lhs.next(), rhs.next()) {
                                (None, None) =&gt; (true, Ordering::Equal),
                                (None, Some(_)) =&gt; (true, Ordering::Less),
                                (Some(_), None) =&gt; (true, Ordering::Greater),
                                (Some(lhs), Some(rhs)) =&gt; (false, lhs.cmp(&amp;rhs)),
                            }
                        }
                        ord
                    }
                    (Node::List(lhs), rhs) =&gt; {
                        let mut lhs = lhs.clone();
                        match (lhs.next(), lhs.next()) {
                            (Some(lhs), Some(_)) =&gt; match lhs.cmp(rhs) {
                                // rhs is exhausted before lhs
                                Ordering::Less =&gt; Ordering::Less,
                                _ =&gt; Ordering::Greater,
                            },
                            (Some(lhs), None) =&gt; lhs.cmp(rhs),
                            (None, _) =&gt; Ordering::Less,
                        }
                    }
                    (lhs, Node::List(rhs)) =&gt; {
                        let mut rhs = rhs.clone();
                        match (rhs.next(), rhs.next()) {
                            (Some(rhs), Some(_)) =&gt; match lhs.cmp(&amp;rhs) {
                                // lhs is exhausted before rhs
                                Ordering::Greater =&gt; Ordering::Greater,
                                _ =&gt; Ordering::Less,
                            },
                            (Some(rhs), None) =&gt; lhs.cmp(&amp;rhs),
                            (None, _) =&gt; Ordering::Greater,
                        }
                    }
                }
            }
        }

        impl&lt;'a&gt; PartialOrd for Node&lt;'a&gt; {
            fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
                Some(self.cmp(other))
            }
        }

        impl&lt;'a&gt; PartialEq for Node&lt;'a&gt; {
            fn eq(&amp;self, other: &amp;Self) -&gt; bool {
                self.cmp(other) == Ordering::Equal
            }
        }

        impl&lt;'a&gt; Eq for Node&lt;'a&gt; {}
    }

    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        let mut lines = data.input.lines().filter(|l| !l.is_empty());
        let mut idx = 0;
        let mut result = 0;
        while let (Some(a), Some(b)) = (lines.next(), lines.next()) {
            idx += 1;
            if Node::from(a).cmp(&amp;Node::from(b)) != Ordering::Greater {
                result += idx;
            }
        }

        result
    }

    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        let n_1 = List::from("[[2]]");
        let n_2 = List::from("[[6]]");

        let (cnt_1, cnt_2) =
            data.input
                .lines()
                .filter(|l| !l.is_empty())
                .fold((1, 2), |(cnt_1, cnt_2), l| {
                    if n_1.clone().cmp(List::from(l)) == Ordering::Greater {
                        (cnt_1 + 1, cnt_2 + 1)
                    } else if n_2.clone().cmp(List::from(l)) == Ordering::Greater {
                        (cnt_1, cnt_2 + 1)
                    } else {
                        (cnt_1, cnt_2)
                    }
                });

        cnt_1 * cnt_2
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::iter::node::{List, Node};

        #[test]
        pub fn test_next() {
            let mut list = List::from("[10,[[9,10,0],2]]");
            assert_eq!(Some("10".into()), list.next().map(|n| n.to_string()));
            assert_eq!(
                Some("[[9,10,0],2]".into()),
                list.next().map(|n| n.to_string())
            );
            assert!(list.next().is_none());
        }

        #[test]
        pub fn test_cmp() {
            let nodes = CONTENT
                .lines()
                .filter(|l| !l.is_empty())
                .map(List::from)
                .map(Node::List)
                .collect::&lt;Vec&lt;_&gt;&gt;();

            let cmp = nodes
                .iter()
                .step_by(2)
                .zip(nodes.iter().skip(1).step_by(2))
                .map(|(a, b)| a.cmp(b))
                .collect::&lt;Vec&lt;_&gt;&gt;();
            println!("{cmp:?}");
            assert_eq!(
                vec![
                    Ordering::Less,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Greater
                ],
                cmp
            );
        }

        #[test]
        pub fn test_star_1() {
            assert_eq!(13, star_1(&amp;PuzzleData::from(CONTENT)))
        }

        #[test]
        pub fn test_star_2() {
            assert_eq!(140, star_2(&amp;PuzzleData::from(CONTENT)))
        }

        const CONTENT: &amp;str = r#"[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
"#;
    }
}</code></pre>
</div>
</div>
<a id="day14" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_14_rust"><a class="anchor" href="#_day_14_rust"></a><a class="link" href="#_day_14_rust">Day 14: rust</a></h3>
<div class="sect3">
<h4 id="_day_14_regolith_reservoir"><a class="anchor" href="#_day_14_regolith_reservoir"></a><a class="link" href="#_day_14_regolith_reservoir">Day 14: Regolith Reservoir</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/14">AoC|2022|14</a>.</p>
</div>
<div class="paragraph">
<p>I was remembered of <a href="https://adventofcode.com/2018/day/17">AoC|2018|17</a> even without the hint in the puzzle.</p>
</div>
<div class="paragraph">
<p>I don&#8217;t think my solution is very elegant, but at the moment, I do not have an idea how to create a nice one &#8230;&#8203;</p>
</div>
<div class="sect4">
<h5 id="_input_14"><a class="anchor" href="#_input_14"></a><a class="link" href="#_input_14">Input</a></h5>
<div class="paragraph">
<p>I parse the input in a vec of paths, where each path is vec of points. The structure <code>PuzzleData</code> has methods to compute the bounding box for all points (<code>bbox</code>) and build a 2D grid using the paths specified (<code>grid</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        paths: Vec&lt;Vec&lt;(isize, isize)&gt;&gt;,
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            Self {
                paths: s
                    .lines()
                    .map(|l| {
                        l.split(" -&gt; ")
                            .map(|c| c.split_once(',').unwrap())
                            .map(|(x, y)| (x.parse().unwrap(), y.parse().unwrap()))
                            .collect()
                    })
                    .collect(),
            }
        }
    }

    impl&lt;'a&gt; PuzzleData {
        pub fn bbox(&amp;self) -&gt; (isize, isize, isize, isize) {
            self.paths.iter().fold((500, 0, 501, 1), |bbox, v| {
                v.iter().fold(bbox, |(x_mn, y_mn, x_mx, y_mx), (x, y)| {
                    (x_mn.min(*x), y_mn.min(*y), x_mx.max(x + 1), y_mx.max(y + 1))
                })
            })
        }

        /// get a grid as flat list of chars, the width of the grid, and the point of sand inflow
        pub fn grid(&amp;self) -&gt; (Vec&lt;char&gt;, usize, (usize, usize)) {
            let (x_mn, y_mn, x_mx, y_mx) = self.bbox();
            let width = (x_mx - x_mn) as usize;
            let height = (y_mx - y_mn) as usize;
            let mut grid = vec!['.'; width * height];

            for path in &amp;self.paths {
                for k in 1..path.len() {
                    let (dx, dy, len) = if path[k].0 &gt; path[k - 1].0 {
                        assert!(path[k].1 == path[k - 1].1);
                        (1, 0, path[k].0 - path[k - 1].0)
                    } else if path[k].0 &lt; path[k - 1].0 {
                        assert!(path[k].1 == path[k - 1].1);
                        (-1, 0, path[k - 1].0 - path[k].0)
                    } else if path[k].1 &gt; path[k - 1].1 {
                        assert!(path[k].0 == path[k - 1].0);
                        (0, 1, path[k].1 - path[k - 1].1)
                    } else if path[k].1 &lt; path[k - 1].1 {
                        assert!(path[k].0 == path[k - 1].0);
                        (0, -1, path[k - 1].1 - path[k].1)
                    } else {
                        unreachable!()
                    };

                    let x0 = path[k - 1].0 - x_mn;
                    let y0 = path[k - 1].1 - y_mn;
                    for k in 0..len + 1 {
                        grid[(x0 + dx * k) as usize + (y0 + dy * k) as usize * width] = '#';
                    }
                }
            }

            (grid, width, ((500 - x_mn) as _, (0 - y_mn) as _))
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_12"><a class="anchor" href="#_star_1_12"></a><a class="link" href="#_star_1_12">Star 1</a></h5>
<div class="paragraph">
<p>Just let the sand flow in the grid until sand starts flowing off to the big void.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let (mut grid, width, (x_0, y_0)) = data.grid();
    let height = grid.len() / width;

    let mut cnt = 0;
    'inflow: loop {
        // first candidate is spot directly on top of something solid
        let mut x = x_0;
        let mut y = match (y_0..height).find(|y| grid[x + y * width] != '.') {
            Some(y) =&gt; y - 1,
            None =&gt; unreachable!("Nothing solid found to start with"),
        };

        loop {
            if y == height - 1 {
                // go to void below
                break 'inflow;
            }

            if grid[x + (y + 1) * width] == '.' {
                // bubble down
                y += 1;
            } else if x &gt; 0 &amp;&amp; grid[x - 1 + (y + 1) * width] == '.' {
                // bubble down-left
                y += 1;
                x -= 1;
            } else if x &lt; width - 1 &amp;&amp; grid[x + 1 + (y + 1) * width] == '.' {
                // bubble down-right
                y += 1;
                x += 1;
            } else if x == 0 || x == width - 1 {
                // go to void left/right
                break 'inflow;
            } else {
                grid[x + y * width] = 'o';
                cnt += 1;
                break;
            }
        }
    }

    cnt
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_12"><a class="anchor" href="#_star_2_12"></a><a class="link" href="#_star_2_12">Star 2</a></h5>
<div class="paragraph">
<p>Create a grid with an additional line added at the bottom and big enough to make sure nothing flows off to the void anymore. The only thing on top to do is to change the condition for exiting the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let (grid_0, width_0, (x_0_0, y_0)) = data.grid();
    let height_0 = grid_0.len() / width_0;

    // wrap the grid in a bigger grid (append height columns to the left and right and an additional row below)
    let width = width_0 + 2 * height_0;
    let height = height_0 + 1;
    let mut grid = vec!['.'; width * height];
    for y in 0..height_0 {
        for x in 0..width_0 {
            grid[x + height_0 + y * width] = grid_0[x + y * width_0];
        }
    }
    let x_0 = x_0_0 + height_0;

    let mut cnt = 0;
    loop {
        // first candidate is spot directly on top of something solid
        let mut x = x_0;
        let mut y = match (y_0..height).find(|y| grid[x + y * width] != '.') {
            Some(y) =&gt; {
                if y == y_0 {
                    // No more sand can enter
                    break;
                }
                y - 1
            }
            None =&gt; unreachable!("Nothing solid found to start with"),
        };

        loop {
            if y == height - 1 {
                // floor reached
                grid[x + y * width] = 'o';
                cnt += 1;
                break;
            }

            if grid[x + (y + 1) * width] == '.' {
                // bubble down
                y += 1;
            } else if x &gt; 0 &amp;&amp; grid[x - 1 + (y + 1) * width] == '.' {
                // bubble down-left
                y += 1;
                x -= 1;
            } else if x &lt; width - 1 &amp;&amp; grid[x + 1 + (y + 1) * width] == '.' {
                // bubble down-right
                y += 1;
                x += 1;
            } else if x == 0 || x == width - 1 {
                // the grid should not be too small
                unreachable!("Grid is too small!");
            } else {
                // cannot move any further
                grid[x + y * width] = 'o';
                cnt += 1;
                break;
            }
        }
    }

    cnt
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_15"><a class="anchor" href="#_tests_15"></a><a class="link" href="#_tests_15">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"498,4 -&gt; 498,6 -&gt; 496,6
503,4 -&gt; 502,4 -&gt; 502,9 -&gt; 494,9
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");

        let bbox = data.bbox();
        assert_eq!((494, 0, 504, 10), bbox);

        let (grid, width, (x0, y0)) = data.grid();
        assert_eq!((6, 0), (x0, y0));
        assert_eq!(10, width);
        let exp = "............................................#...##....#...#...###...#.........#.........#.#########.";
        assert_eq!(exp.chars().collect::&lt;Vec&lt;_&gt;&gt;(), grid);
        for row in 0..grid.len() / width {
            for col in 0..width {
                print!("{}", grid[col + row * width]);
            }
            println!();
        }
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(24, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(93, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>