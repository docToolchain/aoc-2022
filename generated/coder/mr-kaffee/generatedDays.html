<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: mr-kaffee</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_mr_kaffee">mr-kaffee</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_rust">Day 00: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_00_hello_world">Day 00: Hello World!</a>
<ul class="sectlevel4">
<li><a href="#_run_solutions_for_several_days">Run solutions for several days</a></li>
<li><a href="#_general_structure">General structure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_1_calorie_counting">Day 1: Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_input">Input</a></li>
<li><a href="#_star_1">Star 1</a></li>
<li><a href="#_star_2">Star 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
<li><a href="#_today_i_learned">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_2_rock_paper_scissors">Day 2: Rock Paper Scissors</a>
<ul class="sectlevel4">
<li><a href="#_input_2">Input</a></li>
<li><a href="#_star_1_2">Star 1</a></li>
<li><a href="#_star_2_2">Star 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
<li><a href="#_today_i_learned_2">Today I learned</a></li>
<li><a href="#_alternative_based_on_direct_calculations">Alternative based on direct calculations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_3_rucksack_reorganization">Day 3: Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_input_3">Input</a></li>
<li><a href="#_star_1_3">Star 1</a></li>
<li><a href="#_star_2_3">Star 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
<li><a href="#_today_i_learned_3">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_4_camp_cleanup">Day 4: Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_input_4">Input</a></li>
<li><a href="#_star_1_4">Star 1</a></li>
<li><a href="#_star_2_4">Star 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
<li><a href="#_today_i_learned_4">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_5_supply_stacks">Day 5: Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_input_5">Input</a></li>
<li><a href="#_star_1_5">Star 1</a></li>
<li><a href="#_star_2_5">Star 2</a></li>
<li><a href="#_tests_6">Tests</a></li>
<li><a href="#_today_i_learned_5">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_6_tuning_trouble">Day 6: Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_input_6">Input</a></li>
<li><a href="#_star_1_6">Star 1</a></li>
<li><a href="#_star_2_6">Star 2</a></li>
<li><a href="#_alternative">Alternative</a></li>
<li><a href="#_tests_7">Tests</a></li>
<li><a href="#_today_i_learned_6">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_7_no_space_left_on_device">Day 7: No Space Left On Device</a>
<ul class="sectlevel4">
<li><a href="#_input_7">Input</a></li>
<li><a href="#_star_1_7">Star 1</a></li>
<li><a href="#_star_2_7">Star 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_rust">Day 08: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_8_treetop_tree_house">Day 8: Treetop Tree House</a>
<ul class="sectlevel4">
<li><a href="#_input_8">Input</a></li>
<li><a href="#_star_1_8">Star 1</a></li>
<li><a href="#_star_2_8">Star 2</a></li>
<li><a href="#_tests_9">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_rust">Day 09: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_9_rope_bridge">Day 9: Rope Bridge</a>
<ul class="sectlevel4">
<li><a href="#_input_9">Input</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_tests_10">Tests</a></li>
<li><a href="#_today_i_learned_7">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_rust">Day 10: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a>
<ul class="sectlevel4">
<li><a href="#_input_10">Input</a></li>
<li><a href="#_star_1_9">Star 1</a></li>
<li><a href="#_star_2_9">Star 2</a></li>
<li><a href="#_tests_11">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_rust">Day 11: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_11_monkey_in_the_middle">Day 11: Monkey in the Middle</a>
<ul class="sectlevel4">
<li><a href="#_input_11">Input</a></li>
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_tests_12">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_12_rust">Day 12: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_12_hill_climbing_algorithm">Day 12: Hill Climbing Algorithm</a>
<ul class="sectlevel4">
<li><a href="#_input_12">Input</a></li>
<li><a href="#_star_1_10">Star 1</a></li>
<li><a href="#_star_2_10">Star 2</a></li>
<li><a href="#_tests_13">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_13_rust">Day 13: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_13_distress_signal">Day 13: Distress Signal</a>
<ul class="sectlevel4">
<li><a href="#_input_13">Input</a></li>
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_star_1_11">Star 1</a></li>
<li><a href="#_star_2_11">Star 2</a></li>
<li><a href="#_tests_14">Tests</a></li>
<li><a href="#_alternative_without_using_heap">Alternative without using heap</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_14_rust">Day 14: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_14_regolith_reservoir">Day 14: Regolith Reservoir</a>
<ul class="sectlevel4">
<li><a href="#_input_14">Input</a></li>
<li><a href="#_star_1_12">Star 1</a></li>
<li><a href="#_star_2_12">Star 2</a></li>
<li><a href="#_tests_15">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_15_rust">Day 15: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_15_beacon_exclusion_zone">Day 15: Beacon Exclusion Zone</a>
<ul class="sectlevel4">
<li><a href="#_input_15">Input</a></li>
<li><a href="#_star_1_13">Star 1</a></li>
<li><a href="#_star_2_13">Star 2</a></li>
<li><a href="#_star_2scan_lines">Star 2&#8201;&#8212;&#8201;Scan Lines</a></li>
<li><a href="#_tests_16">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_16_rust">Day 16: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_16_proboscidea_volcanium">Day 16: Proboscidea Volcanium</a>
<ul class="sectlevel4">
<li><a href="#_input_16">Input</a></li>
<li><a href="#_star_1_14">Star 1</a></li>
<li><a href="#_star_2_14">Star 2</a></li>
<li><a href="#_tests_17">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_17_rust">Day 17: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_17_pyroclastic_flow">Day 17: Pyroclastic Flow</a>
<ul class="sectlevel4">
<li><a href="#_input_17">Input</a></li>
<li><a href="#_general_solution">General solution</a></li>
<li><a href="#_star_1_15">Star 1</a></li>
<li><a href="#_star_2_15">Star 2</a></li>
<li><a href="#_tests_18">Tests</a></li>
<li><a href="#_animation">Animation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_18_rust">Day 18: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_18_boiling_boulders">Day 18: Boiling Boulders</a>
<ul class="sectlevel4">
<li><a href="#_input_18">Input</a></li>
<li><a href="#_star_1_16">Star 1</a></li>
<li><a href="#_star_2_16">Star 2</a></li>
<li><a href="#_star_1_variant">Star 1 variant</a></li>
<li><a href="#_tests_19">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_19_rust">Day 19: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_19_not_enough_minerals">Day 19: Not Enough Minerals</a>
<ul class="sectlevel4">
<li><a href="#_input_19">Input</a></li>
<li><a href="#_star_1_17">Star 1</a></li>
<li><a href="#_star_2_17">Star 2</a></li>
<li><a href="#_tests_20">Tests</a></li>
<li><a href="#_today_i_learned_8">Today I learned</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_20_rust">Day 20: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_20_grove_positioning_system">Day 20: Grove Positioning System</a>
<ul class="sectlevel4">
<li><a href="#_input_20">Input</a></li>
<li><a href="#_general_solution_2">General Solution</a></li>
<li><a href="#_star_1_18">Star 1</a></li>
<li><a href="#_star_2_18">Star 2</a></li>
<li><a href="#_tests_21">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_21_rust">Day 21: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_21_todo">Day 21: <em>TODO</em></a>
<ul class="sectlevel4">
<li><a href="#_input_21">Input</a></li>
<li><a href="#_star_1_19">Star 1</a></li>
<li><a href="#_star_2_19">Star 2</a></li>
<li><a href="#_tests_22">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_22_rust">Day 22: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_22_monkey_map">Day 22: Monkey Map</a>
<ul class="sectlevel4">
<li><a href="#_input_22">Input</a></li>
<li><a href="#_star_1_20">Star 1</a></li>
<li><a href="#_star_2_20">Star 2</a></li>
<li><a href="#_tests_23">Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_mr_kaffee"><a class="anchor" href="#_mr_kaffee"></a><a class="link" href="#_mr_kaffee">mr-kaffee</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars0.githubusercontent.com/u/73745454?v=4" alt="73745454?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>mr-kaffee</strong><br>
Peter Wieland<br>
Github: <a href="https://github.com/mr-kaffee">mr-kaffee</a>,
Strava: <a href="https://www.strava.com/athletes/89256720">Peter Wieland</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a regular SW coder. Each year in december, I code AoC puzzle solutions. This year, for the 3rd year in a row, I&#8217;ll go with Rust.</p>
</div>
<div class="paragraph">
<p>In my professional career, I used to do lots of Java and MATLAB coding, yet, this feels like very long time ago.</p>
</div>
<div class="paragraph">
<p>If I do not code or work, I enjoy <a href="https://www.strava.com/athletes/89256720">cycling</a> on or off roads, with or without electric support.</p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_rust"><a class="anchor" href="#_day_00_rust"></a><a class="link" href="#_day_00_rust">Day 00: rust</a></h3>
<div class="sect3">
<h4 id="_day_00_hello_world"><a class="anchor" href="#_day_00_hello_world"></a><a class="link" href="#_day_00_hello_world">Day 00: Hello World!</a></h4>
<div class="paragraph">
<p>It&#8217;ll be the 3rd year of <a href="https://www.rust-lang.org/">Rust</a> solutions for the 2022 edition of
<a href="https://adventofcode.com/2021">Advent of Code</a></p>
</div>
<div class="paragraph">
<p>I created a little solution infrastructure (which resides in the <code>aoc</code> subfolder of <code>day00/rust/mr-kaffee</code>) I want to use in my solutions.</p>
</div>
<div class="paragraph">
<p>My day00 solution can be used to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>run all or some of the solutions (<code>cargo run --release -- run -y 2022 -d 1..=25</code> or <code>cargo run --release -- run -y 2022 -d 1,3,7</code> or simply <code>cargo run --release</code> to run everything)</p>
</li>
<li>
<p>init new days from a template (use batch file <code>init.bat &lt;day&gt;</code> or <code>cargo run --release -- init &#8230;&#8203;</code>)</p>
</li>
<li>
<p>submit results (use batch file <code>submit.bat &lt;day&gt; &lt;part&gt;</code> or <code>cargo run --release -- submit &#8230;&#8203;</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than that, my challenges are again to create solutions that perform well and that do not use external dependencies (the latter constraint is not applied for the Day 0 Hello World Example, which I also use to run all my solutions in a row).</p>
</div>
<div class="sect4">
<h5 id="_run_solutions_for_several_days"><a class="anchor" href="#_run_solutions_for_several_days"></a><a class="link" href="#_run_solutions_for_several_days">Run solutions for several days</a></h5>

</div>
<div class="sect4">
<h5 id="_general_structure"><a class="anchor" href="#_general_structure"></a><a class="link" href="#_general_structure">General structure</a></h5>
<div class="paragraph">
<p>My solutions will be implemented in a <code>src/lib.rs</code> file and generally have the structure detailed below. This is most probably a bit of an overhead, but fun to write and a learning opportunity for me.</p>
</div>
<div class="sect5">
<h6 id="_the_puzzle_definition"><a class="anchor" href="#_the_puzzle_definition"></a><a class="link" href="#_the_puzzle_definition">The Puzzle definition</a></h6>
<div class="paragraph">
<p>This is a function returning a <code>mr_kaffee_aoc::Puzzle</code> struct which defines metadata, input data, references to solver functions and expected solutions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn puzzle() -&gt; Puzzle&lt;'static, PuzzleData, usize, usize, usize, usize&gt; {
    Puzzle {
        year: 2022,
        day: 0,
        input: include_str!("../input.txt"),
        star1: Some(Star {
            name: "Hello World example",
            f: &amp;star_1,
            exp: Some(0),
        }),
        star2: None,
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_data_structures"><a class="anchor" href="#_data_structures"></a><a class="link" href="#_data_structures">Data Structures</a></h6>
<div class="paragraph">
<p>This includes the code to parse the input data</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct PuzzleData {
    input: &amp;'static str,
}

impl From&lt;&amp;'static str&gt; for PuzzleData {
    fn from(input: &amp;'static str) -&gt; Self {
        Self { input }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_the_solver_functions"><a class="anchor" href="#_the_solver_functions"></a><a class="link" href="#_the_solver_functions">The solver functions</a></h6>
<div class="paragraph">
<p>The main solver functions plus potentially helper functions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    println!("{}", data.input);
    0
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_tests"><a class="anchor" href="#_tests"></a><a class="link" href="#_tests">Tests</a></h6>
<div class="paragraph">
<p>Tests, in particular code to execute the test cases typically defined in the puzzles</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;
    use mr_kaffee_aoc::GenericPuzzle;

    #[test]
    pub fn test_something() {
        let puzzle = puzzle();
        assert!(puzzle.solve_handle_err());
    }
}</code></pre>
</div>
</div>
<a id="day01" />
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_1_calorie_counting"><a class="anchor" href="#_day_1_calorie_counting"></a><a class="link" href="#_day_1_calorie_counting">Day 1: Calorie Counting</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/1">AoC|2022|1</a>.</p>
</div>
<div class="paragraph">
<p>Nothing very interesting today.</p>
</div>
<div class="sect4">
<h5 id="_input"><a class="anchor" href="#_input"></a><a class="link" href="#_input">Input</a></h5>
<div class="paragraph">
<p>Parse everything in a vec of sums (initially I used a vec of vecs; since individual elements are never needed sums are enough)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::num::ParseIntError;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub calories: Vec&lt;usize&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = ParseIntError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.split("\n\n")
                .map(|elf| elf.lines().map(|l| l.parse::&lt;usize&gt;()).sum())
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|calories| Self { calories })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1"><a class="anchor" href="#_star_1"></a><a class="link" href="#_star_1">Star 1</a></h5>
<div class="paragraph">
<p>Just find the biggest sum (I use <code>fold</code> instead of <code>max</code> to not handle the <code>Option::None</code> case)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.calories.iter().fold(0, |mx, &amp;cal| mx.max(cal))
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2"><a class="anchor" href="#_star_2"></a><a class="link" href="#_star_2">Star 2</a></h5>
<div class="paragraph">
<p>Sum the three biggest sums. First solution used <code>Vec::sort</code>. New solution does not use any sorting and should be <code>O(n)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.calories
        .iter()
        .fold([0; 3], |mut mx, &amp;cal| {
            if cal &gt; mx[0] {
                mx[2] = mx[1];
                mx[1] = mx[0];
                mx[0] = cal;
            } else if cal &gt; mx[1] {
                mx[2] = mx[1];
                mx[1] = cal;
            } else if cal &gt; mx[2] {
                mx[2] = cal;
            }
            mx
        })
        .iter()
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_2"><a class="anchor" href="#_tests_2"></a><a class="link" href="#_tests_2">Tests</a></h5>
<div class="paragraph">
<p>No tests today. It was too simple.</p>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned"><a class="anchor" href="#_today_i_learned"></a><a class="link" href="#_today_i_learned">Today I learned</a></h5>
<div class="paragraph">
<p>Not so much. My template works.</p>
</div>
<div class="paragraph">
<p>Iterating/refactoring the solution, I learned that <code>std::iter::Sum</code> has an implementation <code>impl&lt;T, U, E&gt; Sum&lt;Result&lt;U, E&gt;&gt; for Result&lt;T, E&gt;</code>.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_2_rock_paper_scissors"><a class="anchor" href="#_day_2_rock_paper_scissors"></a><a class="link" href="#_day_2_rock_paper_scissors">Day 2: Rock Paper Scissors</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/2">AoC|2022|2</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_2"><a class="anchor" href="#_input_2"></a><a class="link" href="#_input_2">Input</a></h5>
<div class="paragraph">
<p>I have two enums to parse the first column (A, B, C to <code>RockPaperScissors</code>) and the second column (X, Y, Z to <code>XYZ</code>).</p>
</div>
<div class="paragraph">
<p>It would have been much simpler to parse both into 0, 1, 2 and than use some simple formulas later on (which I did as an alternative, see below), but my solution fails gracefully if something unexpected comes in the input ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum RockPaperScissors {
        Rock,
        Paper,
        Scissors,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum XYZ {
        X,
        Y,
        Z,
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        pub strategy: Vec&lt;(RockPaperScissors, XYZ)&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = String;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(|l| {
                    l.split_once(' ')
                        .ok_or_else(|| format!("Could not parse line '{l}'"))
                        .and_then(|(a, b)| {
                            match a {
                                "A" =&gt; Ok(RockPaperScissors::Rock),
                                "B" =&gt; Ok(RockPaperScissors::Paper),
                                "C" =&gt; Ok(RockPaperScissors::Scissors),
                                _ =&gt; Err(format!("Expected one of A, B, C, found '{a}'")),
                            }
                            .and_then(|a| match b {
                                "X" =&gt; Ok((a, XYZ::X)),
                                "Y" =&gt; Ok((a, XYZ::Y)),
                                "Z" =&gt; Ok((a, XYZ::Z)),
                                _ =&gt; Err(format!("Expected one of X, Y, Z, found '{b}'")),
                            })
                        })
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|strategy| Self { strategy })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_2"><a class="anchor" href="#_star_1_2"></a><a class="link" href="#_star_1_2">Star 1</a></h5>
<div class="paragraph">
<p>For star 1 I directly convert `XYZ`s to `RockPaperScissors&#8217; using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn to_rock_paper_scissors(&amp;self) -&gt; RockPaperScissors {
        match self {
            XYZ::X =&gt; RockPaperScissors::Rock,
            XYZ::Y =&gt; RockPaperScissors::Paper,
            XYZ::Z =&gt; RockPaperScissors::Scissors,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scores are calculated with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn result(&amp;self, other: &amp;Self) -&gt; usize {
        match (self, other) {
            (RockPaperScissors::Rock, RockPaperScissors::Rock) =&gt; 1 + 3,
            (RockPaperScissors::Rock, RockPaperScissors::Paper) =&gt; 1 + 0,
            (RockPaperScissors::Rock, RockPaperScissors::Scissors) =&gt; 1 + 6,
            (RockPaperScissors::Paper, RockPaperScissors::Rock) =&gt; 2 + 6,
            (RockPaperScissors::Paper, RockPaperScissors::Paper) =&gt; 2 + 3,
            (RockPaperScissors::Paper, RockPaperScissors::Scissors) =&gt; 2 + 0,
            (RockPaperScissors::Scissors, RockPaperScissors::Rock) =&gt; 3 + 0,
            (RockPaperScissors::Scissors, RockPaperScissors::Paper) =&gt; 3 + 6,
            (RockPaperScissors::Scissors, RockPaperScissors::Scissors) =&gt; 3 + 3,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the solution is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.strategy
        .iter()
        .map(|(a, b)| b.to_rock_paper_scissors().result(a))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_2"><a class="anchor" href="#_star_2_2"></a><a class="link" href="#_star_2_2">Star 2</a></h5>
<div class="paragraph">
<p>I was expecting an optimization for the second part of the kind, "Figure out what X, Y, Z need to be so you end up with the highest score possible" or "&#8230;&#8203; so that you end up with the lowest score possible that with more than 50% wins". Maybe that would have been too much for day 2.</p>
</div>
<div class="paragraph">
<p>The scores are still calculated in the same way but the conversion is now done using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    fn for_result(&amp;self, opponent: &amp;RockPaperScissors) -&gt; RockPaperScissors {
        match (&amp;self, opponent) {
            (XYZ::X, RockPaperScissors::Rock) =&gt; RockPaperScissors::Scissors,
            (XYZ::X, RockPaperScissors::Paper) =&gt; RockPaperScissors::Rock,
            (XYZ::X, RockPaperScissors::Scissors) =&gt; RockPaperScissors::Paper,
            (XYZ::Y, _) =&gt; *opponent,
            (XYZ::Z, RockPaperScissors::Rock) =&gt; RockPaperScissors::Paper,
            (XYZ::Z, RockPaperScissors::Paper) =&gt; RockPaperScissors::Scissors,
            (XYZ::Z, RockPaperScissors::Scissors) =&gt; RockPaperScissors::Rock,
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.strategy
        .iter()
        .map(|(a, b)| b.for_result(a).result(a))
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_3"><a class="anchor" href="#_tests_3"></a><a class="link" href="#_tests_3">Tests</a></h5>
<div class="paragraph">
<p>I made a mistake in my scoring function in the first place. So I wrote tests this time to debug this&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"A Y
B X
C Z"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(15, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(12, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_2"><a class="anchor" href="#_today_i_learned_2"></a><a class="link" href="#_today_i_learned_2">Today I learned</a></h5>
<div class="paragraph">
<p>I think it was the first time I used <code>Result::and_then</code> in a (maybe) meaningful way.</p>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_based_on_direct_calculations"><a class="anchor" href="#_alternative_based_on_direct_calculations"></a><a class="link" href="#_alternative_based_on_direct_calculations">Alternative based on direct calculations</a></h5>
<div class="paragraph">
<p>I could not stop myself from implementing an alternative solution using direct calculations. Run the alternative solution with <code>cargo run --release --features modulo</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        // 0 rock
        // 1 paper
        // 2 scissor
        // (rock - paper + 1) % 3 = 0
        // (rock - rock + 1) % 3 = 1
        // (rock - scissor + 1) % 3 = 2
        data.strategy
            .iter()
            .map(|(a, b)| ((b + 4 - a) % 3) * 3 + (b + 1))
            .sum()
    }

    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        // 0 rock, 1 paper, 2 scissor
        // 0 loose, 1 draw, 2 win
        // to loose, subtract 1 (% 3), to win add 1 (% 3)
        // play (a + b - 1) % 3 -&gt; add this in formula for first star
        data.strategy
            .iter()
            .map(|(a, b)| b * 3 + (a + b + 2) % 3 + 1)
            .sum()
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>I also implemented a parse function which does not check any inputs and will probably result in panics if something unexpected is in the input (to parse without error handling run <code>cargo run --release --features unchecked_parse</code>; this will automatically use the direct calculation variant)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = String;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            if cfg!(feature = "unchecked_parse") {
                Ok(Self {
                    strategy: s
                        .lines()
                        .map(str::as_bytes)
                        .map(|bytes| ((bytes[0] - b'A') as usize, (bytes[2] - b'X') as usize))
                        .collect(),
                })
            } else {
                s.lines()
                    .map(|l| {
                        l.split_once(' ')
                            .ok_or_else(|| format!("Could not parse line '{l}'"))
                            .and_then(|(a, b)| {
                                match a {
                                    "A" =&gt; Ok(0),
                                    "B" =&gt; Ok(1),
                                    "C" =&gt; Ok(2),
                                    _ =&gt; Err(format!("Expected one of A, B, C, found '{a}'")),
                                }
                                .and_then(|a| match b {
                                    "X" =&gt; Ok((a, 0)),
                                    "Y" =&gt; Ok((a, 1)),
                                    "Z" =&gt; Ok((a, 2)),
                                    _ =&gt; Err(format!("Expected one of X, Y, Z, found '{b}'")),
                                })
                            })
                    })
                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                    .map(|strategy| Self { strategy })
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interestingly, not doing any error handling in parsing the input does not lead to any measurable speed-up. Maybe this is because the overall solution time is so small, that the differences are not distinguishable from noise?</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_3_rucksack_reorganization"><a class="anchor" href="#_day_3_rucksack_reorganization"></a><a class="link" href="#_day_3_rucksack_reorganization">Day 3: Rucksack Reorganization</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/3">AoC|2022|3</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_3"><a class="anchor" href="#_input_3"></a><a class="link" href="#_input_3">Input</a></h5>
<div class="paragraph">
<p>I parse the input directly into a vec of vecs of bytes, each representing the priority of the items contained in the rucksacks.</p>
</div>
<div class="paragraph">
<p>I was tempted to think about using sets for quicker <code>contains</code> operations, but given the size of the problem, this is most likely not worth it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub rucksacks: Vec&lt;Vec&lt;u8&gt;&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = &amp;'static str;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(|l| {
                    l.as_bytes()
                        .iter()
                        .map(|&amp;b| match b {
                            b'a'..=b'z' =&gt; Ok(b - b'a' + 1),
                            b'A'..=b'Z' =&gt; Ok(b - b'A' + 27),
                            _ =&gt; Err("Unexpected bytes in input"),
                        })
                        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|rucksacks| Self { rucksacks })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_3"><a class="anchor" href="#_star_1_3"></a><a class="link" href="#_star_1_3">Star 1</a></h5>
<div class="paragraph">
<p>Star 1 is about finding the item in the first compartment (first half) of the rucksack, which is also contained in the secod half.</p>
</div>
<div class="paragraph">
<p>Some simplifications work because / if the input is correct.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I assume that a common item always exists and therefore do not limit the search to the first half (it will stop once an item is found, which will be in the first half)</p>
</li>
<li>
<p>The <code>find</code> function returns an <code>Option</code>. If there were any <code>None</code> values, they would be simply discarded using <code>filter_map</code> (actually, for part 1, there can be no <code>None</code> values, because search is not stopped in the first half, so the first element of the second half would be found, if there is no common element between first and second half. so a simple <code>unwrap</code> would work as well).</p>
</li>
<li>
<p>The <code>chunks_exact</code> function makes sure that every chunk has exactly three elements. If the overall number of rucksacks was not a multiple of three, the remaining rucksacks would simply be discarded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I use a <code>fold</code> instead of <code>sum</code> to do type conversion on the fly (<code>u8</code> would not be big enough to hold the sum).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.rucksacks
        .iter()
        .filter_map(|rucksack| {
            rucksack
                .iter()
                .find(|item| rucksack.as_slice()[rucksack.len() / 2..].contains(item))
        })
        .fold(0usize, |sum, item| sum + *item as usize)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_3"><a class="anchor" href="#_star_2_3"></a><a class="link" href="#_star_2_3">Star 2</a></h5>
<div class="paragraph">
<p>Star 2 is a simple modification, where we look for items that are common for groups of three consecutive rucksacks</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.rucksacks
        .chunks_exact(3)
        .filter_map(|group| {
            group[0]
                .iter()
                .find(|item| group[1].contains(item) &amp;&amp; group[2].contains(item))
        })
        .fold(0usize, |sum, item| sum + *item as usize)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_4"><a class="anchor" href="#_tests_4"></a><a class="link" href="#_tests_4">Tests</a></h5>
<div class="paragraph">
<p>Tests use the example given in the puzzle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(157, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(70, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_3"><a class="anchor" href="#_today_i_learned_3"></a><a class="link" href="#_today_i_learned_3">Today I learned</a></h5>
<div class="paragraph">
<p>... that sometimes it is as simple as it appears at first view.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_4_camp_cleanup"><a class="anchor" href="#_day_4_camp_cleanup"></a><a class="link" href="#_day_4_camp_cleanup">Day 4: Camp Cleanup</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/4">AoC|2022|4</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_4"><a class="anchor" href="#_input_4"></a><a class="link" href="#_input_4">Input</a></h5>
<div class="paragraph">
<p>Today, input parsing was the biggest challenge. Mainly because I decided to not use <code>unwrap</code> but try some proper error handling and to avoid intermediate <code>collect</code> calls. Until I figured out that the code is much simplified if I create a separate function to parse a single line (because <code>?</code> can be used in that function but not in a clojure within an iterator&#8217;s <code>map</code> function), I had to use a lot of <code>and_then</code>, <code>map</code>, <code>map_error</code>, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So here is my parsing functions (admittedly not how it looked like when I submitted my results)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use mr_kaffee_aoc::err::PuzzleError;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub range_pairs: Vec&lt;((usize, usize), (usize, usize))&gt;,
    }

    fn parse_pair(line: &amp;str) -&gt; Result&lt;((usize, usize), (usize, usize)), PuzzleError&gt; {
        let mut iter = line.split(|c: char| c == '-' || c == ',');
        Ok((
            (
                iter.next()
                    .ok_or_else(|| format!("Missing start 1 '{line}'"))?
                    .parse()?,
                iter.next()
                    .ok_or_else(|| format!("Missing end 1 in '{line}'"))?
                    .parse()?,
            ),
            (
                iter.next()
                    .ok_or_else(|| format!("Missing start 2 in '{line}'"))?
                    .parse()?,
                iter.next()
                    .ok_or_else(|| format!("Missing end 2 in '{line}'"))?
                    .parse()?,
            ),
        ))
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = PuzzleError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            s.lines()
                .map(parse_pair)
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .map(|range_pairs| Self { range_pairs })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_4"><a class="anchor" href="#_star_1_4"></a><a class="link" href="#_star_1_4">Star 1</a></h5>
<div class="paragraph">
<p>The actual solution is simple for part 1 &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    // count how often one range is contained in the other
    data.range_pairs
        .iter()
        .filter(|((start1, end1), (start2, end2))| {
            (start1 &lt;= start2 &amp;&amp; end2 &lt;= end1) || (start2 &lt;= start1 &amp;&amp; end1 &lt;= end2)
        })
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_4"><a class="anchor" href="#_star_2_4"></a><a class="link" href="#_star_2_4">Star 2</a></h5>
<div class="paragraph">
<p>... as well as for part 2 (I was afraid to be asked to look for overlaps across pairs in part 2 &#8230;&#8203;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    // count how often ranges overlap, i.e., start of one range is contained in the other range
    data.range_pairs
        .iter()
        .filter(|((start1, end1), (start2, end2))| {
            (start1 &lt;= start2 &amp;&amp; start2 &lt;= end1) || (start2 &lt;= start1 &amp;&amp; start1 &lt;= end2)
        })
        .count()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_5"><a class="anchor" href="#_tests_5"></a><a class="link" href="#_tests_5">Tests</a></h5>
<div class="paragraph">
<p>Today I even did test-driven development in the sense that I did not write any functional code before I had a failing test case ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;
    use mr_kaffee_aoc::err::PuzzleError;

    const CONTENT: &amp;str = r#"2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8"#;

    #[test]
    pub fn test_star_1() -&gt; Result&lt;(), PuzzleError&gt; {
        let data = PuzzleData::try_from(CONTENT)?;
        assert_eq!(2, star_1(&amp;data));
        Ok(())
    }

    #[test]
    pub fn test_star_2() -&gt; Result&lt;(), PuzzleError&gt; {
        let data = PuzzleData::try_from(CONTENT)?;
        assert_eq!(4, star_2(&amp;data));
        Ok(())
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_4"><a class="anchor" href="#_today_i_learned_4"></a><a class="link" href="#_today_i_learned_4">Today I learned</a></h5>
<div class="paragraph">
<p><code>and_then</code> - <code>map</code> - <code>and_then</code> - <code>map</code> - <code>map_err</code> &#8230;&#8203; is all not needed if some parsing functionality for one line is moved to a separate function where the <code>?</code> shortcut operator can be used for error propagation and conversion</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_5_supply_stacks"><a class="anchor" href="#_day_5_supply_stacks"></a><a class="link" href="#_day_5_supply_stacks">Day 5: Supply Stacks</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/5">AoC|2022|5</a>.</p>
</div>
<div class="paragraph">
<p>Today, there where two main challenges for me:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parsing the input</p>
</li>
<li>
<p>Rust&#8217;s mutability &amp; borrowing concept for part 2</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In addition, it turns out quite complicated to handle possible errors (all kind of invalid moves, empty stacks at end of moves, &#8230;&#8203;). All this effort for code that is never used, because the puzzle inputs are well-formed. I think I will stop this excercise and use plain <code>unwrap</code> again for subsequent days.</p>
</div>
<div class="sect4">
<h5 id="_input_5"><a class="anchor" href="#_input_5"></a><a class="link" href="#_input_5">Input</a></h5>
<div class="paragraph">
<p>Today, it was not just "process input line by line", but in the end almost &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>First, I split the input in one part describing the stacks and a second part describing the moves. Parsing the moves in tuples <code>(n, from, to)</code> is easy. I make the <code>from</code> and <code>to</code> parts zero-based on the fly.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks of crates is a bit more tricky. I did not (could not) use a simple iterator / collect scheme but allocated the stacks upfront and than process line by line starting at the last and pushing elements on the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use mr_kaffee_aoc::err::PuzzleError;

    #[derive(Debug, PartialEq, Eq)]
    pub struct PuzzleData {
        stacks: Vec&lt;Vec&lt;char&gt;&gt;,
        moves: Vec&lt;(usize, usize, usize)&gt;,
    }

    fn parse_move(line: &amp;str, len: usize) -&gt; Result&lt;(usize, usize, usize), PuzzleError&gt; {
        let mut parts = line.split(" ");

        parts.next(); // skip "move"
        let n = parts
            .next()
            .ok_or_else(|| format!("Missing number in move '{line}'"))?
            .parse::&lt;usize&gt;()?;
        parts.next(); // skip "from"
        let from = parts
            .next()
            .ok_or_else(|| format!("Missing from in move '{line}'"))?
            .parse::&lt;usize&gt;()?
            - 1;
        parts.next(); // skip "to"
        let to = parts
            .next()
            .ok_or_else(|| format!("Missing to in move '{line}'"))?
            .parse::&lt;usize&gt;()?
            - 1;

        if from &gt;= len || to &gt;= len {
            Err(format!("Invalid move: '{line}', &lt;from&gt;, &lt;to&gt; &lt;= {len} required.").into())
        } else if from == to {
            Err(format!("Invalid move: '{line}', &lt;from&gt; != &lt;to&gt; required.").into())
        } else {
            Ok((n, from, to))
        }
    }

    fn parse_crate_layer(stacks: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, line: &amp;str) {
        for (k, item) in line
            .chars()
            .skip(1)
            .step_by(4)
            .enumerate()
            .filter(|(_, item)| *item != ' ')
        {
            while k &gt;= stacks.len() {
                stacks.push(Vec::new());
            }
            stacks[k].push(item);
        }
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = PuzzleError;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            let (stacks_part, moves_part) = s
                .split_once("\n\n")
                .ok_or("Could not separate crates from moves")?;

            let mut stacks: Vec&lt;Vec&lt;char&gt;&gt; = vec![];
            for line in stacks_part.lines().rev().skip(1) {
                parse_crate_layer(&amp;mut stacks, line);
            }

            let moves = moves_part
                .lines()
                .map(|line| parse_move(line, stacks.len()))
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

            Ok(PuzzleData { stacks, moves })
        }
    }

    impl PuzzleData {
        /// get moves
        pub fn moves(&amp;self) -&gt; &amp;[(usize, usize, usize)] {
            &amp;self.moves
        }

        /// get cloned crates
        pub fn stacks(&amp;self) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {
            self.stacks.clone()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_5"><a class="anchor" href="#_star_1_5"></a><a class="link" href="#_star_1_5">Star 1</a></h5>
<div class="paragraph">
<p>This is straight forward. Just process move by move, and pop from one stack / push to the other stack the correct number of times.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn msg(stacks: &amp;[Vec&lt;char&gt;]) -&gt; Result&lt;String, PuzzleError&gt; {
    stacks
        .iter()
        .map(|c| {
            c.last().ok_or_else(|| {
                PuzzleError::from(format!(
                    "Can't construct message. Empty stack in {stacks:?}"
                ))
            })
        })
        .collect()
}

pub fn star_1(data: &amp;PuzzleData) -&gt; Result&lt;String, PuzzleError&gt; {
    let mut stacks = data.stacks();
    for (n, from, to) in data.moves() {
        for _ in 0..*n {
            let item = stacks[*from]
                .pop()
                .ok_or_else(|| format!("Tried to pop from empty stack {from}, stacks: {stacks:?}"))?;
            stacks[*to].push(item);
        }
    }

    msg(&amp;stacks)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_5"><a class="anchor" href="#_star_2_5"></a><a class="link" href="#_star_2_5">Star 2</a></h5>
<div class="paragraph">
<p>This is slightly more tricky. Now we have to pop a complete pack of items and push that on top of another stack preserving the order.</p>
</div>
<div class="paragraph">
<p>The challenging part of it is that Rust does not allow mutable references to two items in a vec at the same time. My first solution used intermediate storage. My current solution uses <code>slice::split_at_mut</code> to circumvent this (speed-up by a factor 3 to 4 for part 2 compared to intermediate storage). The code gets a bit complicated though&#8201;&#8212;&#8201;I extracted the complicated part to a function <code>mut_references</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn mut_references&lt;T&gt;(v: &amp;mut Vec&lt;T&gt;, idx1: usize, idx2: usize) -&gt; (&amp;mut T, &amp;mut T) {
    if idx1 &gt; idx2 {
        let (left, right) = v.split_at_mut(idx1);
        (&amp;mut right[0], &amp;mut left[idx2])
    } else {
        let (left, right) = v.split_at_mut(idx2);
        (&amp;mut left[idx1], &amp;mut right[0])
    }
}

pub fn star_2(data: &amp;PuzzleData) -&gt; Result&lt;String, PuzzleError&gt; {
    let mut stacks = data.stacks();
    for (n, from, to) in data.moves() {
        // I need a mutable reference to the from and the to part at the same time
        // to avoid creating intermediate storage
        let (source, dest) = mut_references(&amp;mut stacks, *from, *to);

        let len = source.len();
        if *n &gt; len {
            return Err(format!(
                "Trying to pop {n} elements from stack {from} containing {len}, stacks: {stacks:?}"
            )
            .into());
        }
        for item in source.drain(len - n..) {
            dest.push(item);
        }
    }

    msg(&amp;stacks)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_6"><a class="anchor" href="#_tests_6"></a><a class="link" href="#_tests_6">Tests</a></h5>
<div class="paragraph">
<p>And there are some tests.</p>
</div>
<div class="paragraph">
<p>Since parsing was not totally obvious, I did an additional test for this part &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"    [D]
[N] [C]
[Z] [M] [P]
 1   2   3

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2"#;

    #[test]
    pub fn test_parse() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(
            vec![vec!['Z', 'N'], vec!['M', 'C', 'D'], vec!['P']],
            data.stacks()
        );
        assert_eq!(&amp;[(1, 1, 0), (3, 0, 2), (2, 1, 0), (1, 0, 1)], data.moves());
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!("CMZ", star_1(&amp;data).unwrap());
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!("MCD", star_2(&amp;data).unwrap());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_5"><a class="anchor" href="#_today_i_learned_5"></a><a class="link" href="#_today_i_learned_5">Today I learned</a></h5>
<div class="paragraph">
<p>How to mutably access two elements of one vec in Rust.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_6_tuning_trouble"><a class="anchor" href="#_day_6_tuning_trouble"></a><a class="link" href="#_day_6_tuning_trouble">Day 6: Tuning Trouble</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/6">AoC|2022|6</a>.</p>
</div>
<div class="paragraph">
<p>Today I totally screwed up for the second star for no specific reason :(</p>
</div>
<div class="paragraph">
<p>Too little sleep probably.</p>
</div>
<div class="sect4">
<h5 id="_input_6"><a class="anchor" href="#_input_6"></a><a class="link" href="#_input_6">Input</a></h5>
<div class="paragraph">
<p>I parse the input directly into a slice of bytes. That should be very cheap&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::convert::Infallible;

    #[derive(Debug)]
    pub struct PuzzleData {
        pub stream: &amp;'static [u8],
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = Infallible;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            Ok(PuzzleData {
                stream: s.trim().as_bytes(),
            })
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_6"><a class="anchor" href="#_star_1_6"></a><a class="link" href="#_star_1_6">Star 1</a></h5>
<div class="paragraph">
<p>Hand-crafted solution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let (k, _) = data
        .stream
        .windows(4)
        .enumerate()
        .find(|(_, s)| match s {
            &amp;[a, b, c, d] =&gt; a != b &amp;&amp; a != c &amp;&amp; a != d &amp;&amp; b != c &amp;&amp; b != d &amp;&amp; c != d,
            _ =&gt; unreachable!(),
        })
        .unwrap();

    k + 4
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_6"><a class="anchor" href="#_star_2_6"></a><a class="link" href="#_star_2_6">Star 2</a></h5>
<div class="paragraph">
<p>Solution with a bit of iterators.</p>
</div>
<div class="paragraph">
<p>It feels bad to search the same thing again and again. If a duplicate is found in a window, the search could skip everything until the character just after the first occurance of the duplicate. I implemented this as an alternative (see below)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let (k, _) = data
        .stream
        .windows(14)
        .enumerate()
        .find(|(_, w)| {
            w.iter()
                .enumerate()
                .skip(1)
                .all(|(p, c1)| w.iter().take(p).all(|c2| c1 != c2))
        })
        .unwrap();
    k + 14
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative"><a class="anchor" href="#_alternative"></a><a class="link" href="#_alternative">Alternative</a></h5>
<div class="paragraph">
<p>As an alternative, I implemented a generic solution which skips parts of the search already covered. Interestingly, this solution tends to be slightly slower (the difference is close to measurement noise in my not very professional time measurements)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn find_distinct(stream: &amp;[u8], n: usize) -&gt; usize {
    let mut k = 0;
    while k &lt; stream.len() - n {
        match (k + 1..k + n).find(|p| stream[*p..k + n].contains(&amp;stream[*p - 1])) {
            Some(q) =&gt; k = q,
            None =&gt; return k + n,
        }
    }

    panic!("No solution.");
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_7"><a class="anchor" href="#_tests_7"></a><a class="link" href="#_tests_7">Tests</a></h5>
<div class="paragraph">
<p>Tests for all variants</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"mjqjpqmgbljsphdztnvjfqwrcgsmlb"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(7, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(19, star_2(&amp;data));
    }

    #[test]
    pub fn test_find_distinct() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(7, find_distinct(data.stream, 4));
        assert_eq!(19, find_distinct(data.stream, 14));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_6"><a class="anchor" href="#_today_i_learned_6"></a><a class="link" href="#_today_i_learned_6">Today I learned</a></h5>
<div class="paragraph">
<p>Take a second cup of coffee before solving the puzzle, don&#8217;t forget to wear glasses, and</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is cool to not allocate any intermediate storage but work directly on byte slices.</p>
</li>
<li>
<p>it is possible to destructure slices with <code>match</code></p>
</li>
</ul>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_7_no_space_left_on_device"><a class="anchor" href="#_day_7_no_space_left_on_device"></a><a class="link" href="#_day_7_no_space_left_on_device">Day 7: No Space Left On Device</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/7">AoC|2022|7</a>.</p>
</div>
<div class="paragraph">
<p>When reading the puzzle today, I thought it would get complicated. Finally, it was quite straight-forward.</p>
</div>
<div class="sect4">
<h5 id="_input_7"><a class="anchor" href="#_input_7"></a><a class="link" href="#_input_7">Input</a></h5>
<div class="paragraph">
<p>The description asks for recursion / recursive data structures, which I find a pain in Rust. My solution is to create a vec of <code>Directory</code> elements. Each directory contains references to children and the parent directory as index to this vec.</p>
</div>
<div class="paragraph">
<p>The directories are created by processing the input line by line. When an <code>ls</code> command yields a directory, a new <code>Directory</code> element is added, its index is added to the children to of the current directory and its parent is set to the current directorie&#8217;s index.</p>
</div>
<div class="paragraph">
<p>File sizes are directly summed up (initially, child files were stored in a vec, but once part 2 was unveiled, it was clear that the sum is the only thing needed)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::{collections::HashMap, convert::Infallible};

    #[derive(Debug)]
    pub struct Directory {
        parent: Option&lt;usize&gt;,
        children: HashMap&lt;&amp;'static str, usize&gt;,
        size: usize,
    }

    impl Directory {
        fn new(parent: Option&lt;usize&gt;) -&gt; Self {
            Self {
                parent,
                children: HashMap::new(),
                size: 0,
            }
        }

        pub fn total_size(&amp;self, dirs: &amp;[Directory]) -&gt; usize {
            self.size
                + self
                    .children
                    .values()
                    .map(|idx| dirs[*idx].total_size(dirs))
                    .sum::&lt;usize&gt;()
        }
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        dirs: Vec&lt;Directory&gt;,
    }

    impl TryFrom&lt;&amp;'static str&gt; for PuzzleData {
        type Error = Infallible;

        /// parse the puzzle input
        fn try_from(s: &amp;'static str) -&gt; Result&lt;Self, Self::Error&gt; {
            let mut dirs = vec![Directory::new(None)];

            let mut current = 0;
            for line in s.lines() {
                match line {
                    "$ cd /" =&gt; current = 0,
                    "$ cd .." =&gt; current = dirs[current].parent.unwrap(),
                    "$ ls" =&gt; (),
                    _ if line.starts_with("$ cd ") =&gt; current = dirs[current].children[&amp;line[5..]],
                    _ if line.starts_with("dir ") =&gt; {
                        let dir = dirs.len();
                        dirs.push(Directory::new(Some(current)));
                        dirs[current].children.insert(&amp;line[4..], dir);
                    }
                    _ =&gt; {
                        dirs[current].size +=
                            line[..line.find(' ').unwrap()].parse::&lt;usize&gt;().unwrap();
                    }
                }
            }

            Ok(Self { dirs })
        }
    }

    impl PuzzleData {
        /// immutable access to directories as slice
        pub fn dirs(&amp;self) -&gt; &amp;[Directory] {
            &amp;self.dirs
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_7"><a class="anchor" href="#_star_1_7"></a><a class="link" href="#_star_1_7">Star 1</a></h5>
<div class="paragraph">
<p>Simple iter - filter - fold</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.dirs()
        .iter()
        .map(|d| d.total_size(data.dirs()))
        .filter(|&amp;s| s &lt;= 100_000)
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_7"><a class="anchor" href="#_star_2_7"></a><a class="link" href="#_star_2_7">Star 2</a></h5>
<div class="paragraph">
<p>Another simple iter - filter - fold</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let required = data.dirs()[0].total_size(data.dirs()) - 40_000_000;

    data.dirs()
        .iter()
        .map(|d| d.total_size(data.dirs()))
        .filter(|&amp;s| s &gt;= required)
        .fold(usize::MAX, |mn, s| mn.min(s))
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_8"><a class="anchor" href="#_tests_8"></a><a class="link" href="#_tests_8">Tests</a></h5>
<div class="paragraph">
<p>The standard tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(95_437, star_1(&amp;data))
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::try_from(CONTENT).unwrap();
        assert_eq!(24_933_642, star_2(&amp;data))
    }
}</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_rust"><a class="anchor" href="#_day_08_rust"></a><a class="link" href="#_day_08_rust">Day 08: rust</a></h3>
<div class="sect3">
<h4 id="_day_8_treetop_tree_house"><a class="anchor" href="#_day_8_treetop_tree_house"></a><a class="link" href="#_day_8_treetop_tree_house">Day 8: Treetop Tree House</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/8">AoC|2022|8</a>.</p>
</div>
<div class="paragraph">
<p>I took a moment to put my brain in the condition to think in the 2D grid&#8230;&#8203;</p>
</div>
<div class="sect4">
<h5 id="_input_8"><a class="anchor" href="#_input_8"></a><a class="link" href="#_input_8">Input</a></h5>
<div class="paragraph">
<p>I directly use the bytes from the input. I scan for the first occurrence of a line break. Its index is the width of the grid. The <code>PuzzleData</code> struct&#8217;s implementation has an additional field for the <code>height</code> of the grid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub trees: &amp;'static [u8],
        pub w: usize,
        pub h: usize,
    }

    impl From&lt;&amp;'static str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'static str) -&gt; Self {
            let trees = s.as_bytes();
            let w = s.find('\n').unwrap();
            let h = trees.len() / (w + 1);
            Self { trees, w, h }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_8"><a class="anchor" href="#_star_1_8"></a><a class="link" href="#_star_1_8">Star 1</a></h5>
<div class="paragraph">
<p>The function <code>is_visible</code> verifies in all four directions (left, right, top, bottom), that all trees up to the boundary are smaller. It stops after one such direction is found.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn is_visible(&amp;self, x: usize, y: usize) -&gt; bool {
        let h = self.trees[x + (self.w + 1) * y];

        let fx = |x_: usize| self.trees[x_ + (self.w + 1) * y] &lt; h;
        let fy = |y_: usize| self.trees[x + (self.w + 1) * y_] &lt; h;

        (0..x).all(fx) || (x + 1..self.w).all(fx) || (0..y).all(fy) || (y + 1..self.h).all(fy)
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then I count in the <code>star_1</code> function, how many trees are visible. For a tree on the boundary, <code>is_visible</code> always returns true, so no need to handle the boundary separately.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    (0..data.w)
        .map(|x| (0..data.h).filter(|&amp;y| data.is_visible(x, y)).count())
        .sum::&lt;usize&gt;()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_8"><a class="anchor" href="#_star_2_8"></a><a class="link" href="#_star_2_8">Star 2</a></h5>
<div class="paragraph">
<p>Similar to star 1. This time, I use the function <code>scenic_score</code> to calculate the scenic score of each tree and the function <code>star_2</code> to find the maximum.</p>
</div>
<div class="paragraph">
<p>In the scenic score calculations, different to the visibility check, the traversal order matters. For left and top directions, the direction is reversed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn scenic_score(&amp;self, x: usize, y: usize) -&gt; usize {
        let h = self.trees[x + (self.w + 1) * y];

        let fx = |&amp;x_: &amp;usize| self.trees[x_ + (self.w + 1) * y] &gt;= h;
        let fy = |&amp;y_: &amp;usize| self.trees[x + (self.w + 1) * y_] &gt;= h;

        (x - (0..x).rev().find(fx).unwrap_or(0))
            * ((x + 1..self.w).find(fx).unwrap_or(self.w - 1) - x)
            * (y - (0..y).rev().find(fy).unwrap_or(0))
            * ((y + 1..self.h).find(fy).unwrap_or(self.h - 1) - y)
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    (0..data.w)
        .map(|x| (0..data.h).map(|y| data.scenic_score(x, y)).max().unwrap())
        .max()
        .unwrap()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_9"><a class="anchor" href="#_tests_9"></a><a class="link" href="#_tests_9">Tests</a></h5>
<div class="paragraph">
<p>Tests for <code>star_1</code>, <code>scenic_score</code> and <code>star_2</code> functions based on example defined in puzzle description.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"30373
25512
65332
33549
35390
"#;

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(21, star_1(&amp;data));
    }

    #[test]
    pub fn test_scenic_score() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(4, data.scenic_score(2, 1));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(8, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_rust"><a class="anchor" href="#_day_09_rust"></a><a class="link" href="#_day_09_rust">Day 09: rust</a></h3>
<div class="sect3">
<h4 id="_day_9_rope_bridge"><a class="anchor" href="#_day_9_rope_bridge"></a><a class="link" href="#_day_9_rope_bridge">Day 9: Rope Bridge</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/9">AoC|2022|9</a>.</p>
</div>
<div class="paragraph">
<p>Knots are moving around, following each other. The difficulty is to figure out where you have your off by one errors or similar. In the end, I had a print function showing current configurations to debug my code (because it actually looks nice, you may want to have a look at the output with <code>cargo test test_star_2 -- --nocapture</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// Print knots for debugging purposes
///
/// Knots are printed by consecutive letters `a`, `b`, ... starting with the head at `a`
///
/// If a knot sits on a spot which is already seen, it is represented by a capital letter `A`, `B`, ...
///
/// The start is indicated by `$` if no knot is located at the start
///
/// Spots that have been seen and where currently no knot is located are shown as `#`
///
/// If several knots sit on top of each other, the first one in the chain is shown.
pub fn print(
    rx: RangeInclusive&lt;isize&gt;,
    ry: RangeInclusive&lt;isize&gt;,
    knots: &amp;[(isize, isize)],
    ((dx, dy), s): ((isize, isize), usize),
    seen: &amp;HashSet&lt;(isize, isize)&gt;,
) {
    println!("\nAfter moving {s} times by ({dx}, {dy}):");
    for y in ry {
        for x in rx.clone() {
            let seen = seen.contains(&amp;(x, y));
            match knots
                .iter()
                .enumerate()
                .find(|(_, (xn, yn))| *xn == x &amp;&amp; *yn == y)
            {
                Some((v, _)) if seen =&gt; print!("{}", (b'A' + v as u8) as char),
                Some((v, _)) =&gt; print!("{}", (b'a' + v as u8) as char),
                None if x == 0 &amp;&amp; y == 0 =&gt; print!("$"),
                _ if seen =&gt; print!("#"),
                _ =&gt; print!("\u{00b7}"),
            }
        }
        println!();
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_input_9"><a class="anchor" href="#_input_9"></a><a class="link" href="#_input_9">Input</a></h5>
<div class="paragraph">
<p>I parse the input in a vec of tuples <code>((dx, dy), s)</code> where <code>dx</code> and <code>dy</code> are the horizontal / vertical unit step changes and <code>s</code> is the number of steps.</p>
</div>
<div class="paragraph">
<p>Not allocating extra memory for today&#8217;s input parsing is not for me ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        moves: Vec&lt;((isize, isize), usize)&gt;,
    }

    impl From&lt;&amp;str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;str) -&gt; Self {
            Self {
                moves: s
                    .lines()
                    .map(|l| match (l.as_bytes()[0], l[2..].parse().unwrap()) {
                        (b'U', s) =&gt; ((0, -1), s),
                        (b'D', s) =&gt; ((0, 1), s),
                        (b'L', s) =&gt; ((-1, 0), s),
                        (b'R', s) =&gt; ((1, 0), s),
                        _ =&gt; panic!("No valid move: {l}"),
                    })
                    .collect(),
            }
        }
    }

    impl PuzzleData {
        pub fn moves(&amp;self) -&gt; &amp;[((isize, isize), usize)] {
            &amp;self.moves
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>After a little bit of refactoring, one solution works for both parts today. The solve function is called with the total number of knots (including head) as a parameter.</p>
</div>
<div class="paragraph">
<p>In each step, it updates the head and then all subsequent knots ony by one.</p>
</div>
<div class="paragraph">
<p>The debug function parameter is a clojure that is called after each move for debugging purposes. In the actual solution, an empty function is used. In the test cases, the <code>print</code> function is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solve&lt;F&gt;(data: &amp;PuzzleData, n: usize, debug: F) -&gt; usize
where
    F: Fn(&amp;[(isize, isize)], ((isize, isize), usize), &amp;HashSet&lt;(isize, isize)&gt;) -&gt; (),
{
    let mut seen: HashSet&lt;(isize, isize)&gt; = HashSet::from([(0, 0)]);
    let mut knots: Vec&lt;(isize, isize)&gt; = vec![(0, 0); n];

    for ((dx, dy), s) in data.moves() {
        for _ in 0..*s {
            knots[0].0 += *dx;
            knots[0].1 += *dy;

            for k in 1..n {
                let dx = knots[k].0 - knots[k - 1].0;
                let dy = knots[k].1 - knots[k - 1].1;

                knots[k].0 += (dx &lt; -1 || (dx == -1 &amp;&amp; dy.abs() &gt; 1)) as isize
                    - (dx &gt; 1 || (dx == 1 &amp;&amp; dy.abs() &gt; 1)) as isize;

                knots[k].1 += (dy &lt; -1 || (dy == -1 &amp;&amp; dx.abs() &gt; 1)) as isize
                    - (dy &gt; 1 || (dy == 1 &amp;&amp; dx.abs() &gt; 1)) as isize;
            }

            seen.insert(knots[n - 1]);
        }

        debug(&amp;knots, ((*dx, *dy), *s), &amp;seen);
    }

    seen.len()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_10"><a class="anchor" href="#_tests_10"></a><a class="link" href="#_tests_10">Tests</a></h5>
<div class="paragraph">
<p>The usual tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
"#;

    const CONTENT_2: &amp;str = r#"R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
"#;

    #[test]
    pub fn test_try_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(
            13,
            solve(&amp;data, 2, |knots, mv, seen| print(
                0..=5,
                -5..=0,
                knots,
                mv,
                seen
            ))
        );
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(1, solve(&amp;data, 10, |_, _, _| ()));

        let data = PuzzleData::from(CONTENT_2);
        assert_eq!(
            36,
            solve(&amp;data, 10, |knots, mv, seen| print(
                -11..=14,
                -15..=5,
                knots,
                mv,
                seen
            ))
        );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_7"><a class="anchor" href="#_today_i_learned_7"></a><a class="link" href="#_today_i_learned_7">Today I learned</a></h5>
<div class="paragraph">
<p>That sometimes it is helpful to write <code>as _</code> to give the rust compiler a hint to perform type coercion. Although in the end, I did not use it in my solution.</p>
</div>
<div class="paragraph">
<p>And, today for the first time, I used my scripted solution to submit results. Not because it is faster (who cares about a few seconds) but because it is fun.</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_rust"><a class="anchor" href="#_day_10_rust"></a><a class="link" href="#_day_10_rust">Day 10: rust</a></h3>
<div class="sect3">
<h4 id="_day_10_cathode_ray_tube"><a class="anchor" href="#_day_10_cathode_ray_tube"></a><a class="link" href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/10">AoC|2022|10</a>.</p>
</div>
<div class="paragraph">
<p>Today is about a simple CPU which is used to control a simple display (a cathode-ray tube)</p>
</div>
<div class="sect4">
<h5 id="_input_10"><a class="anchor" href="#_input_10"></a><a class="link" href="#_input_10">Input</a></h5>
<div class="paragraph">
<p>Parsing the input is straight forward. Each line represents either an <code>addx</code> operation or a <code>noop</code> operation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub enum Instr {
        NoOp,
        AddX(isize),
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        instructions: Vec&lt;Instr&gt;,
    }

    impl From&lt;&amp;'static str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'static str) -&gt; Self {
            Self {
                instructions: s
                    .lines()
                    .map(|l| match l {
                        "noop" =&gt; Instr::NoOp,
                        _ =&gt; Instr::AddX(l[5..].parse().unwrap()),
                    })
                    .collect(),
            }
        }
    }

    impl PuzzleData {
        pub fn instructions(&amp;self) -&gt; &amp;[Instr] {
            &amp;&amp;self.instructions
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_9"><a class="anchor" href="#_star_1_9"></a><a class="link" href="#_star_1_9">Star 1</a></h5>
<div class="paragraph">
<p>I created a small model of the CPU:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct Cpu {
    instructions: Vec&lt;Instr&gt;,
    pointer: usize,
    cycle: usize,
    timer: usize,
    x: isize,
}

impl Cpu {
    pub fn init(instructions: &amp;[Instr]) -&gt; Self {
        let mut cpu = Self {
            instructions: Vec::from(instructions),
            pointer: 0,
            cycle: 0,
            timer: 0,
            x: 1,
        };

        // set initial timer if required
        if let Instr::AddX(_) = cpu.instructions[0] {
            cpu.timer = 1;
        }

        cpu
    }

    pub fn step(&amp;mut self) {
        // should not be called if no more instructions
        assert!(self.pointer &lt; self.instructions.len(), "Cpu halted");

        if self.timer &gt; 0 {
            // only decrement timer
            self.timer -= 1;
        } else {
            // apply increment
            if let Instr::AddX(inc) = self.instructions[self.pointer] {
                self.x += inc;
            }

            // increment pointer
            self.pointer += 1;

            // set timer if required
            if self.pointer &lt; self.instructions.len() {
                if let Instr::AddX(_) = self.instructions[self.pointer] {
                    self.timer = 1;
                }
            }
        }

        // increment cycle counter
        self.cycle += 1;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most difficult part was to read the puzzle description carefully. Specifically the part were it says to calculate the signal strength <strong>during</strong> and not <strong>after</strong> the 20th, 60th, &#8230;&#8203; cycle.</p>
</div>
<div class="paragraph">
<p>The rest was just applying the instructions giving in the puzzle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; isize {
    let mut cpu = Cpu::init(data.instructions());

    // we first look during 20th cycle, i.e., after 19th cycle
    for _ in 0..19 {
        cpu.step();
    }
    let mut v = (cpu.cycle as isize + 1) * cpu.x;

    // 5 blocks of 40 cycles
    for _ in 0..5 {
        for _ in 0..40 {
            cpu.step();
        }
        v += (cpu.cycle as isize + 1) * cpu.x;
    }

    v
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_9"><a class="anchor" href="#_star_2_9"></a><a class="link" href="#_star_2_9">Star 2</a></h5>
<div class="paragraph">
<p>Again, reading carefully is important. I did not get the meaning of</p>
</div>
<div class="listingblock">
<div class="content">
<pre>In this system, there is no such thing as "vertical position"</pre>
</div>
</div>
<div class="paragraph">
<p>After having that fixed, it was again straight forward. It somehow feels incorrect to manually read the "LCD" to produce the result to enter at the website, hence I created a little helper which recognizes the letters. Since there is nothing to recognize for the sample data, I put the recognition in a separate function to still be able to run my code on the examples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn solve_2(data: &amp;PuzzleData) -&gt; [u8; 240] {
    const W: usize = 40;
    const H: usize = 6;

    // initialize lcd with new lines, W + 1 to keep new lines at the and
    let mut lcd = [b'.'; W * H];

    let mut cpu = Cpu::init(data.instructions());
    for row in 0..H {
        for col in 0..W {
            lcd[col as usize + W * row] = if (cpu.x - 1..=cpu.x + 1).contains(&amp;(col as _)) {
                LIT as u8
            } else {
                DARK as u8
            };
            cpu.step();
        }
    }

    lcd
}

pub fn star_2(data: &amp;PuzzleData) -&gt; String {
    solve_2(data).decode(0).unwrap()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_11"><a class="anchor" href="#_tests_11"></a><a class="link" href="#_tests_11">Tests</a></h5>
<div class="paragraph">
<p>A bit of tests, as usual &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_try_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(13_140, star_1(&amp;data));
    }

    #[test]
    pub fn test_solve_2() {
        let data = PuzzleData::from(CONTENT);
        let b = solve_2(&amp;data);
        let mut s = String::with_capacity(41 * 6);
        for row in 0..6 {
            for col in 0..40 {
                s.push(b[col + 40 * row] as _);
            }
            s.push('\n');
        }
        assert_eq!(EXP_2, s);
    }

    #[test]
    pub fn test_simple() {
        let data = PuzzleData::from(CONTENT_SIMPLE);
        let mut cpu = Cpu::init(data.instructions());
        let r = (0..5)
            .map(|_| {
                cpu.step();
                cpu.x
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();
        let exp: &amp;[isize] = &amp;[1, 1, 4, 4, -1];
        assert_eq!(exp, r);
    }

    const CONTENT_SIMPLE: &amp;str = r#"noop
addx 3
addx -5"#;

    const EXP_2: &amp;str = r"##..##..##..##..##..##..##..##..##..##..
###...###...###...###...###...###...###.
####....####....####....####....####....
#####.....#####.....#####.....#####.....
######......######......######......####
#######.......#######.......#######.....
";

    const CONTENT: &amp;str = r#"addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
"#;
}</code></pre>
</div>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_rust"><a class="anchor" href="#_day_11_rust"></a><a class="link" href="#_day_11_rust">Day 11: rust</a></h3>
<div class="sect3">
<h4 id="_day_11_monkey_in_the_middle"><a class="anchor" href="#_day_11_monkey_in_the_middle"></a><a class="link" href="#_day_11_monkey_in_the_middle">Day 11: Monkey in the Middle</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/11">AoC|2022|11</a>.</p>
</div>
<div class="paragraph">
<p>It was quite tedious today for me to create the solution.</p>
</div>
<div class="paragraph">
<p>I liked the twist in part 2. Since each monkey does a modulo <code>test</code> before passing on the item, we can safely do a modulo with the product of all tests of all monkeys to keep the numbers small. Still took me a while to complete part two because I just replaced the <code>/ 3</code> from the first part with <code>/ mod</code> in the second part which is obviously not the same as <code>% mod</code>. And I have to confess that my first attempt was to use 128bit numbers.</p>
</div>
<div class="sect4">
<h5 id="_input_11"><a class="anchor" href="#_input_11"></a><a class="link" href="#_input_11">Input</a></h5>
<div class="paragraph">
<p>Parsing was a pain today. I almost regret my decision to not use external dependencies (and thus not use Regex) &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub enum Operation {
        Plus(usize),
        Times(usize),
        Square,
        Double,
    }

    impl Operation {
        pub fn apply(&amp;self, item: usize) -&gt; usize {
            match self {
                Operation::Plus(v) =&gt; item + v,
                Operation::Times(v) =&gt; item * v,
                Operation::Square =&gt; item * item,
                Operation::Double =&gt; item + item,
            }
        }
    }

    #[derive(Debug, PartialEq, Eq, Clone)]
    pub struct Monkey {
        pub worries: Vec&lt;usize&gt;,
        pub upd: Operation,
        pub test: usize,
        pub if_true: usize,
        pub if_false: usize,
    }

    impl From&lt;&amp;'static str&gt; for Monkey {
        fn from(monkey: &amp;'static str) -&gt; Self {
            let words = monkey.split_ascii_whitespace();

            let mut words = words.skip(4); // Monkey &lt;id&gt;: Starting items:

            let mut worries = Vec::new();
            let mut word = words.next().unwrap();
            while word != "Operation:" {
                worries.push(word.trim_end_matches(',').parse().unwrap());
                word = words.next().unwrap();
            }

            let mut words = words.skip(3); // new = old

            let upd = match (words.next().unwrap(), words.next().unwrap()) {
                ("*", "old") =&gt; Operation::Square,
                ("+", "old") =&gt; Operation::Double,
                ("*", v) =&gt; Operation::Times(v.parse().unwrap()),
                ("+", v) =&gt; Operation::Plus(v.parse().unwrap()),
                _ =&gt; unreachable!(),
            };

            let mut words = words.skip(3); // Test: divisible by

            let test = words.next().unwrap().parse().unwrap();

            let mut words = words.skip(5); // If true: throw to monkey

            let if_true = words.next().unwrap().parse().unwrap();

            let mut words = words.skip(5); // If false: throw to monkey

            let if_false = words.next().unwrap().parse().unwrap();

            Self {
                worries,
                upd,
                test,
                if_true,
                if_false,
            }
        }
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        monkeys: Vec&lt;Monkey&gt;,
    }

    impl From&lt;&amp;'static str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'static str) -&gt; Self {
            Self {
                monkeys: s.split("\n\n").map(Monkey::from).collect(),
            }
        }
    }

    impl PuzzleData {
        pub fn monkeys(&amp;self) -&gt; &amp;[Monkey] {
            &amp;self.monkeys
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution_2"><a class="anchor" href="#_solution_2"></a><a class="link" href="#_solution_2">Solution</a></h5>
<div class="paragraph">
<p>Here is my solution for both parts. The <code>solve</code> function is called with <code>div = 3</code> for the first part and <code>div = 1</code> for the second.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn round(monkeys: &amp;mut Vec&lt;Monkey&gt;, counts: &amp;mut Vec&lt;usize&gt;, div: usize, m: usize) {
    for id in 0..monkeys.len() {
        counts[id] += monkeys[id].worries.len();
        for k in 0..monkeys[id].worries.len() {
            let worry = (monkeys[id].upd.apply(monkeys[id].worries[k]) / div) % m;
            let target = if worry % monkeys[id].test == 0 {
                monkeys[id].if_true
            } else {
                monkeys[id].if_false
            };
            monkeys[target].worries.push(worry);
        }
        monkeys[id].worries.clear();
    }
}

pub fn solve(data: &amp;PuzzleData, div: usize, rounds: usize) -&gt; usize {
    let mut monkeys = Vec::from(data.monkeys());
    let mut counts = vec![0; monkeys.len()];
    let m = monkeys.iter().map(|monkey| monkey.test).product();

    for _ in 0..rounds {
        round(&amp;mut monkeys, &amp;mut counts, div, m);
    }

    counts.sort_unstable();

    counts.pop().unwrap() as usize * counts.pop().unwrap() as usize
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_12"><a class="anchor" href="#_tests_12"></a><a class="link" href="#_tests_12">Tests</a></h5>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>and the tests</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"Monkey 0:
Starting items: 79, 98
Operation: new = old * 19
Test: divisible by 23
  If true: throw to monkey 2
  If false: throw to monkey 3

Monkey 1:
Starting items: 54, 65, 75, 74
Operation: new = old + 6
Test: divisible by 19
  If true: throw to monkey 2
  If false: throw to monkey 0

Monkey 2:
Starting items: 79, 60, 97
Operation: new = old * old
Test: divisible by 13
  If true: throw to monkey 1
  If false: throw to monkey 3

Monkey 3:
Starting items: 74
Operation: new = old + 3
Test: divisible by 17
  If true: throw to monkey 0
  If false: throw to monkey 1
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_round() {
        let data = PuzzleData::from(CONTENT);
        let mut monkeys = Vec::from(data.monkeys());
        let mut counts = vec![0; monkeys.len()];
        round(&amp;mut monkeys, &amp;mut counts, 3, usize::MAX);
        assert_eq!(vec![20, 23, 27, 26], monkeys[0].worries);
        assert_eq!(vec![2080, 25, 167, 207, 401, 1046], monkeys[1].worries);
        assert!(monkeys[2].worries.is_empty());
        assert!(monkeys[3].worries.is_empty());
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(10605, solve(&amp;data, 3, 20));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);

        assert_eq!(4 * 6, solve(&amp;data, 1, 1));
        assert_eq!(99 * 103, solve(&amp;data, 1, 20));

        assert_eq!(2_713_310_158, solve(&amp;data, 1, 10_000));
    }
}</code></pre>
</div>
</div>
<a id="day12" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_12_rust"><a class="anchor" href="#_day_12_rust"></a><a class="link" href="#_day_12_rust">Day 12: rust</a></h3>
<div class="sect3">
<h4 id="_day_12_hill_climbing_algorithm"><a class="anchor" href="#_day_12_hill_climbing_algorithm"></a><a class="link" href="#_day_12_hill_climbing_algorithm">Day 12: Hill Climbing Algorithm</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/12">AoC|2022|12</a>.</p>
</div>
<div class="paragraph">
<p>The first path finding challenge in 2022&#8217;s AoC edition ;)</p>
</div>
<div class="sect4">
<h5 id="_input_12"><a class="anchor" href="#_input_12"></a><a class="link" href="#_input_12">Input</a></h5>
<div class="paragraph">
<p>I parse the input into a grid of bytes stored in a vec and additionally determine the starting position, the target position and the width of the grid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub grid: Vec&lt;u8&gt;,
        pub width: usize,
        pub start: usize,
        pub target: usize,
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            let width = s.find('\n').unwrap();

            let mut grid: Vec&lt;_&gt; = s
                .as_bytes()
                .iter()
                .cloned()
                .filter(|b| *b != b'\n')
                .collect();
            let start = grid.iter().position(|&amp;b| b == b'S').unwrap();
            let target = grid.iter().position(|&amp;b| b == b'E').unwrap();

            grid[start] = b'a';
            grid[target] = b'z';

            Self {
                grid,
                width,
                start,
                target,
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_10"><a class="anchor" href="#_star_1_10"></a><a class="link" href="#_star_1_10">Star 1</a></h5>
<div class="paragraph">
<p>The shortest path is found by a breadth first traversal.</p>
</div>
<div class="paragraph">
<p>The function <code>shortest_path</code> returns an option with a <code>None</code> value in case no path is found. My initial version just panicked in that case which turned out to not be good enough for part 2.</p>
</div>
<div class="paragraph">
<p>Today, I made the baddest mistake ever: I put the wrong number in my test (32 instead of 31) and was trying to figure out for quite some while where I inserted an off-by-one error in my code until I figured that my expected value was wrong.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn shortest_path(data: &amp;PuzzleData, start: usize) -&gt; Option&lt;usize&gt; {
    let mut queue = VecDeque::new();
    queue.push_back((0, start));

    let mut seen = vec![false; data.grid.len()];
    seen[start] = true;

    let height = data.grid.len() / data.width;

    while let Some((steps, pos)) = queue.pop_front() {
        if pos == data.target {
            return Some(steps);
        }

        let x = pos % data.width;
        let y = pos / data.width;

        for (chk, nxt) in [
            (x &gt; 0, pos as isize - 1),
            (x &lt; data.width - 1, pos as isize + 1),
            (y &gt; 0, pos as isize - data.width as isize),
            (y &lt; height - 1, pos as isize + data.width as isize),
        ] {
            if chk &amp;&amp; !seen[nxt as usize] &amp;&amp; data.grid[nxt as usize] &lt;= data.grid[pos] + 1 {
                queue.push_back((steps + 1, nxt as _));
                seen[nxt as usize] = true;
            }
        }
    }

    None
}

pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    shortest_path(data, data.start).unwrap()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_10"><a class="anchor" href="#_star_2_10"></a><a class="link" href="#_star_2_10">Star 2</a></h5>
<div class="paragraph">
<p>Just perform shortest path calculation for all possible starting positions (that was my solution to submit the answer)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2_original(data: &amp;PuzzleData) -&gt; usize {
    (0..data.grid.len())
        .filter(|&amp;k| data.grid[k] == b'a')
        .filter_map(|start| shortest_path(data, start))
        .min()
        .unwrap()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then I realized it is much simpler if I just reverse the search direction and look for the shortest path from the target to any 'a'. So I did that to have another sub 1ms solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn shortest_path_2&lt;F, G&gt;(data: &amp;PuzzleData, start: usize, reached: F, check: G) -&gt; Option&lt;usize&gt;
where
    F: Fn(usize) -&gt; bool,
    G: Fn(u8, u8) -&gt; bool,
{
    let mut queue = VecDeque::new();
    queue.push_back((0, start));

    let mut seen = vec![false; data.grid.len()];
    seen[start] = true;

    let height = data.grid.len() / data.width;

    while let Some((steps, pos)) = queue.pop_front() {
        if reached(pos) {
            return Some(steps);
        }

        let x = pos % data.width;
        let y = pos / data.width;

        for (chk, nxt) in [
            (x &gt; 0, pos as isize - 1),
            (x &lt; data.width - 1, pos as isize + 1),
            (y &gt; 0, pos as isize - data.width as isize),
            (y &lt; height - 1, pos as isize + data.width as isize),
        ] {
            if chk &amp;&amp; !seen[nxt as usize] &amp;&amp; check(data.grid[pos], data.grid[nxt as usize]) {
                queue.push_back((steps + 1, nxt as _));
                seen[nxt as usize] = true;
            }
        }
    }

    None
}

pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    shortest_path_2(
        data,
        data.target,
        |pos| data.grid[pos] == b'a',
        |f, t| f &lt;= t + 1,
    )
    .unwrap()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>shortest_path_2</code> function is generic to also work for part 1, but I did not change it in my code. Here is how to call it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-rust" data-lang="rust">shortest_path_2(data, data.start, |pos| pos == data.target, |f, t| t &lt;= f + 1).unwrap()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_13"><a class="anchor" href="#_tests_13"></a><a class="link" href="#_tests_13">Tests</a></h5>
<div class="paragraph">
<p>And the mandatory tests. But be careful, if a test of the type <code>expected == actual</code> fails, there are two possible reasons: <code>actual</code> can be wrong or <code>expected</code> can be wrong.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(8, data.width);
        assert_eq!(0, data.start);
        assert_eq!(21, data.target);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(31, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(29, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day13" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_13_rust"><a class="anchor" href="#_day_13_rust"></a><a class="link" href="#_day_13_rust">Day 13: rust</a></h3>
<div class="sect3">
<h4 id="_day_13_distress_signal"><a class="anchor" href="#_day_13_distress_signal"></a><a class="link" href="#_day_13_distress_signal">Day 13: Distress Signal</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/13">AoC|2022|13</a>.</p>
</div>
<div class="paragraph">
<p>My initial solution was based on "If the input looks like a tree structure, parse it into a tree structure!"</p>
</div>
<div class="sect4">
<h5 id="_input_13"><a class="anchor" href="#_input_13"></a><a class="link" href="#_input_13">Input</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub mod input {
        use super::node::Node;

        pub struct PuzzleData {
            pub nodes: Vec&lt;Node&gt;,
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
            fn from(s: &amp;'a str) -&gt; Self {
                Self {
                    nodes: s
                        .lines()
                        .filter(|l| !l.is_empty())
                        .map(|l| Node::from(l))
                        .collect(),
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution_3"><a class="anchor" href="#_solution_3"></a><a class="link" href="#_solution_3">Solution</a></h5>
<div class="paragraph">
<p>The whole work for the solution is in the recursive <code>Node</code> enum modeling the trees represented by the puzzle input with its implementation. Namely recursive parsing in the <code>parse</code> function and comparison in the <code>Ord</code> trait implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub mod node {
        //! Tree structure for recursive lists from puzzle
        use std::cmp::Ordering;

        #[derive(Debug, Eq, PartialEq, Clone)]
        pub enum Node {
            List(Box&lt;[Node]&gt;),
            Value(usize),
        }

        impl std::fmt::Display for Node {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                match self {
                    Node::List(list) =&gt; {
                        '['.fmt(f)?;
                        for n in list.iter().take(1) {
                            n.fmt(f)?;
                        }
                        for n in list.iter().skip(1) {
                            ','.fmt(f)?;
                            n.fmt(f)?;
                        }
                        ']'.fmt(f)?;
                    }
                    Node::Value(value) =&gt; value.fmt(f)?,
                }

                Ok(())
            }
        }

        impl&lt;T&gt; From&lt;T&gt; for Node
        where
            T: AsRef&lt;[u8]&gt;,
        {
            fn from(s: T) -&gt; Self {
                Self::parse(s.as_ref(), 0).0
            }
        }

        impl Ord for Node {
            fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
                match (self, other) {
                    (Node::List(lhs), Node::List(rhs)) =&gt; {
                        for k in 0..lhs.len().min(rhs.len()) {
                            let o = lhs[k].cmp(&amp;rhs[k]);
                            if o != Ordering::Equal {
                                return o;
                            }
                        }
                        lhs.len().cmp(&amp;rhs.len())
                    }
                    (Node::Value(lhs), Node::Value(rhs)) =&gt; lhs.cmp(rhs),
                    (_, Node::Value(rhs)) =&gt; self.cmp(&amp;Node::List(vec![Node::Value(*rhs)].into())),
                    (Node::Value(lhs), _) =&gt; Node::List(vec![Node::Value(*lhs)].into()).cmp(other),
                }
            }
        }

        impl PartialOrd for Node {
            fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
                Some(self.cmp(other))
            }
        }

        impl Node {
            fn parse(s: &amp;[u8], pos: usize) -&gt; (Self, usize) {
                if s[pos] == b'[' &amp;&amp; s[pos + 1] == b']' {
                    // handle empty list separately
                    (Self::List(vec![].into()), 2)
                } else if s[pos] == b'[' {
                    let mut v = Vec::new();
                    let mut len = 1;
                    loop {
                        let (n, l) = Self::parse(s, pos + len);
                        v.push(n);
                        len += l + 1;
                        if s[pos + len - 1] == b']' {
                            break;
                        }
                    }
                    (Self::List(v.into()), len)
                } else {
                    let mut v = 0;
                    let mut len = 0;
                    while pos + len &lt; s.len() &amp;&amp; s[pos + len] &gt;= b'0' &amp;&amp; s[pos + len] &lt;= b'9' {
                        v = v * 10 + (s[pos + len] - b'0') as usize;
                        len += 1;
                    }
                    (Self::Value(v), len)
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_11"><a class="anchor" href="#_star_1_11"></a><a class="link" href="#_star_1_11">Star 1</a></h5>
<div class="paragraph">
<p>Do the pairwise comparisons.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        data.nodes
            .iter()
            .step_by(2)
            .zip(data.nodes.iter().skip(1).step_by(2))
            .enumerate()
            .filter(|(_, (a, b))| a.cmp(b) != Ordering::Greater)
            .fold(0, |s, (k, _)| s + k + 1)
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_11"><a class="anchor" href="#_star_2_11"></a><a class="link" href="#_star_2_11">Star 2</a></h5>
<div class="paragraph">
<p>Find the position of the divider packets after sorting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        let mut v = data.nodes.clone();
        v.push(Node::from("[[2]]"));
        v.push(Node::from("[[6]]"));
        v.sort_unstable();

        let a = v.iter().position(|n| n == &amp;Node::from("[[2]]")).unwrap();
        let b = v.iter().position(|n| n == &amp;Node::from("[[6]]")).unwrap();

        (a + 1) * (b + 1)
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_14"><a class="anchor" href="#_tests_14"></a><a class="link" href="#_tests_14">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::tree::node::Node;

        #[test]
        pub fn test_parse() {
            let s = "[1,[2,[3,[4,[5,6,7]]]],8,9]";
            let n = Node::from(s);
            println!("{n:?}");
            assert_eq!(s, n.to_string());
        }

        #[test]
        pub fn test_cmp() {
            let nodes = PuzzleData::from(crate::tests::CONTENT).nodes;
            let cmp = nodes
                .iter()
                .step_by(2)
                .zip(nodes.iter().skip(1).step_by(2))
                .map(|(a, b)| a.cmp(b))
                .collect::&lt;Vec&lt;_&gt;&gt;();
            println!("{cmp:?}");
            assert_eq!(
                vec![
                    Ordering::Less,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Greater
                ],
                cmp
            );
        }

        #[test]
        pub fn test_star_1() {
            assert_eq!(13, star_1(&amp;PuzzleData::from(crate::tests::CONTENT)))
        }

        #[test]
        pub fn test_star_2() {
            assert_eq!(140, star_2(&amp;PuzzleData::from(crate::tests::CONTENT)))
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_alternative_without_using_heap"><a class="anchor" href="#_alternative_without_using_heap"></a><a class="link" href="#_alternative_without_using_heap">Alternative without using heap</a></h5>
<div class="paragraph">
<p>Later on, I thought it should be possible to implement a solution that does not require any heap allocations by directly iterating on the input data. I added this in a variant of my solution in <code>mod iter</code>. You can run this variant using <code>cargo run --release --features no-heap</code>. Interestingly it is not really performing any better than the original solution. The advantage for the second part is probably mainly caused by avoiding to sort.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod iter {
    use self::node::List;
    use self::{input::PuzzleData, node::Node};
    use mr_kaffee_aoc::{Puzzle, Star};
    use std::cmp::Ordering;

    /// the puzzle
    pub fn puzzle() -&gt; Puzzle&lt;'static, PuzzleData&lt;'static&gt;, usize, usize, usize, usize&gt; {
        Puzzle {
            year: 2022,
            day: 13,
            input: include_str!("../input.txt"),
            star1: Some(Star {
                name: "Star 1",
                f: &amp;star_1,
                exp: Some(5_675),
            }),
            star2: Some(Star {
                name: "Star 2",
                f: &amp;star_2,
                exp: Some(20_383),
            }),
        }
    }

    pub mod input {
        pub struct PuzzleData&lt;'a&gt; {
            pub input: &amp;'a str,
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData&lt;'a&gt; {
            fn from(input: &amp;'a str) -&gt; Self {
                Self { input }
            }
        }
    }

    pub mod node {
        use std::{cmp::Ordering, iter::once};

        #[derive(Debug, Clone)]
        pub struct List&lt;'a&gt; {
            data: &amp;'a [u8],
            pos: usize,
        }

        #[derive(Debug, Clone)]
        pub enum Node&lt;'a&gt; {
            List(List&lt;'a&gt;),
            Value(usize),
        }

        impl&lt;'a&gt; std::fmt::Display for Node&lt;'a&gt; {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                match self {
                    Node::List(list) =&gt; list.fmt(f),
                    Node::Value(value) =&gt; value.fmt(f),
                }
            }
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Node&lt;'a&gt; {
            fn from(s: &amp;'a str) -&gt; Self {
                if s.starts_with('[') {
                    Self::List(List::from(s))
                } else {
                    Self::Value(s.parse().unwrap())
                }
            }
        }

        impl&lt;'a&gt; std::fmt::Display for List&lt;'a&gt; {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                let mut level = 1;
                '['.fmt(f)?;
                for &amp;b in &amp;self.data[self.pos..] {
                    level = match b {
                        b'[' =&gt; level + 1,
                        b']' =&gt; level - 1,
                        _ =&gt; level,
                    };
                    (b as char).fmt(f)?;
                    if level == 0 {
                        break;
                    }
                }
                Ok(())
            }
        }

        impl&lt;'a&gt; From&lt;&amp;'a [u8]&gt; for List&lt;'a&gt; {
            fn from(s: &amp;'a [u8]) -&gt; Self {
                let data = s.as_ref();
                let pos = if data[0] == b'[' { 1 } else { 0 };
                Self { data, pos }
            }
        }

        impl&lt;'a&gt; From&lt;&amp;'a str&gt; for List&lt;'a&gt; {
            fn from(s: &amp;'a str) -&gt; Self {
                Self::from(s.as_bytes())
            }
        }

        impl&lt;'a&gt; Iterator for List&lt;'a&gt; {
            type Item = Node&lt;'a&gt;;

            fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
                if self.pos &gt;= self.data.len() || self.data[self.pos] == b']' {
                    // exhausted
                    None
                } else if self.data[self.pos] == b'[' {
                    // parse list
                    let nxt = Self::Item::List(List::from(&amp;self.data[self.pos..]));

                    // advance pos to after list
                    self.pos += 2 + self.data[self.pos + 1..]
                        .iter()
                        .scan(1usize, |level, b| {
                            match b {
                                b'[' =&gt; *level += 1,
                                b']' =&gt; *level -= 1,
                                _ =&gt; (),
                            };
                            Some(*level)
                        })
                        .position(|level| level == 0)
                        .unwrap();

                    // skip ',' if applicable
                    if self.pos &lt; self.data.len() &amp;&amp; self.data[self.pos] == b',' {
                        self.pos += 1;
                    }

                    // return list
                    Some(nxt)
                } else {
                    // parse value
                    let mut v = 0;
                    while (b'0'..=b'9').contains(&amp;self.data[self.pos]) {
                        // parse digit
                        v = 10 * v + (self.data[self.pos] - b'0') as usize;
                        self.pos += 1;
                    }

                    // skip ',' if applicable
                    if self.pos &lt; self.data.len() &amp;&amp; self.data[self.pos] == b',' {
                        self.pos += 1;
                    }

                    // return value
                    Some(Self::Item::Value(v))
                }
            }
        }

        impl&lt;'a&gt; Ord for Node&lt;'a&gt; {
            fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
                match (self, other) {
                    (Node::Value(lhs), Node::Value(rhs)) =&gt; lhs.cmp(rhs),
                    (Node::List(lhs), Node::List(rhs)) =&gt; lhs.clone().cmp(rhs.clone()),
                    (Node::List(lhs), rhs) =&gt; lhs.clone().cmp(once(rhs.clone())),
                    (lhs, Node::List(rhs)) =&gt; once(lhs.clone()).cmp(rhs.clone()),
                }
            }
        }

        impl&lt;'a&gt; PartialOrd for Node&lt;'a&gt; {
            fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
                Some(self.cmp(other))
            }
        }

        impl&lt;'a&gt; PartialEq for Node&lt;'a&gt; {
            fn eq(&amp;self, other: &amp;Self) -&gt; bool {
                self.cmp(other) == Ordering::Equal
            }
        }

        impl&lt;'a&gt; Eq for Node&lt;'a&gt; {}
    }

    pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
        let mut lines = data.input.lines().filter(|l| !l.is_empty());
        let mut idx = 0;
        let mut result = 0;
        while let (Some(a), Some(b)) = (lines.next(), lines.next()) {
            idx += 1;
            if Node::from(a).cmp(&amp;Node::from(b)) != Ordering::Greater {
                result += idx;
            }
        }

        result
    }

    pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
        let n_1 = List::from("[[2]]");
        let n_2 = List::from("[[6]]");

        let (cnt_1, cnt_2) =
            data.input
                .lines()
                .filter(|l| !l.is_empty())
                .fold((1, 2), |(cnt_1, cnt_2), l| {
                    if n_1.clone().cmp(List::from(l)) == Ordering::Greater {
                        (cnt_1 + 1, cnt_2 + 1)
                    } else if n_2.clone().cmp(List::from(l)) == Ordering::Greater {
                        (cnt_1, cnt_2 + 1)
                    } else {
                        (cnt_1, cnt_2)
                    }
                });

        cnt_1 * cnt_2
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::iter::node::{List, Node};

        #[test]
        pub fn test_next() {
            let mut list = List::from("[10,[[9,10,0],2]]");
            assert_eq!(Some("10".into()), list.next().map(|n| n.to_string()));
            assert_eq!(
                Some("[[9,10,0],2]".into()),
                list.next().map(|n| n.to_string())
            );
            assert!(list.next().is_none());
        }

        #[test]
        pub fn test_cmp() {
            let nodes = crate::tests::CONTENT
                .lines()
                .filter(|l| !l.is_empty())
                .map(List::from)
                .map(Node::List)
                .collect::&lt;Vec&lt;_&gt;&gt;();

            let cmp = nodes
                .iter()
                .step_by(2)
                .zip(nodes.iter().skip(1).step_by(2))
                .map(|(a, b)| a.cmp(b))
                .collect::&lt;Vec&lt;_&gt;&gt;();
            println!("{cmp:?}");
            assert_eq!(
                vec![
                    Ordering::Less,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Less,
                    Ordering::Greater,
                    Ordering::Greater
                ],
                cmp
            );
        }

        #[test]
        pub fn test_star_1() {
            assert_eq!(13, star_1(&amp;PuzzleData::from(crate::tests::CONTENT)))
        }

        #[test]
        pub fn test_star_2() {
            assert_eq!(140, star_2(&amp;PuzzleData::from(crate::tests::CONTENT)))
        }
    }
}</code></pre>
</div>
</div>
<a id="day14" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_14_rust"><a class="anchor" href="#_day_14_rust"></a><a class="link" href="#_day_14_rust">Day 14: rust</a></h3>
<div class="sect3">
<h4 id="_day_14_regolith_reservoir"><a class="anchor" href="#_day_14_regolith_reservoir"></a><a class="link" href="#_day_14_regolith_reservoir">Day 14: Regolith Reservoir</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/14">AoC|2022|14</a>.</p>
</div>
<div class="paragraph">
<p>I was remembered of <a href="https://adventofcode.com/2018/day/17">AoC|2018|17</a> even without the hint in the puzzle.</p>
</div>
<div class="paragraph">
<p>I don&#8217;t think my solution is very elegant, but at the moment, I do not have an idea how to create a nice one &#8230;&#8203;</p>
</div>
<div class="sect4">
<h5 id="_input_14"><a class="anchor" href="#_input_14"></a><a class="link" href="#_input_14">Input</a></h5>
<div class="paragraph">
<p>I parse the input in a vec of paths, where each path is vec of points. The structure <code>PuzzleData</code> has methods to compute the bounding box for all points (<code>bbox</code>) and build a 2D grid using the paths specified (<code>grid</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        paths: Vec&lt;Vec&lt;(isize, isize)&gt;&gt;,
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            Self {
                paths: s
                    .lines()
                    .map(|l| {
                        l.split(" -&gt; ")
                            .map(|c| c.split_once(',').unwrap())
                            .map(|(x, y)| (x.parse().unwrap(), y.parse().unwrap()))
                            .collect()
                    })
                    .collect(),
            }
        }
    }

    impl&lt;'a&gt; PuzzleData {
        pub fn bbox(&amp;self) -&gt; (isize, isize, isize, isize) {
            self.paths.iter().fold((500, 0, 501, 1), |bbox, v| {
                v.iter().fold(bbox, |(x_mn, y_mn, x_mx, y_mx), (x, y)| {
                    (x_mn.min(*x), y_mn.min(*y), x_mx.max(x + 1), y_mx.max(y + 1))
                })
            })
        }

        /// get a grid as flat list of chars, the width of the grid, and the point of sand inflow
        pub fn grid(&amp;self) -&gt; (Vec&lt;char&gt;, usize, (usize, usize)) {
            let (x_mn, y_mn, x_mx, y_mx) = self.bbox();
            let width = (x_mx - x_mn) as usize;
            let height = (y_mx - y_mn) as usize;
            let mut grid = vec!['.'; width * height];

            for path in &amp;self.paths {
                for k in 1..path.len() {
                    let (dx, dy, len) = if path[k].0 &gt; path[k - 1].0 {
                        assert!(path[k].1 == path[k - 1].1);
                        (1, 0, path[k].0 - path[k - 1].0)
                    } else if path[k].0 &lt; path[k - 1].0 {
                        assert!(path[k].1 == path[k - 1].1);
                        (-1, 0, path[k - 1].0 - path[k].0)
                    } else if path[k].1 &gt; path[k - 1].1 {
                        assert!(path[k].0 == path[k - 1].0);
                        (0, 1, path[k].1 - path[k - 1].1)
                    } else if path[k].1 &lt; path[k - 1].1 {
                        assert!(path[k].0 == path[k - 1].0);
                        (0, -1, path[k - 1].1 - path[k].1)
                    } else {
                        unreachable!()
                    };

                    let x0 = path[k - 1].0 - x_mn;
                    let y0 = path[k - 1].1 - y_mn;
                    for k in 0..len + 1 {
                        grid[(x0 + dx * k) as usize + (y0 + dy * k) as usize * width] = '#';
                    }
                }
            }

            (grid, width, ((500 - x_mn) as _, (0 - y_mn) as _))
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_12"><a class="anchor" href="#_star_1_12"></a><a class="link" href="#_star_1_12">Star 1</a></h5>
<div class="paragraph">
<p>Just let the sand flow in the grid until sand starts flowing off to the big void.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let (mut grid, width, (x_0, y_0)) = data.grid();
    let height = grid.len() / width;

    let mut cnt = 0;
    'inflow: loop {
        // first candidate is spot directly on top of something solid
        let mut x = x_0;
        let mut y = match (y_0..height).find(|y| grid[x + y * width] != '.') {
            Some(y) =&gt; y - 1,
            None =&gt; unreachable!("Nothing solid found to start with"),
        };

        loop {
            if y == height - 1 {
                // go to void below
                break 'inflow;
            }

            if grid[x + (y + 1) * width] == '.' {
                // bubble down
                y += 1;
            } else if x &gt; 0 &amp;&amp; grid[x - 1 + (y + 1) * width] == '.' {
                // bubble down-left
                y += 1;
                x -= 1;
            } else if x &lt; width - 1 &amp;&amp; grid[x + 1 + (y + 1) * width] == '.' {
                // bubble down-right
                y += 1;
                x += 1;
            } else if x == 0 || x == width - 1 {
                // go to void left/right
                break 'inflow;
            } else {
                grid[x + y * width] = 'o';
                cnt += 1;
                break;
            }
        }
    }

    cnt
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_12"><a class="anchor" href="#_star_2_12"></a><a class="link" href="#_star_2_12">Star 2</a></h5>
<div class="paragraph">
<p>Create a grid with an additional line added at the bottom and big enough to make sure nothing flows off to the void anymore. The only thing on top to do is to change the condition for exiting the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let (grid_0, width_0, (x_0_0, y_0)) = data.grid();
    let height_0 = grid_0.len() / width_0;

    // wrap the grid in a bigger grid (append height columns to the left and right and an additional row below)
    let width = width_0 + 2 * height_0;
    let height = height_0 + 1;
    let mut grid = vec!['.'; width * height];
    for y in 0..height_0 {
        for x in 0..width_0 {
            grid[x + height_0 + y * width] = grid_0[x + y * width_0];
        }
    }
    let x_0 = x_0_0 + height_0;

    let mut cnt = 0;
    loop {
        // first candidate is spot directly on top of something solid
        let mut x = x_0;
        let mut y = match (y_0..height).find(|y| grid[x + y * width] != '.') {
            Some(y) =&gt; {
                if y == y_0 {
                    // No more sand can enter
                    break;
                }
                y - 1
            }
            None =&gt; unreachable!("Nothing solid found to start with"),
        };

        loop {
            if y == height - 1 {
                // floor reached
                grid[x + y * width] = 'o';
                cnt += 1;
                break;
            }

            if grid[x + (y + 1) * width] == '.' {
                // bubble down
                y += 1;
            } else if x &gt; 0 &amp;&amp; grid[x - 1 + (y + 1) * width] == '.' {
                // bubble down-left
                y += 1;
                x -= 1;
            } else if x &lt; width - 1 &amp;&amp; grid[x + 1 + (y + 1) * width] == '.' {
                // bubble down-right
                y += 1;
                x += 1;
            } else if x == 0 || x == width - 1 {
                // the grid should not be too small
                unreachable!("Grid is too small!");
            } else {
                // cannot move any further
                grid[x + y * width] = 'o';
                cnt += 1;
                break;
            }
        }
    }

    cnt
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_15"><a class="anchor" href="#_tests_15"></a><a class="link" href="#_tests_15">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"498,4 -&gt; 498,6 -&gt; 496,6
503,4 -&gt; 502,4 -&gt; 502,9 -&gt; 494,9
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");

        let bbox = data.bbox();
        assert_eq!((494, 0, 504, 10), bbox);

        let (grid, width, (x0, y0)) = data.grid();
        assert_eq!((6, 0), (x0, y0));
        assert_eq!(10, width);
        let exp = "............................................#...##....#...#...###...#.........#.........#.#########.";
        assert_eq!(exp.chars().collect::&lt;Vec&lt;_&gt;&gt;(), grid);
        for row in 0..grid.len() / width {
            for col in 0..width {
                print!("{}", grid[col + row * width]);
            }
            println!();
        }
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(24, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(93, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day15" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_15_rust"><a class="anchor" href="#_day_15_rust"></a><a class="link" href="#_day_15_rust">Day 15: rust</a></h3>
<div class="sect3">
<h4 id="_day_15_beacon_exclusion_zone"><a class="anchor" href="#_day_15_beacon_exclusion_zone"></a><a class="link" href="#_day_15_beacon_exclusion_zone">Day 15: Beacon Exclusion Zone</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/15">AoC|2022|15</a>.</p>
</div>
<div class="paragraph">
<p>This one was a challenge for me. Part one was initially solved with brute force. My current solution projects ranges on the row to scan.</p>
</div>
<div class="paragraph">
<p>For part 2, brute force was not a real option.</p>
</div>
<div class="sect4">
<h5 id="_input_15"><a class="anchor" href="#_input_15"></a><a class="link" href="#_input_15">Input</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        sensors: Vec&lt;((isize, isize), (isize, isize))&gt;,
        pub row: isize,
        pub width: isize,
    }

    fn parse_line(l: &amp;str) -&gt; ((isize, isize), (isize, isize)) {
        let words = l.split_ascii_whitespace();
        let mut words = words.skip(2); // Sensor at

        let x_s = words.next().unwrap();
        let x_s = x_s.strip_prefix("x=").unwrap().strip_suffix(",").unwrap();
        let x_s = x_s.parse().unwrap();

        let y_s = words.next().unwrap();
        let y_s = y_s.strip_prefix("y=").unwrap().strip_suffix(":").unwrap();
        let y_s = y_s.parse().unwrap();

        let mut words = words.skip(4); // closest beacon is at

        let x_b = words.next().unwrap();
        let x_b = x_b.strip_prefix("x=").unwrap().strip_suffix(",").unwrap();
        let x_b = x_b.parse().unwrap();

        let y_b = words.next().unwrap();
        let y_b = y_b.strip_prefix("y=").unwrap();
        let y_b = y_b.parse().unwrap();

        ((x_s, y_s), (x_b, y_b))
    }

    impl From&lt;&amp;str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;str) -&gt; Self {
            Self {
                sensors: s.lines().map(parse_line).collect(),
                row: 2_000_000,
                width: 4_000_000,
            }
        }
    }

    impl PuzzleData {
        pub fn sensors(&amp;self) -&gt; &amp;[((isize, isize), (isize, isize))] {
            &amp;self.sensors
        }

        pub fn sensors_with_r(&amp;self) -&gt; Vec&lt;((isize, isize), isize)&gt; {
            self.sensors
                .iter()
                .map(|((x, y), (x_b, y_b))| ((*x, *y), (x - x_b).abs() + (y - y_b).abs()))
                .collect()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_13"><a class="anchor" href="#_star_1_13"></a><a class="link" href="#_star_1_13">Star 1</a></h5>
<div class="paragraph">
<p>Project ranges</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">/// determine ranges covered by sensors on given row
pub fn ranges(
    sensors: &amp;[((isize, isize), (isize, isize))],
    mn: isize,
    mx: isize,
    row: isize,
) -&gt; Vec&lt;(isize, isize)&gt; {
    sensors
        .iter()
        .map(|((x, y), (x_b, y_b))| (*x, (x - x_b).abs() + (y - y_b).abs() - (y - row).abs()))
        .map(|(x, d)| ((x - d).max(mn), (x + d).min(mx)))
        .filter(|(mn, mx)| mx &gt;= mn)
        .fold(Vec::new(), |mut ranges, range| {
            ranges.push(range);
            let mut k_2 = ranges.len() - 1;
            for k_1 in (0..ranges.len() - 1).rev() {
                if ranges[k_1].0 &lt;= ranges[k_2].0 &amp;&amp; ranges[k_1].1 &gt;= ranges[k_2].1 {
                    // k_2 contained in k_1
                    ranges.swap_remove(k_2);
                    break;
                } else if ranges[k_2].0 &lt;= ranges[k_1].0 &amp;&amp; ranges[k_2].1 &gt;= ranges[k_1].1 {
                    // k_1 contained in k_2
                    ranges.swap_remove(k_1);
                    k_2 = if k_2 == ranges.len() { k_1 } else { k_2 };
                } else if ranges[k_2].0 &gt;= ranges[k_1].0 &amp;&amp; ranges[k_2].0 &lt;= ranges[k_1].1 + 1 {
                    // k_2's min in k_1 or immediately after
                    ranges[k_1].1 = ranges[k_2].1;
                    ranges.swap_remove(k_2);
                    k_2 = k_1;
                } else if ranges[k_2].1 &gt;= ranges[k_1].0 - 1 &amp;&amp; ranges[k_2].1 &lt;= ranges[k_1].1 {
                    // k_2's max in k_1 or immediately before
                    ranges[k_1].0 = ranges[k_2].0;
                    ranges.swap_remove(k_2);
                    k_2 = k_1;
                }
            }
            ranges
        })
}

pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let ranges: Vec&lt;(isize, isize)&gt; = ranges(data.sensors(), isize::MIN, isize::MAX, data.row);
    let r = ranges
        .iter()
        .map(|(mn, mx)| (mx - mn + 1) as usize)
        .sum::&lt;usize&gt;();
    let s = data
        .sensors()
        .iter()
        .filter(|(_, (_, y))| *y == data.row)
        .map(|(_, b)| b)
        .collect::&lt;HashSet&lt;_&gt;&gt;()
        .len();
    r - s
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_13"><a class="anchor" href="#_star_2_13"></a><a class="link" href="#_star_2_13">Star 2</a></h5>
<div class="paragraph">
<p>The idea is that the position of the distress beacon must be just outside the range of at least two sensors. Hence, for all pairs of sensors, I find the points that are just outside of both sensor&#8217;s ranges as candidates. Out of these candidates, I search for a point that is also outside of all the other sensor&#8217;s ranges.</p>
</div>
<div class="paragraph">
<p>Well &#8230;&#8203; it works. But coming up with the formulas for the points was a pain and very error prone for me. I am sure there is something more elegant and simple.</p>
</div>
<div class="paragraph">
<p>There is also a flaw in the candidates function. Normally, it should be symmetric, i.e., <code>candidates(s1, s2) == candidates(s2, s1)</code>; it is not in all cases. I guess this is rounding issues &#8230;&#8203; It seems the function returns rather too many candidates than too few, which would not be an issue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn is_distress_beacon(
    sensors: &amp;[((isize, isize), isize)],
    p: &amp;(isize, isize),
    width: isize,
) -&gt; bool {
    (0..=width).contains(&amp;p.0)
        &amp;&amp; (0..=width).contains(&amp;p.1)
        &amp;&amp; sensors
            .iter()
            .all(|((x, y), r)| (x - p.0).abs() + (y - p.1).abs() &gt; *r)
}

pub fn candidates(
    (((x_1, y_1), r_1), ((x_2, y_2), r_2)): (&amp;((isize, isize), isize), &amp;((isize, isize), isize)),
) -&gt; HashSet&lt;(isize, isize)&gt; {
    let dx = x_2 - x_1;
    let dy = y_2 - y_1;
    let dr = r_2 - r_1;

    [
        // TL - RT
        // x1+(dx+dy-dr)/2,y1-r1-1+(dx+dy-dr)/2
        (
            x_1 + (dx + dy - dr + 1) / 2,
            y_1 - r_1 - 1 + (dx + dy - dr) / 2,
        ),
        (x_1 + (dx + dy - dr) / 2, y_1 - r_1 - 1 + (dx + dy - dr) / 2),
        // LB - BR
        // x1+(dx+dy+dr)/2,y1+r1+1+(dx+dy+dr)/2
        (
            x_1 + (dx + dy + dr - 1) / 2,
            y_1 + r_1 + 1 + (dx + dy + dr) / 2,
        ),
        (x_1 + (dx + dy + dr) / 2, y_1 + r_1 + 1 + (dx + dy + dr) / 2),
        // RT - TL
        // x1+(dx-dy+dr)/2,y1-r1-1-(dx-dy+dr)/2
        (
            x_1 + (dx - dy + dr - 1) / 2,
            y_1 - r_1 - 1 - (dx - dy + dr) / 2,
        ),
        (x_1 + (dx - dy + dr) / 2, y_1 - r_1 - 1 - (dx - dy + dr) / 2),
        // BR - LB
        // x1+(dx-dy-dr)/2,y1+r1+1-(dx-dy-dr)/2
        (
            x_1 + (dx - dy - dr + 1) / 2,
            y_1 + r_1 + 1 - (dx - dy - dr) / 2,
        ),
        (x_1 + (dx - dy - dr) / 2, y_1 + r_1 + 1 - (dx - dy - dr) / 2),
        // LB - TL
        // x1-r1-1+(dx+dy-dr)/2,y1+(dx+dy-dr)/2
        (
            x_1 - r_1 - 1 + (dx + dy - dr) / 2,
            y_1 + (dx + dy - dr + 1) / 2,
        ),
        (x_1 - r_1 - 1 + (dx + dy - dr) / 2, y_1 + (dx + dy - dr) / 2),
        // BR - RT
        // x1+r1+1+(dx-dy+dr)/2,y1-(dx-dy+dr)/2
        (
            x_1 + r_1 + 1 + (dx - dy + dr) / 2,
            y_1 - (dx - dy + dr - 1) / 2,
        ),
        (x_1 + r_1 + 1 + (dx - dy + dr) / 2, y_1 - (dx - dy + dr) / 2),
        // TL - LB
        // x1-r1-1+(dx-dy-dr)/2,y1-(dx-dy-dr)/2
        (
            x_1 - r_1 - 1 + (dx - dy - dr) / 2,
            y_1 - (dx - dy - dr + 1) / 2,
        ),
        (x_1 - r_1 - 1 + (dx - dy - dr) / 2, y_1 - (dx - dy - dr) / 2),
        // RT - BR
        // x2+r2+1+(dx+dy+dr)/2,y2+(dx+dy+dr)/2
        (
            x_1 + r_1 + 1 + (dx + dy + dr) / 2,
            y_1 + (dx + dy + dr - 1) / 2,
        ),
        (x_1 + r_1 + 1 + (dx + dy + dr) / 2, y_1 + (dx + dy + dr) / 2),
    ]
    .into_iter()
    .filter(|(x, y)| {
        (1..=2).contains(&amp;((x - x_1).abs() + (y - y_1).abs() - r_1))
            &amp;&amp; (1..=2).contains(&amp;((x - x_2).abs() + (y - y_2).abs() - r_2))
    })
    .collect()
}

fn star_2_geometry(data: &amp;PuzzleData) -&gt; usize {
    let sensors = data.sensors_with_r();
    let (x, y) = sensors
        .iter()
        .zip(sensors.iter().skip(1))
        .map(candidates)
        .map(HashSet::into_iter)
        .flatten()
        .find(|p| is_distress_beacon(&amp;sensors, p, data.width))
        .unwrap();

    (x * 4_000_000 + y) as _
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2scan_lines"><a class="anchor" href="#_star_2scan_lines"></a><a class="link" href="#_star_2scan_lines">Star 2&#8201;&#8212;&#8201;Scan Lines</a></h5>
<div class="paragraph">
<p>A solution using the functionality from star 1 is as follows. Much simpler code but much longer run-time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2_scan_lines(data: &amp;PuzzleData) -&gt; usize {
    let (y, ranges) = (0..data.width)
        .map(|row| (row, ranges(data.sensors(), 0, data.width, row)))
        .find(|(_, r)| r.len() == 2)
        .unwrap();

    let x = ranges[0].0.max(ranges[1].0) - 1;

    (x * 4_000_000 + y) as _
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_16"><a class="anchor" href="#_tests_16"></a><a class="link" href="#_tests_16">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"Sensor at x=2, y=18: closest beacon is at x=-2, y=15
Sensor at x=9, y=16: closest beacon is at x=10, y=16
Sensor at x=13, y=2: closest beacon is at x=15, y=3
Sensor at x=12, y=14: closest beacon is at x=10, y=16
Sensor at x=10, y=20: closest beacon is at x=10, y=16
Sensor at x=14, y=17: closest beacon is at x=10, y=16
Sensor at x=8, y=7: closest beacon is at x=2, y=10
Sensor at x=2, y=0: closest beacon is at x=2, y=10
Sensor at x=0, y=11: closest beacon is at x=2, y=10
Sensor at x=20, y=14: closest beacon is at x=25, y=17
Sensor at x=17, y=20: closest beacon is at x=21, y=22
Sensor at x=16, y=7: closest beacon is at x=15, y=3
Sensor at x=14, y=3: closest beacon is at x=15, y=3
Sensor at x=20, y=1: closest beacon is at x=15, y=3
"#;

    #[test]
    pub fn test_is_distress_beacon() {
        let data = PuzzleData::from(CONTENT);
        let sensors = data.sensors_with_r();
        assert!(is_distress_beacon(&amp;sensors, &amp;(14, 11), 20));
    }

    #[test]
    pub fn test_candidates() {
        // 0...#..%...
        // 1..#.#%.%..
        // 2.#.A%#B.%.
        // 3..#.#%.%..
        // 4...#..%...
        //  0123456789
        let s1 = ((3, 2), 2);
        let s2 = ((6, 2), 2);
        let e = HashSet::from([(4, 0), (5, 0), (4, 4), (5, 4)]);
        assert_eq!(
            e,
            candidates((&amp;s1, &amp;s2)).intersection(&amp;e).cloned().collect()
        );
        assert_eq!(
            e,
            candidates((&amp;s2, &amp;s1)).intersection(&amp;e).cloned().collect()
        );

        // 0...#...%..
        // 1..#.#.%.%.
        // 2.#.A.$.B.%
        // 3..#.#.%.%.
        // 4...#...%..
        //  0123456789
        //
        // RT: [x1 + r1 + 1 - k1, y1 - k1];
        // TL: [x2 - k2, y2 - r2 - 1 + k2];
        // [x1+(dx+dy-dr)/2,y1-r1-1+(dx+dy-dr)/2];
        // --- [x1+(dx-dy+dr)/2,y1-r1-1-(dx-dy+dr)/2];
        //
        // BR: [x1 + k1, y1 + r1 + 1 - k1];
        // LB: [x2 - r2 - 1 + k2, y2 + k2];
        // [x1+(dx-dy-dr)/2,y1+r1+1-(dx-dy-dr)/2];
        // --- [x1+(dx+dy+dr)/2,y1+r1+1+(dx+dy+dr)/2];
        let s1 = ((3, 2), 2);
        let s2 = ((7, 2), 2);
        let e = HashSet::from([(5, 1), (5, 3)]);
        assert_eq!(
            e,
            candidates((&amp;s1, &amp;s2)).intersection(&amp;e).cloned().collect()
        );
        assert_eq!(
            e,
            candidates((&amp;s2, &amp;s1)).intersection(&amp;e).cloned().collect()
        );

        // 0...#....
        // 1..#.#...
        // 2.#.A%#..
        // 3..#%#%..
        // 4..%#..%.
        // 5.%..B..%
        // 6..%...%.
        // 7...%.%..
        // 8....%...
        //  01234567
        // LB: [x1 - r1 - 1 + k1, y1 + k1];
        // TL: [x2 - k2, y2 - r2 - 1 + k2];
        // [x1-r1-1+(dx+dy-dr)/2,y1+(dx+dy-dr)/2]
        // --- [x1-r1-1+(dx-dy-dr)/2,y1-(dx-dy-dr)/2]
        let s1 = ((3, 2), 2);
        let s2 = ((4, 5), 3);
        let e = HashSet::from([(1, 3), (1, 4), (6, 2), (6, 3)]);
        assert_eq!(
            e,
            candidates((&amp;s1, &amp;s2)).intersection(&amp;e).cloned().collect()
        );
        assert_eq!(
            e,
            candidates((&amp;s2, &amp;s1)).intersection(&amp;e).cloned().collect()
        );

        // 0...#...
        // 1..#.#..
        // 2.#.A.#.
        // 3..#.#..
        // 4...$...
        // 5.-%.%..
        // 6.%.B.%.
        // 7..%.%..
        // 8...%...
        //  0123456
        let s1 = ((3, 2), 2);
        let s2 = ((3, 6), 2);
        let e = HashSet::from([(2, 4), (4, 4)]);
        assert_eq!(
            e,
            candidates((&amp;s1, &amp;s2)).intersection(&amp;e).cloned().collect()
        );
        assert_eq!(
            e,
            candidates((&amp;s2, &amp;s1)).intersection(&amp;e).cloned().collect()
        );
    }

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let mut data = PuzzleData::from(CONTENT);
        data.row = 10;
        assert_eq!(26, star_1(&amp;data));
    }

    #[test]
    pub fn test_solve_2() {
        let mut data = PuzzleData::from(CONTENT);
        data.width = 20;
        assert_eq!(56_000_011, star_2_geometry(&amp;data));
        assert_eq!(56_000_011, star_2_scan_lines(&amp;data));
        assert_eq!(56_000_011, star_2_brute_force(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day16" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_16_rust"><a class="anchor" href="#_day_16_rust"></a><a class="link" href="#_day_16_rust">Day 16: rust</a></h3>
<div class="sect3">
<h4 id="_day_16_proboscidea_volcanium"><a class="anchor" href="#_day_16_proboscidea_volcanium"></a><a class="link" href="#_day_16_proboscidea_volcanium">Day 16: Proboscidea Volcanium</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/16">AoC|2022|16</a>.</p>
</div>
<div class="paragraph">
<p>Today was a tough nut to crack for me.</p>
</div>
<div class="paragraph">
<p>My attempt is to use a path finding algorithm to explore the valve &amp; tunnel system.</p>
</div>
<div class="paragraph">
<p>The current state (node) is modeled by</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>potential</code>, i.e, the max pressure released until the timer is elapsed if all valves were opened in subsequent steps. If all valves are actually open, the potential is equal to the pressure released until the timer elapses (the volcano erupts)</p>
</li>
<li>
<p>the <code>pressure</code> released</p>
</li>
<li>
<p>the <code>flow</code> of all currently opened valves</p>
</li>
<li>
<p>the <code>idx</code> (position) of the agents opening valves (just me for part 1 and me + an elephant for part 2)</p>
<div class="ulist">
<ul>
<li>
<p>Actually, for part two, the two agents exploring the valve &amp; tunnel system are interchangeable, so I transform to an elephant from time to time</p>
</li>
</ul>
</div>
</li>
<li>
<p>the <code>opened</code> valves</p>
</li>
<li>
<p>the <code>timer</code> (counting down to zero)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I use a priority queue which yields the state with the highest <code>potential</code> first. This results in the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a state is expanded, it is guaranteed that all adjacent states have at most the same potential. They will have equal potential if and only if all valves with positive flow are open. In all other cases, they will have lower potential.</p>
</li>
<li>
<p>If a state is popped from the queue, all states popped later on will have at most the same potential.</p>
</li>
<li>
<p>The potential of the first state popped from the queue with all valves open is the max. possible pressure.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The key is to figure out how to narrow down the search space without eliding relevant states. I tried several ideas and do not quite understand why those are not working:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is a possibility to open a valve, open it and discard possibilities to move on without opening the valve&#8201;&#8212;&#8201;worked for the real data but not for the examples.</p>
</li>
<li>
<p>If a state is expanded with position and opened valves identical to a state seen previously, skip it&#8201;&#8212;&#8201;worked for the real data but not for the examples.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Eventually, I finished with a variant of the second option: If a state is expanded with position and opened valves identical to a state seen previously, skip it unless it has higher potential than the state seen previously (kind of 'decrease key').</p>
</div>
<div class="sect4">
<h5 id="_input_16"><a class="anchor" href="#_input_16"></a><a class="link" href="#_input_16">Input</a></h5>
<div class="paragraph">
<p>I parse the input into a vec of valves. Each valve has its tunnels stored as vec of indices to that list for cheap lookups.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData&lt;'a&gt; {
        valves: Vec&lt;Valve&lt;'a&gt;&gt;,
        root: usize,
    }

    fn parse_line(line: &amp;str) -&gt; (&amp;str, Vec&lt;&amp;str&gt;, usize) {
        let mut words = line.split_ascii_whitespace().skip(1);

        let name = words.next().unwrap();

        let mut words = words.skip(2);

        let flow = words.next().unwrap();
        let flow = flow[5..flow.len() - 1].parse().unwrap();

        let tunnels = words
            .skip(4)
            .map(|word| word.trim_end_matches(','))
            .collect();

        (name, tunnels, flow)
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData&lt;'a&gt; {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            let lines = s.lines().map(parse_line).collect::&lt;Vec&lt;_&gt;&gt;();
            let valves = lines
                .iter()
                .enumerate()
                .map(|(idx, (name, tunnels, flow))| Valve {
                    name,
                    idx,
                    flow: *flow,
                    tunnels: tunnels
                        .iter()
                        .map(|&amp;tunnel| {
                            lines
                                .iter()
                                .position(|&amp;(name, _, _)| name == tunnel)
                                .unwrap()
                        })
                        .collect(),
                })
                .collect();
            let root = lines.iter().position(|&amp;(name, _, _)| name == "AA").unwrap();
            Self { valves, root }
        }
    }

    impl&lt;'a&gt; PuzzleData&lt;'a&gt; {
        pub fn get(&amp;self, idx: usize) -&gt; &amp;Valve {
            &amp;self.valves[idx]
        }

        pub fn root(&amp;self) -&gt; &amp;Valve {
            &amp;self.valves[self.root]
        }

        pub fn valves(&amp;self) -&gt; &amp;[Valve] {
            &amp;self.valves
        }
    }

    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Valve&lt;'a&gt; {
        pub idx: usize,
        pub name: &amp;'a str,
        pub flow: usize,
        pub tunnels: Vec&lt;usize&gt;,
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_14"><a class="anchor" href="#_star_1_14"></a><a class="link" href="#_star_1_14">Star 1</a></h5>
<div class="paragraph">
<p>Solution with a single agent (me).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    // search state
    // - pressure potential
    // - pressure
    // - flow (valves opened so far)
    // - idx (position)
    // - opened (valves opened so far)
    // - timer (time left before eruption)
    #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct State {
        potential: usize,
        pressure: usize,
        flow: usize,
        idx: usize,
        opened: u64,
        timer: usize,
    }

    impl State {
        fn create(
            pressure: usize,
            flow: usize,
            idx: usize,
            opened: u64,
            timer: usize,
            data: &amp;PuzzleData,
            max_flow: usize,
        ) -&gt; Self {
            let mut potential = pressure;
            let mut flow_ = 0;
            if timer &gt;= 1 {
                // in next step, pressure will be increased by flow
                flow_ += flow;
                potential += flow_;
            }
            if timer &gt;= 2 {
                // in the 2nd step, pressure will at most be increased by flow
                // of current valve. If it is not opened in the next step
                // (agent moves instead), the flow will not change
                if opened &amp; 1 &lt;&lt; idx == 0 {
                    flow_ += data.get(idx).flow;
                }
                potential += flow_;

                // upper bound for subsequent steps: all valves open
                potential += (timer - 2) * max_flow;
            }

            Self {
                potential,
                pressure,
                flow,
                idx,
                opened,
                timer,
            }
        }
    }

    // all valves opened / max flow
    let (all_opened, max_flow) = data
        .valves()
        .iter()
        .filter(|v| v.flow &gt; 0)
        .fold((0, 0), |(o, f), v| (o | 1 &lt;&lt; v.idx, f + v.flow));

    // max time
    let timer: usize = 30;

    // start at root, no valves open
    let start = State::create(0, 0, data.root().idx, 0, timer, data, max_flow);

    // the queue for searching
    let mut queue = BinaryHeap::new();
    queue.push(start);

    // do not visit the same spot with the same opened valves again
    let mut seen = HashMap::from([((start.idx, start.opened), max_flow * timer)]);

    while let Some(s) = queue.pop() {
        // do not explore further if timer elapsed or all valves open,
        // just see if there is something better in the queue
        if s.timer == 0 || s.opened == all_opened {
            return s.potential;
        }

        let v = data.get(s.idx);

        let can_o = (s.opened &amp; 1 &lt;&lt; v.idx) == 0 &amp;&amp; v.flow &gt; 0;

        for (o, adj) in once((true, v))
            .chain(v.tunnels.iter().map(|&amp;idx| (false, data.get(idx))))
            .filter(|&amp;(o, _)| !o || can_o)
        {
            let opened = s.opened | if o { 1 &lt;&lt; adj.idx } else { 0 };
            let flow = s.flow + if o { adj.flow } else { 0 };
            let next = State::create(
                s.pressure + s.flow,
                flow,
                adj.idx,
                opened,
                s.timer - 1,
                data,
                max_flow,
            );
            let v = seen.entry((next.idx, next.opened)).or_insert(0);
            if next.potential.gt(v) {
                *v = next.potential;
                queue.push(next);
            }
        }
    }

    unreachable!();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_14"><a class="anchor" href="#_star_2_14"></a><a class="link" href="#_star_2_14">Star 2</a></h5>
<div class="paragraph">
<p>Same solution with two agents (me + elephant), not really anything new compared to star 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    // search state
    // - pressure potential
    // - pressure
    // - flow (valves opened so far)
    // - idx (positions, sorted)
    // - opened (valves opened so far)
    // - timer (time left before eruption)
    #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    struct State {
        potential: usize,
        pressure: usize,
        flow: usize,
        idx: [usize; 2],
        opened: u64,
        timer: usize,
    }

    impl State {
        fn create(
            pressure: usize,
            flow: usize,
            idx: [usize; 2],
            opened: u64,
            timer: usize,
            data: &amp;PuzzleData,
            max_flow: usize,
        ) -&gt; Self {
            let mut potential = pressure;
            let mut flow_ = 0;
            if timer &gt;= 1 {
                // in next step, pressure will be increased by flow
                flow_ += flow;
                potential += flow_;
            }
            if timer &gt;= 2 {
                // in the 2nd step, pressure will at most be increased by flow
                // of current valves. If they are not opened in the next step
                // (agents move instead), the flow will not change
                for idx_ in idx {
                    if opened &amp; 1 &lt;&lt; idx_ == 0 {
                        flow_ += data.get(idx_).flow;
                    }
                }
                potential += flow_;

                // upper bound for subsequent steps: all valves open
                potential += (timer - 2) * max_flow;
            }

            Self {
                potential,
                pressure,
                flow,
                idx,
                opened,
                timer,
            }
        }
    }

    // all valves opened / max flow
    let (all_opened, max_flow) = data
        .valves()
        .iter()
        .filter(|v| v.flow &gt; 0)
        .fold((0, 0), |(o, f), v| (o | 1 &lt;&lt; v.idx, f + v.flow));

    // max time
    let timer: usize = 26;

    // start at root, no valves open
    let start = State::create(0, 0, [data.root().idx; 2], 0, timer, data, max_flow);

    // the queue for searching
    let mut queue = BinaryHeap::new();
    queue.push(start);

    // do not visit the same spot with the same opened valves again
    let mut seen = HashMap::from([((start.idx, start.opened), start.potential)]);

    while let Some(s) = queue.pop() {
        // do not explore further if timer elapsed or all valves open,
        // just see if there is something better in the queue
        if s.timer == 0 || s.opened == all_opened {
            return s.potential;
        }

        let v_1 = data.get(s.idx[0]);
        let v_2 = data.get(s.idx[1]);

        let can_o_1 = (s.opened &amp; 1 &lt;&lt; v_1.idx) == 0 &amp;&amp; v_1.flow &gt; 0;
        let can_o_2 = v_1.idx != v_2.idx &amp;&amp; (s.opened &amp; 1 &lt;&lt; v_2.idx) == 0 &amp;&amp; v_2.flow &gt; 0;

        for (o_1, adj_1) in once((true, v_1))
            .chain(v_1.tunnels.iter().map(|&amp;idx| (false, data.get(idx))))
            .filter(|&amp;(o, _)| !o || can_o_1)
        {
            for (o_2, adj_2) in once((true, v_2))
                .chain(v_2.tunnels.iter().map(|&amp;idx| (false, data.get(idx))))
                .filter(|&amp;(o, _)| !o || can_o_2)
            {
                let opened = s.opened
                    | if o_1 { 1 &lt;&lt; adj_1.idx } else { 0 }
                    | if o_2 { 1 &lt;&lt; adj_2.idx } else { 0 };
                let flow =
                    s.flow + if o_1 { adj_1.flow } else { 0 } + if o_2 { adj_2.flow } else { 0 };
                let next = State::create(
                    s.pressure + s.flow,
                    flow,
                    [adj_1.idx.min(adj_2.idx), adj_1.idx.max(adj_2.idx)],
                    opened,
                    s.timer - 1,
                    data,
                    max_flow,
                );
                let v = seen.entry((next.idx, next.opened)).or_insert(0);
                if next.potential.gt(v) {
                    *v = next.potential;
                    queue.push(next);
                }
            }
        }
    }

    unreachable!();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_17"><a class="anchor" href="#_tests_17"></a><a class="link" href="#_tests_17">Tests</a></h5>
<div class="paragraph">
<p>One additional test to see whether my calculations come up with the correct result but following the path defined in the puzzle for part 2. They do ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use std::collections::{HashMap, HashSet};

    use super::*;

    const CONTENT: &amp;str = r#"Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        let root = data.root();
        assert_eq!("AA", root.name);
        assert_eq!(
            vec!["DD", "II", "BB"],
            root.tunnels
                .iter()
                .map(|&amp;idx| data.get(idx).name)
                .collect::&lt;Vec&lt;_&gt;&gt;()
        );
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(1_651, star_1(&amp;data));
    }

    #[test]
    pub fn test_example() {
        let data = PuzzleData::from(CONTENT);
        let map = data
            .valves()
            .iter()
            .map(|v| (v.name, v.idx))
            .collect::&lt;HashMap&lt;_, _&gt;&gt;();

        let steps = [
            (1, false, "DD"),
            (2, true, "DD"),
            (3, false, "CC"),
            (4, false, "BB"),
            (5, true, "BB"),
            (6, false, "AA"),
            (7, false, "II"),
            (8, false, "JJ"),
            (9, true, "JJ"),
            (10, false, "II"),
            (11, false, "AA"),
            (12, false, "DD"),
            (13, false, "EE"),
            (14, false, "FF"),
            (15, false, "GG"),
            (16, false, "HH"),
            (17, true, "HH"),
            (18, false, "GG"),
            (19, false, "FF"),
            (20, false, "EE"),
            (21, true, "EE"),
            (22, false, "DD"),
            (23, false, "CC"),
            (24, true, "CC"),
        ];

        let max_flow: usize = data.valves().iter().map(|v| v.flow).sum();
        let timer = 30;

        #[derive(Debug)]
        struct State {
            potential: usize,
            pressure: usize,
            flow: usize,
            idx: usize,
            opened: u64,
            timer: usize,
        }

        let mut s = State {
            potential: timer * max_flow,
            pressure: 0,
            flow: 0,
            idx: *map.get("AA").unwrap(),
            opened: 0,
            timer: timer,
        };

        let mut seen = HashSet::new();
        seen.insert((s.idx, s.opened));

        for (minute, open, valve) in steps {
            let idx = *map.get(valve).unwrap();
            let v = data.get(idx);
            assert!(idx == s.idx || !open);
            assert!(open || data.get(s.idx).tunnels.contains(&amp;idx));
            s = State {
                potential: s.pressure + s.flow + (s.timer - 1) * max_flow,
                pressure: s.pressure + s.flow,
                flow: if open { s.flow + v.flow } else { s.flow },
                idx: v.idx,
                opened: if open { s.opened | 1 &lt;&lt; idx } else { s.opened },
                timer: s.timer - 1,
            };
            assert!(seen.insert((s.idx, s.opened)));
            println!(
                "{minute}, {} {valve}, open valves: {:?} ({s:?})",
                if open { "opened" } else { "moved to" },
                data.valves()
                    .iter()
                    .filter(|v| (s.opened &amp; 1 &lt;&lt; v.idx) &gt; 0)
                    .map(|v| v.name)
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            );
        }
        println!(
            "{} + {} * {} = {}, {}",
            s.pressure,
            s.timer,
            s.flow,
            s.pressure + s.timer * s.flow,
            s.potential
        );

        assert_eq!(1_651, s.potential);
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(1_707, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day17" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_17_rust"><a class="anchor" href="#_day_17_rust"></a><a class="link" href="#_day_17_rust">Day 17: rust</a></h3>
<div class="sect3">
<h4 id="_day_17_pyroclastic_flow"><a class="anchor" href="#_day_17_pyroclastic_flow"></a><a class="link" href="#_day_17_pyroclastic_flow">Day 17: Pyroclastic Flow</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/17">AoC|2022|17</a>.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s play <a href="https://de.wikipedia.org/wiki/Tetris">Tetris</a> ;)</p>
</div>
<div class="paragraph">
<p>Because I made stupid bugs, I spent lots of time displaying the chamber and figuring out what I did wrong. My biggest mistake was to overwrite occupied space by empty space when a rock comes to rest and is not filling a full rectangle. Unfortunately, with this bug, I still get the correct result for the example data.</p>
</div>
<div class="paragraph">
<p>Part 2 is about finding a pattern that repeats itself. I do that by looking at the top 30 rows. The number 30 is kind of arbitrarily chosen.</p>
</div>
<div class="sect4">
<h5 id="_input_17"><a class="anchor" href="#_input_17"></a><a class="link" href="#_input_17">Input</a></h5>
<div class="paragraph">
<p>I just read the input in a byte array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData&lt;'a&gt; {
        jets: &amp;'a [u8],
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData&lt;'a&gt; {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            Self {
                jets: s.trim().as_bytes(),
            }
        }
    }

    impl&lt;'a&gt; PuzzleData&lt;'a&gt; {
        pub fn jets(&amp;self) -&gt; &amp;'a [u8] {
            &amp;self.jets
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_general_solution"><a class="anchor" href="#_general_solution"></a><a class="link" href="#_general_solution">General solution</a></h5>
<div class="paragraph">
<p>I have a struct <code>Chamber</code> with a method <code>integrate_rock</code>. This takes a rock and let&#8217;s it move in the chamber until it comes to rest.</p>
</div>
<div class="paragraph">
<p>My first version did not have the <code>.filter(|&amp;k| rock[k] == b'#')</code> part in the update chamber loop at the end of the <code>integrate_rock</code> function. I typed these 29 characters with an average speed of about 12 character / hour.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct Chamber&lt;'a&gt; {
    chamber: Vec&lt;u8&gt;,
    jets: RingBuffer&lt;'a, u8&gt;,
    rocks: RingBuffer&lt;'static, (&amp;'static str, usize)&gt;,
}

impl&lt;'a&gt; From&lt;&amp;PuzzleData&lt;'a&gt;&gt; for Chamber&lt;'a&gt; {
    fn from(data: &amp;PuzzleData&lt;'a&gt;) -&gt; Self {
        Self {
            chamber: Vec::new(),
            jets: data.jets().into(),
            rocks: Self::ROCKS.into(),
        }
    }
}

impl Chamber&lt;'_&gt; {
    const WIDTH: usize = 7;
    const ROCKS: &amp;'static [(&amp;'static str, usize)] = &amp;[
        ("####", 4),
        (".#.###.#.", 3),
        ("###..#..#", 3),
        ("####", 1),
        ("####", 2),
    ];
    const X0: usize = 2;
    const DY0: usize = 3;

    pub fn check(&amp;self, rock: &amp;[u8], x: usize, y: usize, w: usize) -&gt; bool {
        (0..rock.len())
            .filter(|&amp;k| rock[k] == b'#')
            .filter(|k| y + k / w &lt; self.height())
            .all(|k| self.chamber[x + k % w + (y + k / w) * Self::WIDTH] == b'.')
    }

    pub fn height(&amp;self) -&gt; usize {
        self.chamber.len() / Self::WIDTH
    }

    pub fn top(&amp;self, rows: usize) -&gt; (Vec&lt;u8&gt;, usize, usize) {
        (
            self.chamber[self.chamber.len() - rows * Self::WIDTH..].to_vec(),
            self.rocks.pos(),
            self.jets.pos(),
        )
    }

    pub fn integrate_rock&lt;F&gt;(&amp;mut self, f: F)
    where
        F: Fn(&amp;[u8], &amp;[u8], usize, usize, usize),
    {
        let &amp;(rock, w) = self.rocks.next();
        let rock = rock.as_bytes();

        let mut x = Self::X0;
        let mut y = self.height() + Self::DY0;

        let mut stop = false;

        while !stop {
            f(&amp;self.chamber, &amp;rock, x, y, w);
            let &amp;jet = self.jets.next();
            x = if jet == b'&lt;' &amp;&amp; x &gt; 0 &amp;&amp; self.check(rock, x - 1, y, w) {
                x - 1
            } else if jet == b'&gt;' &amp;&amp; x + w &lt; Chamber::WIDTH &amp;&amp; self.check(rock, x + 1, y, w) {
                x + 1
            } else {
                x
            };

            if y == 0 {
                stop = true;
            } else if y &lt;= self.height() {
                if self.check(rock, x, y - 1, w) {
                    y -= 1;
                } else {
                    stop = true;
                }
            } else {
                y -= 1;
            }

            if stop {
                // add new lines to chamber
                while self.height() &lt; y + rock.len() / w {
                    self.chamber.extend([b'.'; Self::WIDTH])
                }
                // update chamber
                for k in (0..rock.len()).filter(|&amp;k| rock[k] == b'#') {
                    self.chamber[x + k % w + (y + k / w) * Self::WIDTH] = rock[k];
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_15"><a class="anchor" href="#_star_1_15"></a><a class="link" href="#_star_1_15">Star 1</a></h5>
<div class="paragraph">
<p>Just integrate 2022 rocks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let mut chamber = Chamber::from(data);

    for _ in 0..2022 {
        chamber.integrate_rock(|_, _, _, _, _| ());
    }

    chamber.height()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_15"><a class="anchor" href="#_star_2_15"></a><a class="link" href="#_star_2_15">Star 2</a></h5>
<div class="paragraph">
<p>Integrate rocks until a situation as defined by top rows of chamber, current jet position, current rock repeats. Calculate how much hight we gain by repeating this full cycle as often as it fits in the required number of rocks to integrate and simulate the remaining steps.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let mut chamber = Chamber::from(data);

    let mut seen = HashMap::new();
    let rows = 30; // this is somehow arbitrary

    let rounds: usize = 1_000_000_000_000;

    let mut cnt = 0;
    while chamber.height() &lt; rows {
        chamber.integrate_rock(|_, _, _, _, _| ());
        cnt += 1;
    }

    for cur in cnt..rounds {
        if let Some((prev, prev_height)) = seen.insert(chamber.top(rows), (cur, chamber.height())) {
            let d_round = cur - prev;
            let d_height = chamber.height() - prev_height;

            let n = (rounds - cur) / d_round;
            let h = n * d_height;

            let rem = (rounds - cur) % d_round;
            for _ in 0..rem {
                chamber.integrate_rock(|_, _, _, _, _| ());
            }

            return chamber.height() + h;
        }
        chamber.integrate_rock(|_, _, _, _, _| ());
    }

    unreachable!()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_18"><a class="anchor" href="#_tests_18"></a><a class="link" href="#_tests_18">Tests</a></h5>
<div class="paragraph">
<p>Tests did not help a lot today.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"&gt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&lt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&gt;"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(3_068, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(1_514_285_714_288, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>My testing approach was to print various configurations using <strong>very nice</strong> printing code. Obviously, I removed all the <code>println!</code> and <code>if debug {}</code> statements before I publish my code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub struct RockInChamber&lt;'a, 'b&gt; {
    pub chamber: &amp;'a [u8],
    pub rock: &amp;'b [u8],
    pub x: usize,
    pub y: usize,
    pub w: usize,
    pub rock_part: usize,
    pub print_lim: usize,
}

impl Default for RockInChamber&lt;'_, '_&gt; {
    fn default() -&gt; Self {
        Self {
            chamber: &amp;[],
            rock: &amp;[],
            x: 0,
            y: 0,
            w: 1,
            rock_part: 8,
            print_lim: 17,
        }
    }
}

impl std::fmt::Display for RockInChamber&lt;'_, '_&gt; {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        let h = self.chamber.len() / Chamber::WIDTH;
        let y_mx = h + self.rock_part;
        let y_mn = 0.max(h - self.print_lim.min(h));
        for y_ in (y_mn..y_mx).rev() {
            '|'.fmt(f)?;
            for x_ in 0..Chamber::WIDTH {
                if x_ &gt;= self.x
                    &amp;&amp; x_ &lt; self.x + self.w
                    &amp;&amp; y_ &gt;= self.y
                    &amp;&amp; y_ &lt; self.y + self.rock.len() / self.w
                    &amp;&amp; self.rock[x_ - self.x + (y_ - self.y) * self.w] == b'#'
                {
                    '@'.fmt(f)?;
                } else if y_ &lt; h {
                    (self.chamber[x_ + y_ * Chamber::WIDTH] as char).fmt(f)?;
                } else {
                    '.'.fmt(f)?;
                }
            }
            "|\n".fmt(f)?;
        }
        if y_mn == 0 {
            '+'.fmt(f)?;
            for _ in 0..Chamber::WIDTH {
                '-'.fmt(f)?;
            }
            "+".fmt(f)?;
        } else {
            "|~y=".fmt(f)?;
            (y_mn - 1).fmt(f)?;
            "~".fmt(f)?;
        }
        Ok(())
    }
}

impl std::fmt::Display for Chamber&lt;'_&gt; {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        RockInChamber {
            chamber: &amp;self.chamber,
            ..RockInChamber::default()
        }
        .fmt(f)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_animation"><a class="anchor" href="#_animation"></a><a class="link" href="#_animation">Animation</a></h5>
<div class="paragraph">
<p>Just for fun, I created an example with a little animation (simulates 2022 rocks using the example data). Run with <code>cargo run --release --example animate&#8201;&#8212;&#8201;&lt;ms&gt;</code> where <code>&lt;ms&gt;</code> is the amount of ms to sleep after each animation step, defaults to <code>40</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">fn main() {
    // accept a single numeric argumnet
    let arg = env::args().skip(1).next();
    let wait = arg
        .map(|arg| arg.parse().expect("a positive amount of ms to pause"))
        .unwrap_or(40);

    let mut chamber = Chamber::from(&amp;CONTENT.into());
    for k in 0..2022 {
        chamber.integrate_rock(|chamber, rock, x, y, w| {
            print!("\x1B[1;1H\x1B[J"); // clear console
            println!(
                "{}",
                RockInChamber {
                    chamber,
                    rock,
                    x,
                    y,
                    w,
                    ..RockInChamber::default()
                }
            );
            println!("Rock {}", k + 1);
            thread::sleep(Duration::from_millis(wait));
        });
    }
}</code></pre>
</div>
</div>
<a id="day18" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_18_rust"><a class="anchor" href="#_day_18_rust"></a><a class="link" href="#_day_18_rust">Day 18: rust</a></h3>
<div class="sect3">
<h4 id="_day_18_boiling_boulders"><a class="anchor" href="#_day_18_boiling_boulders"></a><a class="link" href="#_day_18_boiling_boulders">Day 18: Boiling Boulders</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/18">AoC|2022|18</a>.</p>
</div>
<div class="sect4">
<h5 id="_input_18"><a class="anchor" href="#_input_18"></a><a class="link" href="#_input_18">Input</a></h5>
<div class="paragraph">
<p>Parse the input in a vec of 3D coordinates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        cubes: Vec&lt;(isize, isize, isize)&gt;,
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            Self {
                cubes: s
                    .lines()
                    .map(|line| line.split(','))
                    .map(|mut split| {
                        (
                            split.next().unwrap().parse().unwrap(),
                            split.next().unwrap().parse().unwrap(),
                            split.next().unwrap().parse().unwrap(),
                        )
                    })
                    .collect(),
            }
        }
    }

    impl&lt;'a&gt; PuzzleData {
        pub fn cubes(&amp;self) -&gt; &amp;[(isize, isize, isize)] {
            &amp;self.cubes
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_16"><a class="anchor" href="#_star_1_16"></a><a class="link" href="#_star_1_16">Star 1</a></h5>
<div class="paragraph">
<p>I use bits of bytes to store whether a side of a cube is touching a side of another cube. I start with all bits set to 1 and set them to zero by looking at all pairs of cubes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1_pairwise_comp(data: &amp;PuzzleData) -&gt; usize {
    let cubes = data.cubes();

    let mut sides = vec![0b111111u8; cubes.len()];

    for k1 in 0..cubes.len() - 1 {
        let (x_1, y_1, z_1) = cubes[k1];
        for k2 in k1 + 1..cubes.len() {
            let (x_2, y_2, z_2) = cubes[k2];
            if x_1 == x_2 + 1 &amp;&amp; y_1 == y_2 &amp;&amp; z_1 == z_2 {
                sides[k1] &amp;= !(1 &lt;&lt; 0);
                sides[k2] &amp;= !(1 &lt;&lt; 1);
            } else if x_1 == x_2 - 1 &amp;&amp; y_1 == y_2 &amp;&amp; z_1 == z_2 {
                sides[k1] &amp;= !(1 &lt;&lt; 1);
                sides[k2] &amp;= !(1 &lt;&lt; 0);
            } else if x_1 == x_2 &amp;&amp; y_1 == y_2 + 1 &amp;&amp; z_1 == z_2 {
                sides[k1] &amp;= !(1 &lt;&lt; 2);
                sides[k2] &amp;= !(1 &lt;&lt; 3);
            } else if x_1 == x_2 &amp;&amp; y_1 == y_2 - 1 &amp;&amp; z_1 == z_2 {
                sides[k1] &amp;= !(1 &lt;&lt; 3);
                sides[k2] &amp;= !(1 &lt;&lt; 2);
            } else if x_1 == x_2 &amp;&amp; y_1 == y_2 &amp;&amp; z_1 == z_2 + 1 {
                sides[k1] &amp;= !(1 &lt;&lt; 4);
                sides[k2] &amp;= !(1 &lt;&lt; 5);
            } else if x_1 == x_2 &amp;&amp; y_1 == y_2 &amp;&amp; z_1 == z_2 - 1 {
                sides[k1] &amp;= !(1 &lt;&lt; 5);
                sides[k2] &amp;= !(1 &lt;&lt; 4);
            }
        }
    }

    sides.iter().map(|s| s.count_ones() as usize).sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_16"><a class="anchor" href="#_star_2_16"></a><a class="link" href="#_star_2_16">Star 2</a></h5>
<div class="paragraph">
<p>The approach for part 2 is totally different from the approach for part 1.</p>
</div>
<div class="paragraph">
<p>I calculate the bounding box containing all cubes of a droplet and do a breadth first traversal starting from all 8 corners of the bounding box (enlarged by one in each direction) at the same time. The traversal will not exit this enlarged bounding box.</p>
</div>
<div class="paragraph">
<p>Whenever the traversal hits a cube contained in the droplet, there is exactly on side facing outwards to be added to the count.</p>
</div>
<div class="paragraph">
<p>Interestingly, the solution for the second part is calculated faster than the solution for the first part in my case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    let ((x_mn, y_mn, z_mn), (x_mx, y_mx, z_mx)) = data.cubes().iter().fold(
        (
            (isize::MAX, isize::MAX, isize::MAX),
            (isize::MIN, isize::MIN, isize::MIN),
        ),
        |(mn, mx), c| {
            (
                (mn.0.min(c.0 - 1), mn.1.min(c.1 - 1), mn.2.min(c.2 - 1)),
                (mx.0.max(c.0 + 1), mx.1.max(c.1 + 1), mx.2.max(c.2 + 1)),
            )
        },
    );

    let droplet: HashSet&lt;(isize, isize, isize)&gt; = HashSet::from_iter(data.cubes().iter().cloned());

    let mut queue = VecDeque::new();
    for x in [x_mn, x_mx] {
        for y in [y_mn, y_mx] {
            for z in [z_mn, z_mx] {
                queue.push_back((x, y, z));
            }
        }
    }

    let mut seen: HashSet&lt;(isize, isize, isize)&gt; = HashSet::from_iter(queue.iter().cloned());

    let mut sides = 0;

    while let Some((x, y, z)) = queue.pop_front() {
        for a in [
            (x + 1, y, z),
            (x - 1, y, z),
            (x, y + 1, z),
            (x, y - 1, z),
            (x, y, z + 1),
            (x, y, z - 1),
        ]
        .into_iter()
        .filter(|&amp;(x, y, z)| {
            x &gt;= x_mn &amp;&amp; y &gt;= y_mn &amp;&amp; z &gt;= z_mn &amp;&amp; x &lt;= x_mx &amp;&amp; y &lt;= y_mx &amp;&amp; z &lt;= z_mx
        }) {
            if droplet.contains(&amp;a) {
                sides += 1;
            } else if seen.insert(a) {
                queue.push_back(a);
            }
        }
    }

    sides
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_variant"><a class="anchor" href="#_star_1_variant"></a><a class="link" href="#_star_1_variant">Star 1 variant</a></h5>
<div class="paragraph">
<p>After part 2 was done, I re-created a solution for part 1 based on the same idea.</p>
</div>
<div class="paragraph">
<p>This time, I do a breadth first traversal inside the droplet. Since the droplet is not necessarily connected, I need to wrap everything in an additional loop until all cubes are processed. To do so, I replace the <code>seen</code> set (which is initially empty) by a <code>remain</code> set, which initially contains all cubes, and from which I remove all cubes that are processed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1_traversal(data: &amp;PuzzleData) -&gt; usize {
    let droplet: HashSet&lt;(isize, isize, isize)&gt; = HashSet::from_iter(data.cubes().iter().cloned());

    let mut sides = 0;

    let mut queue = VecDeque::new();
    let mut remain = droplet.clone();
    while !remain.is_empty() {
        let &amp;start = remain.iter().next().unwrap();
        remain.remove(&amp;start);

        queue.push_back(start);

        while let Some((x, y, z)) = queue.pop_front() {
            for a in [
                (x + 1, y, z),
                (x - 1, y, z),
                (x, y + 1, z),
                (x, y - 1, z),
                (x, y, z + 1),
                (x, y, z - 1),
            ] {
                if remain.remove(&amp;a) {
                    // cube in droplet and not yet seen
                    queue.push_back(a);
                } else if !droplet.contains(&amp;a) {
                    // cube which is direct adjacent is not contained
                    sides += 1;
                }
            }
        }
    }

    sides
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_19"><a class="anchor" href="#_tests_19"></a><a class="link" href="#_tests_19">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"2,2,2
1,2,2
3,2,2
2,1,2
2,3,2
2,2,1
2,2,3
2,2,4
2,2,6
1,2,5
3,2,5
2,1,5
2,3,5
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(13, data.cubes().len());
        assert_eq!((2, 1, 2), data.cubes()[3]);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(64, star_1_pairwise_comp(&amp;data));
        assert_eq!(64, star_1_traversal(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(58, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day19" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_19_rust"><a class="anchor" href="#_day_19_rust"></a><a class="link" href="#_day_19_rust">Day 19: rust</a></h3>
<div class="sect3">
<h4 id="_day_19_not_enough_minerals"><a class="anchor" href="#_day_19_not_enough_minerals"></a><a class="link" href="#_day_19_not_enough_minerals">Day 19: Not Enough Minerals</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/19">AoC|2022|19</a>.</p>
</div>
<div class="paragraph">
<p>I was basically poking in the fog and brute forcing the solution.</p>
</div>
<div class="paragraph">
<p>After I had a working solution, I looked for help in the <a href="https://www.reddit.com/r/adventofcode/comments/zpihwi/2022_day_19_solutions/">reddit solution megathread</a> and re-worked my solution.</p>
</div>
<div class="paragraph">
<p>There are three main elements that lead to acceptable solution time:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Do not simulate every minute but rather decide which robot to build next and simulate as many minutes as required to build that robot at once</p>
</li>
<li>
<p>Understand that only one robot can be made per minute, which implies that there is no point in having more Ore, Clay or Obsidian collecting robots than the maximum Ore, Clay or Obsidian required to produce a single robot of any kind</p>
</li>
<li>
<p>Do a depth first search to have terminal states quickly and discard all branches for which an upper bound can be calculated which is below the current optimum (this is kind of an A* idea)</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_input_19"><a class="anchor" href="#_input_19"></a><a class="link" href="#_input_19">Input</a></h5>
<div class="paragraph">
<p>I parse the blueprints into a vec containing the amount of Ore, Clay and Obsidian required to build any of the Ore collecting, Clay collecting, Obsidian collecting or Geode opening robots. This results in many 0&#8217;s but makes the implementation of the search algorithm much easier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use crate::{CLAY, GEODE, OBSIDIAN, ORE};

    #[derive(Debug)]
    pub struct PuzzleData {
        pub blueprints: Vec&lt;[usize; 12]&gt;,
    }

    fn parse_blueprint(line: &amp;str) -&gt; [usize; 12] {
        let mut blueprint = [0; 12];

        let mut words = line.split_ascii_whitespace().skip(6); // blueprint &lt;id&gt;: each ore robot costs
        blueprint[ORE + 3 * ORE] = words.next().unwrap().parse().unwrap(); // XX: ore for ore robot
        let mut words = words.skip(5); // ore. each clay robot costs
        blueprint[ORE + 3 * CLAY] = words.next().unwrap().parse().unwrap(); // XX: ore for clay robot
        let mut words = words.skip(5); // ore. each obsidian robot costs
        blueprint[ORE + 3 * OBSIDIAN] = words.next().unwrap().parse().unwrap(); // XX: ore for obsidian robot
        let mut words = words.skip(2); // ore and
        blueprint[CLAY + 3 * OBSIDIAN] = words.next().unwrap().parse().unwrap(); // XX: clay for obsidian robot
        let mut words = words.skip(5); // clay. each geode robot costs
        blueprint[ORE + 3 * GEODE] = words.next().unwrap().parse().unwrap(); // XX: ore for geode robot
        let mut words = words.skip(2); // ore and
        blueprint[OBSIDIAN + 3 * GEODE] = words.next().unwrap().parse().unwrap(); // XX: obsidian for geode robot
        assert_eq!(Some("obsidian."), words.next());
        assert_eq!(None, words.next());

        blueprint
    }

    impl From&lt;&amp;str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;str) -&gt; Self {
            Self {
                blueprints: s.lines().map(parse_blueprint).collect(),
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_17"><a class="anchor" href="#_star_1_17"></a><a class="link" href="#_star_1_17">Star 1</a></h5>
<div class="paragraph">
<p>My depth-first search implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn max_geodes(blueprint: &amp;[usize], steps: usize) -&gt; usize {
    // start with one ore robot, zero material and steps to go
    let start = ([1usize, 0, 0, 0], [0; 4], steps);

    // initialize queue
    let mut queue = Vec::from([start]);

    // maximum required amount of robots per type
    let max_req = (ORE..=OBSIDIAN).fold([usize::MAX; 4], |mut max_req, m| {
        max_req[m] = (ORE..=GEODE).map(|r| blueprint[m + 3 * r]).max().unwrap();
        max_req
    });

    // optimum
    let mut opt: usize = 0;

    while let Some((robots, materials, steps)) = queue.pop() {
        // update optimum, including geodes opened in remaining steps
        opt = opt.max(materials[GEODE] + robots[GEODE] * steps);

        // time elapsed
        if steps == 0 {
            continue;
        }

        // if geodes opened by making a geode robot in every subsequent step does not lead to
        // an improvement, stop here
        if (0..steps).fold(materials[GEODE], |bound, step| {
            bound + (robots[GEODE] + step) * (steps - step)
        }) &lt; opt
        {
            continue;
        }

        for r in (ORE..=GEODE).rev().filter(|&amp;r| robots[r] &lt; max_req[r]) {
            // calculate steps required to build robot
            let Some(s) = (ORE..=OBSIDIAN)
                .map(|m| {
                    if materials[m] &gt;= blueprint[m + 3 * r] {
                        Some(0)
                    } else if robots[m] == 0 {
                        None
                    } else {
                        Some((blueprint[m + 3 * r] - materials[m] + robots[m] - 1) / robots[m])
                    }
                })
                .fold(Some(0), |s_max, s| match (s_max, s) {
                    (Some(s_max), Some(s)) =&gt; Some(s_max.max(s)),
                    _ =&gt; None,
                }) else {
                    // can't build robot
                    continue
                };

            if s + 1 &gt; steps {
                // time elapsed
                continue;
            }

            // update robots and materials
            let mut materials = materials;
            for m in ORE..=OBSIDIAN {
                materials[m] += (s + 1) * robots[m];
                materials[m] -= blueprint[m + 3 * r];
            }
            materials[GEODE] += (s + 1) * robots[GEODE];
            let mut robots = robots;
            robots[r] += 1;

            // push to queue
            queue.push((robots, materials, steps - s - 1));
        }
    }

    opt
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is used for part 1 as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    data.blueprints
        .iter()
        .map(|blueprint| max_geodes(blueprint, 24))
        .enumerate()
        .map(|(k, opt)| (k + 1) * opt)
        .sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_17"><a class="anchor" href="#_star_2_17"></a><a class="link" href="#_star_2_17">Star 2</a></h5>
<div class="paragraph">
<p>The same solution works for part 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; usize {
    data.blueprints
        .iter()
        .take(3)
        .map(|blueprint| max_geodes(blueprint, 32))
        .product()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_20"><a class="anchor" href="#_tests_20"></a><a class="link" href="#_tests_20">Tests</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 2 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 2 ore and 7 obsidian.
Blueprint 2: Each ore robot costs 2 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 8 clay. Each geode robot costs 3 ore and 12 obsidian.
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(9 * 1 + 12 * 2, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(56 * 62, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_today_i_learned_8"><a class="anchor" href="#_today_i_learned_8"></a><a class="link" href="#_today_i_learned_8">Today I learned</a></h5>
<div class="paragraph">
<p>Brute force sometimes works but it is no fun, and there is a lot to learn on how to solve these kind of problems &#8230;&#8203;</p>
</div>
<a id="day20" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_20_rust"><a class="anchor" href="#_day_20_rust"></a><a class="link" href="#_day_20_rust">Day 20: rust</a></h3>
<div class="sect3">
<h4 id="_day_20_grove_positioning_system"><a class="anchor" href="#_day_20_grove_positioning_system"></a><a class="link" href="#_day_20_grove_positioning_system">Day 20: Grove Positioning System</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/20">AoC|2022|20</a>.</p>
</div>
<div class="paragraph">
<p>Looked simple but was more tricky than expected.</p>
</div>
<div class="paragraph">
<p>The example data turned out to be too <em>friendly</em> for me.</p>
</div>
<div class="sect4">
<h5 id="_input_20"><a class="anchor" href="#_input_20"></a><a class="link" href="#_input_20">Input</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug)]
    pub struct PuzzleData {
        pub numbers: Vec&lt;isize&gt;,
    }

    impl From&lt;&amp;str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;str) -&gt; Self {
            Self {
                numbers: s.trim().lines().map(|l| l.parse().unwrap()).collect(),
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_general_solution_2"><a class="anchor" href="#_general_solution_2"></a><a class="link" href="#_general_solution_2">General Solution</a></h5>
<div class="paragraph">
<p>I decided to store the data in a kind of doubly linked list. I implemented this by creating a list of indices to the predecessor and successor of each number. The numbers themselves are stored in a vec which is unchanged all the time (this is useful since we need to process along the initial order of the numbers)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn mix(numbers: &amp;[isize], times: usize) -&gt; isize {
    let n = numbers.len();
    let mut indices = (0..n)
        .map(|k| ((k + n - 1) % n, (k + 1) % n))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    let k0 = numbers.iter().position(|&amp;v| v == 0).unwrap();

    for _ in 0..times {
        for k in 0..n {
            mix_step(&amp;mut indices, numbers, k);
        }
    }

    let k1 = (0..1000).fold(k0, |k, _| indices[k].1);
    let k2 = (0..1000).fold(k1, |k, _| indices[k].1);
    let k3 = (0..1000).fold(k2, |k, _| indices[k].1);

    numbers[k1] + numbers[k2] + numbers[k3]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key is to perform a single mix step correctly. I failed to do so in all possible ways. To be able to test this properly, I put it into a separate function and created my own test cases for it (see below).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn mix_step(indices: &amp;mut Vec&lt;(usize, usize)&gt;, numbers: &amp;[isize], k: usize) {
    let v = numbers[k];
    let steps = v % (numbers.len() as isize - 1);

    // move in direction of lower number of steps
    let steps = if steps &gt; (numbers.len() as isize - 1) / 2 {
        steps - (numbers.len() as isize - 1)
    } else if steps &lt; -(numbers.len() as isize - 1) / 2 {
        steps + (numbers.len() as isize - 1)
    } else {
        steps
    };

    if steps != 0 {
        if steps &gt; 0 {
            // k_pre k k_post .. idx idx_post =&gt; k_pre k_post .. idx k idx_post
            let idx = (0..steps).fold(k, |k, _| indices[k].1);
            let (k_pre, k_post) = indices[k];
            let (_, idx_post) = indices[idx];
            indices[k_post].0 = k_pre;
            indices[k_pre].1 = k_post;
            indices[k] = (idx, idx_post);
            indices[idx].1 = k;
            indices[idx_post].0 = k;
        } else {
            // idx_pre idx .. k_pre k k_post =&gt; idx_pre k idx .. k_pre k_post
            let idx = (steps..0).fold(k, |k, _| indices[k].0);
            let (k_pre, k_post) = indices[k];
            let (idx_pre, _) = indices[idx];
            indices[k_post].0 = k_pre;
            indices[k_pre].1 = k_post;
            indices[k] = (idx_pre, idx);
            indices[idx].0 = k;
            indices[idx_pre].1 = k;
        };
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_18"><a class="anchor" href="#_star_1_18"></a><a class="link" href="#_star_1_18">Star 1</a></h5>
<div class="paragraph">
<p>Just call the mix function with <code>times = 1</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_18"><a class="anchor" href="#_star_2_18"></a><a class="link" href="#_star_2_18">Star 2</a></h5>
<div class="paragraph">
<p>Call the mix function with numbers multiplied by the decryption key and <code>times = 10</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_2(data: &amp;PuzzleData) -&gt; isize {
    mix(
        &amp;data
            .numbers
            .iter()
            .map(|v| v * 811_589_153)
            .collect::&lt;Vec&lt;_&gt;&gt;(),
        10,
    )
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_21"><a class="anchor" href="#_tests_21"></a><a class="link" href="#_tests_21">Tests</a></h5>
<div class="paragraph">
<p>The most difficult part today: create <code>test_mix_step</code> and make it pass.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use std::collections::HashSet;

    use super::*;

    const CONTENT: &amp;str = r#"1
2
-3
3
-2
0
4
"#;

    #[test]
    pub fn test_mix_step() {
        let n = 21;
        let numbers: &amp;[isize] = &amp;[
            0,
            -1,
            -2,
            1,
            2,
            n - 2,
            n - 1,
            n,
            2 * n - 4,
            2 * n - 3,
            2 * n - 2,
            2 * n - 1,
            2 * n,
            -n - 1,
            -n,
            -n + 1,
            -2 * n - 3,
            -2 * n - 2,
            -2 * n - 1,
            -2 * n,
            -2 * n + 1,
        ];

        println!(
            "{:?}",
            numbers
                .iter()
                .map(|v| (v, v % (n - 1), v.rem_euclid(n - 1)))
                .collect::&lt;Vec&lt;_&gt;&gt;()
        );

        let exp = vec![
            (-2 * n + 1, -1),       // 0
            (-2 * n + 1, 0),        // -1
            (-2 * n + 1, 0),        // -2
            (2, n - 2),             // 1
            (n - 1, n),             // 2
            (1, 2),                 // n - 2 = 19
            (n - 2, n),             // n - 1 = 20
            (2 * n - 4, 2 * n - 3), // n = 21
            (n - 2, n - 1),         // 2 n - 4 = 38
            (n, 2 * n - 4),         // 2 n - 3 = 39
            (2 * n - 3, 2 * n - 1), // 2 n - 2 = 40
            (2 * n, -n - 1),        // 2 n - 1 = 41
            (-n, -n + 1),           // 2 n = 42
            (2 * n - 2, 2 * n - 1), // -n-1 = -22
            (2 * n, -n - 1),        // -n = -21
            (-n, -2 * n - 3),       // -n+1 = -20
        ];
        let n = n as usize;

        let to_vec = |indices: &amp;Vec&lt;(usize, usize)&gt;| {
            (0..n)
                .scan(0, |k, _| {
                    let v = numbers[*k];
                    *k = indices[*k].1;
                    Some(v)
                })
                .collect::&lt;Vec&lt;isize&gt;&gt;()
        };

        let indices = (0..n)
            .map(|k| ((k + n - 1) % n, (k + 1) % n))
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(numbers, to_vec(&amp;indices));

        for k in 0..n {
            let mut indices = (0..n)
                .map(|k| ((k + n - 1) % n, (k + 1) % n))
                .collect::&lt;Vec&lt;_&gt;&gt;();
            mix_step(&amp;mut indices, numbers, k);
            println!("numbers[{k}] = {} =&gt; {:?}", numbers[k], to_vec(&amp;indices));

            if k &lt; exp.len() {
                assert_eq!(
                    exp[k],
                    (numbers[indices[k].0], numbers[indices[k].1]),
                    "at k = {k}"
                );
            }

            let mut k_fwd = 0;
            let mut k_rev = 0;
            let mut fwds = HashSet::from([0]);
            let mut revs = HashSet::from([0]);
            for _ in 0..n {
                k_fwd = indices[k_fwd].1;
                k_rev = indices[k_rev].1;
                fwds.insert(k_fwd);
                revs.insert(k_rev);
            }
            // full cycle in both directions
            assert_eq!(
                0, k_fwd,
                "incomplete forward cycle\nk: {k}\n numbers: {numbers:?}\n indices: {indices:?}"
            );
            assert_eq!(
                0, k_rev,
                "incomplete backwards cycle\nk: {k}\n numbers: {numbers:?}\n indices: {indices:?}"
            );
            assert_eq!(
                n,
                fwds.len(),
                "items not in forward cycle\nk: {k}\n numbers: {numbers:?}\n indices: {indices:?}"
            );
            assert_eq!(
                n,
                revs.len(),
                "items not in backwards cycle\nk: {k}\n numbers: {numbers:?}\n indices: {indices:?}"
            );
        }
    }

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(3, mix(&amp;data.numbers, 1));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(1_623_178_306, star_2(&amp;data));
    }
}</code></pre>
</div>
</div>
<a id="day21" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_21_rust"><a class="anchor" href="#_day_21_rust"></a><a class="link" href="#_day_21_rust">Day 21: rust</a></h3>
<div class="sect3">
<h4 id="_day_21_todo"><a class="anchor" href="#_day_21_todo"></a><a class="link" href="#_day_21_todo">Day 21: <em>TODO</em></a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/21">AoC|2022|21</a>.</p>
</div>
<div class="paragraph">
<p>Primary school math today&#8230;&#8203;</p>
</div>
<div class="sect4">
<h5 id="_input_21"><a class="anchor" href="#_input_21"></a><a class="link" href="#_input_21">Input</a></h5>
<div class="paragraph">
<p>I parse the input into a map with monkey names as keys and <code>Yell</code> enums as values. A <code>Yell</code> is either a <code>Number</code> or an <code>Operation</code> referencing other monkey by name. The <code>Unknown</code> variant is required for star 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    use std::collections::HashMap;

    #[derive(Debug, Clone)]
    pub enum Yell&lt;'a&gt; {
        Operation(&amp;'a str, &amp;'a str, &amp;'a str),
        Number(isize),
        Unknown, // required for part 2
    }

    pub fn parse_yell&lt;'a&gt;(line: &amp;'a str) -&gt; (&amp;'a str, Yell&lt;'a&gt;) {
        let mut words = line.split_ascii_whitespace();
        let name = words.next().unwrap().trim_end_matches(':');
        let word = words.next().unwrap();
        let yell = if (word.as_bytes()[0] as char).is_ascii_digit() {
            Yell::Number(word.parse().unwrap())
        } else {
            Yell::Operation(word, words.next().unwrap(), words.next().unwrap())
        };
        (name, yell)
    }

    #[derive(Debug)]
    pub struct PuzzleData&lt;'a&gt; {
        pub monkeys: HashMap&lt;&amp;'a str, Yell&lt;'a&gt;&gt;,
    }

    impl&lt;'a&gt; From&lt;&amp;'a str&gt; for PuzzleData&lt;'a&gt; {
        /// parse the puzzle input
        fn from(s: &amp;'a str) -&gt; Self {
            Self {
                monkeys: s.lines().map(parse_yell).collect(),
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_19"><a class="anchor" href="#_star_1_19"></a><a class="link" href="#_star_1_19">Star 1</a></h5>
<div class="paragraph">
<p>This is a trivial recursive <code>get_result</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; isize {
    get_result(&amp;data.monkeys, "root")
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_19"><a class="anchor" href="#_star_2_19"></a><a class="link" href="#_star_2_19">Star 2</a></h5>
<div class="paragraph">
<p>For the second part, I update the map so that the value for key <code>"humn"</code> is <code>Unknown</code> and the operation for key <code>"root"</code> is <code>-</code>, so that I can solve the root value for <code>0</code>.</p>
</div>
<div class="paragraph">
<p>I put the yells in a recursive tree enum <code>YellRec</code> reducing branches of the tree that do not contain <code>Unknown</code> on the fly with a <code>reduce</code> function.</p>
</div>
<div class="paragraph">
<p>Then I solve for the <code>Unknown</code> inverting operations one by one. This works if the <code>Unknown</code> appears in exactly one of the right hand side or left hand side arguments, which is the case for my input (and I guess for every one else&#8217;s input as well) and for the example data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[derive(Debug)]
pub enum YellRec&lt;'a&gt; {
    Operation(Box&lt;(YellRec&lt;'a&gt;, &amp;'a str, YellRec&lt;'a&gt;)&gt;),
    Number(isize),
    Unknown,
}

pub fn reduce&lt;'a&gt;(monkeys: &amp;HashMap&lt;&amp;str, Yell&lt;'a&gt;&gt;, monkey: &amp;str) -&gt; YellRec&lt;'a&gt; {
    match monkeys.get(monkey) {
        Some(Yell::Operation(lhs, op, rhs)) =&gt; {
            let lhs = reduce(monkeys, lhs);
            let rhs = reduce(monkeys, rhs);
            match (lhs, rhs) {
                (YellRec::Number(lhs), YellRec::Number(rhs)) =&gt; match *op {
                    "+" =&gt; YellRec::Number(lhs + rhs),
                    "-" =&gt; YellRec::Number(lhs - rhs),
                    "*" =&gt; YellRec::Number(lhs * rhs),
                    "/" =&gt; YellRec::Number(lhs / rhs),
                    _ =&gt; panic!("Unknown operation: {op}"),
                },
                (lhs, rhs) =&gt; YellRec::Operation((lhs, *op, rhs).into()),
            }
        }
        Some(Yell::Number(v)) =&gt; YellRec::Number(*v),
        Some(Yell::Unknown) =&gt; YellRec::Unknown,
        yell =&gt; panic!("Can't get result for monkey {monkey} =&gt; {yell:?}"),
    }
}

pub fn solve(yell: &amp;YellRec, tar: isize) -&gt; isize {
    match yell {
        YellRec::Operation(b) =&gt; match b.as_ref() {
            (lhs, op, YellRec::Number(rhs)) =&gt; match *op {
                "+" =&gt; solve(lhs, tar - *rhs), // lhs + rhs = tar
                "-" =&gt; solve(lhs, tar + *rhs), // lhs - rhs = tar
                "*" =&gt; solve(lhs, tar / *rhs), // lhs * rhs = tar
                "/" =&gt; solve(lhs, tar * *rhs), // lhs / rhs = tar
                _ =&gt; panic!("Unknown operation: {op}"),
            },
            (YellRec::Number(lhs), op, rhs) =&gt; match *op {
                "+" =&gt; solve(rhs, tar - *lhs), // lhs + rhs = tar
                "-" =&gt; solve(rhs, *lhs - tar), // lhs - rhs = tar
                "*" =&gt; solve(rhs, tar / *lhs), // lhs * rhs = tar
                "/" =&gt; solve(rhs, *lhs / tar), // lhs / rhs = tar
                _ =&gt; panic!("Unknown operation: {op}"),
            },
            _ =&gt; panic!("solve expects either rhs or lhs to be a number"),
        },
        YellRec::Unknown =&gt; tar,
        YellRec::Number(_) =&gt; panic!("Can't solve a number"),
    }
}

pub fn star_2(data: &amp;PuzzleData) -&gt; isize {
    let mut monkeys = data.monkeys.clone();

    let Some(Yell::Operation(lhs, _, rhs)) = monkeys.get("root") else {panic!()};
    monkeys.insert("root", Yell::Operation(lhs, "-", rhs));
    monkeys.insert("humn", Yell::Unknown);

    solve(&amp;reduce(&amp;monkeys, "root"), 0)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_22"><a class="anchor" href="#_tests_22"></a><a class="link" href="#_tests_22">Tests</a></h5>
<div class="paragraph">
<p>I only created tests today, because my template contains them. I actually did not use them before submitting the result&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"root: pppw + sjmn
dbpl: 5
cczh: sllz + lgvd
zczc: 2
ptdq: humn - dvpt
dvpt: 3
lfqf: 4
humn: 5
ljgn: 2
sjmn: drzm * dbpl
sllz: 4
pppw: cczh / lfqf
lgvd: ljgn * ptdq
drzm: hmdt - zczc
hmdt: 32
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(152, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(301, star_2(&amp;data));
    }

    #[test]
    pub fn test_solution_range() {
        let data = PuzzleData::from(include_str!("../input.txt"));

        let sol_a = star_2(&amp;data);
        let sol_b = star_2_bisection(&amp;data);

        let sol_rg = sol_a.min(sol_b)..=sol_a.max(sol_b);
        println!("Solution range: {sol_rg:?}");


        let mut monkeys = data.monkeys.clone();
        let Some(Yell::Operation(lhs, _, rhs)) = monkeys.get("root") else {panic!()};
        monkeys.insert("root", Yell::Operation(lhs, "-", rhs));

        for sol in sol_rg {
            monkeys.insert("humn", Yell::Number(sol));
            assert_eq!(0, get_result(&amp;monkeys, "root"));
        }
    }
}</code></pre>
</div>
</div>
<a id="day22" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_22_rust"><a class="anchor" href="#_day_22_rust"></a><a class="link" href="#_day_22_rust">Day 22: rust</a></h3>
<div class="sect3">
<h4 id="_day_22_monkey_map"><a class="anchor" href="#_day_22_monkey_map"></a><a class="link" href="#_day_22_monkey_map">Day 22: Monkey Map</a></h4>
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2022/day/22">AoC|2022|22</a>.</p>
</div>
<div class="paragraph">
<p>Geometry! Cube layouts &#8230;&#8203; what looked simple turned out to be very tedious</p>
</div>
<div class="sect4">
<h5 id="_input_22"><a class="anchor" href="#_input_22"></a><a class="link" href="#_input_22">Input</a></h5>
<div class="paragraph">
<p>Nothing special here today. I decided to make the lines of the grid equal length (padded with spaced) for easier processing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub mod input {
    #[derive(Debug, PartialEq, Eq)]
    pub enum Step {
        Fwd(usize),
        Left,
        Right,
    }

    #[derive(Debug)]
    pub struct PuzzleData {
        pub grid: Vec&lt;u8&gt;,
        pub width: usize,
        pub steps: Vec&lt;Step&gt;,
    }

    impl From&lt;&amp;str&gt; for PuzzleData {
        /// parse the puzzle input
        fn from(s: &amp;str) -&gt; Self {
            let (grid_part, steps_part) = s.split_once("\n\n").unwrap();

            // store the grid with rows of equal width
            let lines = grid_part.lines().collect::&lt;Vec&lt;_&gt;&gt;();
            let width = lines.iter().map(|line| line.len()).max().unwrap();
            let mut grid = vec![b' '; width * lines.len()];
            for row in 0..lines.len() {
                for (col, b) in lines[row].as_bytes().iter().enumerate() {
                    grid[col + row * width] = *b;
                }
            }

            let mut steps = Vec::new();
            let mut fwd = 0;
            for b in steps_part.trim().as_bytes() {
                if (b'0'..=b'9').contains(b) {
                    fwd = 10 * fwd + (b - b'0') as usize;
                } else {
                    if fwd != 0 {
                        steps.push(Step::Fwd(fwd));
                        fwd = 0;
                    }
                    if *b == b'L' {
                        steps.push(Step::Left);
                    } else if *b == b'R' {
                        steps.push(Step::Right);
                    } else {
                        panic!("Unexpected {} in {steps_part}", *b as char);
                    }
                }
            }
            if fwd != 0 {
                steps.push(Step::Fwd(fwd));
            }

            Self { grid, width, steps }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_1_20"><a class="anchor" href="#_star_1_20"></a><a class="link" href="#_star_1_20">Star 1</a></h5>
<div class="paragraph">
<p>I used an iterator to move forward. Looks much nicer that for loops ;)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub fn star_1(data: &amp;PuzzleData) -&gt; usize {
    let mut col = data.grid.iter().position(|&amp;b| b == b'.').unwrap();
    let mut row = 0;
    let mut d: usize = 0;
    let height = data.grid.len() / data.width;

    for step in &amp;data.steps {
        match step {
            Step::Fwd(fwd) =&gt; {
                let (d_col, d_row, n) = match d {
                    0 =&gt; (1, 0, data.width),
                    1 =&gt; (0, 1, height),
                    2 =&gt; (data.width - 1, 0, data.width),
                    3 =&gt; (0, height - 1, height),
                    _ =&gt; unreachable!(),
                };
                (col, row) = (0..n)
                    .cycle()
                    .map(|s| ((col + s * d_col) % data.width, (row + s * d_row) % height))
                    .filter(|(col, row)| data.grid[col + data.width * row] != b' ')
                    .take(fwd + 1)
                    .take_while(|(col, row)| data.grid[col + row * data.width] != b'#')
                    .last()
                    .unwrap();
            }
            Step::Left =&gt; d = (d + 3) % 4,
            Step::Right =&gt; d = (d + 1) % 4,
        }
    }

    (row + 1) * 1000 + (col + 1) * 4 + d
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_2_20"><a class="anchor" href="#_star_2_20"></a><a class="link" href="#_star_2_20">Star 2</a></h5>
<div class="paragraph">
<p>I did not see the cubes come when working on part 1.</p>
</div>
<div class="paragraph">
<p>This turned out to be much more complicated than what I first thought.</p>
</div>
<div class="paragraph">
<p>There is quite a bit of repetition in my code which multiplies the opportunities for mistakes. I used a lot of the opportunities and made a lot of them. And I had no efficient way for debugging. Which branch of the code is actually used, depends a lot on the cube layout. Since this is different for the example and the real data, the example was not good enough to fix all the issues.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">pub const EAST: usize = 0; // [1 0 0]
pub const NORTH: usize = 1; // [0 1 0]
pub const UP: usize = 2; // [0 0 1]
pub const WEST: usize = 3; // [-1 0 0]
pub const SOUTH: usize = 4; // [0 -1 0]
pub const DOWN: usize = 5; // [0 0 -1]

pub const HEAD_RIGHT: usize = 0;
pub const HEAD_DOWN: usize = 1;
pub const HEAD_LEFT: usize = 2;
pub const HEAD_UP: usize = 3;

pub fn star_2(data: &amp;PuzzleData, face_width: usize) -&gt; usize {
    let layout_w = data.width / face_width;
    let layout_h = (data.grid.len() / data.width) / face_width;
    assert_eq!(
        layout_w * face_width * layout_h * face_width,
        data.grid.len(),
        "Grid len does not match layout"
    );

    // get the cube layout (each face is represented by a '#')
    let cube_layout = (0..data.grid.len() / (face_width * face_width))
        .map(|p| (p % layout_w, p / layout_w))
        .map(|(c, r)| {
            if data.grid[c * face_width + r * face_width * data.width] == b' ' {
                ' '
            } else {
                '#'
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // compile a map of cube faces with the normal direction as key and
    // ((col, row), (n_dir, x_dir, y_dir)) as value where (col, row) is the
    // position in the grid and (n_dir, x_dir, y_dir) is normal direction
    // and direction of x- and y- respectively
    let pos: usize = cube_layout.iter().position(|&amp;face| face == '#').unwrap();
    let start = ((pos % layout_w, pos / layout_w), (UP, EAST, SOUTH));
    let mut faces = HashMap::from([(UP, start)]);
    let mut queue = VecDeque::from([start]);
    while let Some(((col, row), (n_dir, x_dir, y_dir))) = queue.pop_front() {
        if col &gt; 0 &amp;&amp; cube_layout[col - 1 + row * layout_w] == '#' {
            let next = ((col - 1, row), ((x_dir + 3) % 6, n_dir, y_dir));
            if !faces.contains_key(&amp;next.1 .0) {
                faces.insert(next.1 .0, next);
                queue.push_back(next);
            }
        }
        if col &lt; layout_w - 1 &amp;&amp; cube_layout[col + 1 + row * layout_w] == '#' {
            let next = ((col + 1, row), (x_dir, (n_dir + 3) % 6, y_dir));
            if !faces.contains_key(&amp;next.1 .0) {
                faces.insert(next.1 .0, next);
                queue.push_back(next);
            }
        }
        if row &gt; 0 &amp;&amp; cube_layout[col + (row - 1) * layout_w] == '#' {
            let next = ((col, row - 1), ((y_dir + 3) % 6, x_dir, n_dir));
            if !faces.contains_key(&amp;next.1 .0) {
                faces.insert(next.1 .0, next);
                queue.push_back(next);
            }
        }
        if row &lt; layout_h - 1 &amp;&amp; cube_layout[col + (row + 1) * layout_w] == '#' {
            let next = ((col, row + 1), (y_dir, x_dir, (n_dir + 3) % 6));
            if !faces.contains_key(&amp;next.1 .0) {
                faces.insert(next.1 .0, next);
                queue.push_back(next);
            }
        }
    }

    // current position is given by (x, y) within face and (col, row) of face
    // in addition normal direction and x-/y-direction of current face and
    // the current orientation `d`
    let pos = data.grid.iter().position(|&amp;b| b == b'.').unwrap();
    let mut x = pos % face_width;
    let mut y = 0;
    let mut col = pos / face_width;
    let mut row = 0;
    let (_, (mut n_dir, mut x_dir, mut y_dir)) = faces.get(&amp;UP).unwrap();
    let mut d: usize = 0;

    #[cfg(feature = "print-path")]
    let mut path: HashMap&lt;usize, usize&gt; = HashMap::from([(pos, d)]);

    for step in &amp;data.steps {
        match step {
            Step::Fwd(fwd) =&gt; {
                for _ in 0..*fwd {
                    // determine x and y updates (wrapping)
                    // and normal direction of next face (if wrapping)
                    let (x_upd, y_upd, n_dir_upd) = match d {
                        HEAD_RIGHT =&gt; (
                            (x + 1) % face_width,
                            y,
                            if x &lt; face_width - 1 { n_dir } else { x_dir },
                        ),
                        HEAD_DOWN =&gt; (
                            x,
                            (y + 1) % face_width,
                            if y &lt; face_width - 1 { n_dir } else { y_dir },
                        ),
                        HEAD_LEFT =&gt; (
                            (x + face_width - 1) % face_width,
                            y,
                            if x &gt; 0 { n_dir } else { (x_dir + 3) % 6 },
                        ),
                        HEAD_UP =&gt; (
                            x,
                            (y + face_width - 1) % face_width,
                            if y &gt; 0 { n_dir } else { (y_dir + 3) % 6 },
                        ),
                        _ =&gt; unreachable!(),
                    };

                    let (x_upd, y_upd, d_upd, col_upd, row_upd, x_dir_upd, y_dir_upd) = if n_dir_upd
                        != n_dir
                    {
                        // calculate update on a new face
                        // get face
                        let ((col_upd, row_upd), (n_dir_upd, x_dir_upd, y_dir_upd)) =
                            *faces.get(&amp;n_dir_upd).unwrap();

                        // do the transformation
                        let (x_upd, y_upd, d_upd) = if n_dir_upd == x_dir {
                            // move right
                            if y_dir_upd == y_dir &amp;&amp; x_dir_upd == (n_dir + 3) % 6 {
                                (0, y, HEAD_RIGHT)
                            } else if y_dir_upd == (y_dir + 3) % 6 &amp;&amp; x_dir_upd == n_dir {
                                (face_width - 1, face_width - 1 - y, HEAD_LEFT)
                            } else if x_dir_upd == y_dir &amp;&amp; y_dir_upd == n_dir {
                                (y, face_width - 1, HEAD_UP)
                            } else if x_dir_upd == (y_dir + 3) % 6 &amp;&amp; y_dir_upd == (n_dir + 3) % 6 {
                                (face_width - 1 - y, 0, HEAD_DOWN)
                            } else {
                                unreachable!(
                                    "right: {}, _{}_, {} --&gt; _{}_, {}, {}",
                                    n_dir, x_dir, y_dir, n_dir_upd, x_dir_upd, y_dir_upd
                                )
                            }
                        } else if n_dir_upd == (x_dir + 3) % 6 {
                            // move left
                            if y_dir_upd == y_dir &amp;&amp; x_dir_upd == n_dir {
                                (face_width - 1, y, HEAD_LEFT)
                            } else if y_dir_upd == (y_dir + 3) % 6 &amp;&amp; x_dir_upd == (n_dir + 3) % 6 {
                                (0, face_width - 1 - y, HEAD_RIGHT)
                            } else if x_dir_upd == y_dir &amp;&amp; y_dir_upd == (n_dir + 3) % 6 {
                                (y, 0, HEAD_DOWN)
                            } else if x_dir_upd == (y_dir + 3) % 6 &amp;&amp; y_dir_upd == n_dir {
                                (face_width - 1 - y, face_width - 1, HEAD_UP)
                            } else {
                                unreachable!(
                                    "left: {}, _{}_, {} --&gt; _{}_, {}, {}",
                                    n_dir, x_dir, y_dir, n_dir_upd, x_dir_upd, y_dir_upd
                                )
                            }
                        } else if n_dir_upd == y_dir {
                            // move down
                            if x_dir_upd == x_dir &amp;&amp; y_dir_upd == (n_dir + 3) % 6 {
                                (x, 0, HEAD_DOWN)
                            } else if x_dir_upd == (x_dir + 3) % 6 &amp;&amp; y_dir_upd == n_dir {
                                (face_width - 1 - x, face_width - 1, HEAD_UP)
                            } else if y_dir_upd == x_dir &amp;&amp; x_dir_upd == n_dir {
                                (face_width - 1, x, HEAD_LEFT)
                            } else if y_dir_upd == (x_dir + 3) % 6 &amp;&amp; x_dir_upd == (n_dir + 3) % 6 {
                                (0, face_width - 1 - x, HEAD_RIGHT)
                            } else {
                                unreachable!(
                                    "down: {}, {}, _{}_ --&gt; _{}_, {}, {}",
                                    n_dir, x_dir, y_dir, n_dir_upd, x_dir_upd, y_dir_upd
                                )
                            }
                        } else if n_dir_upd == (y_dir + 3) % 6 {
                            // move up
                            if x_dir_upd == x_dir &amp;&amp; y_dir_upd == n_dir {
                                (x, face_width - 1, HEAD_UP)
                            } else if x_dir_upd == (x_dir + 3) % 6 &amp;&amp; y_dir_upd == (n_dir + 3) % 6 {
                                (face_width - 1 - x, 0, HEAD_DOWN)
                            } else if y_dir_upd == x_dir &amp;&amp; x_dir_upd == (n_dir + 3) % 6 {
                                (0, x, HEAD_RIGHT)
                            } else if y_dir_upd == (x_dir + 3) % 6 &amp;&amp; x_dir_upd == n_dir {
                                (face_width - 1, face_width - 1 - x, HEAD_LEFT)
                            } else {
                                unreachable!(
                                    "up: {}, {}, _{}_ --&gt; _{}_, {}, {}",
                                    n_dir, x_dir, y_dir, n_dir_upd, x_dir_upd, y_dir_upd
                                )
                            }
                        } else {
                            unreachable!()
                        };

                        (x_upd, y_upd, d_upd, col_upd, row_upd, x_dir_upd, y_dir_upd)
                    } else {
                        // update within a face
                        (x_upd, y_upd, d, col, row, x_dir, y_dir)
                    };

                    if data.grid
                        [x_upd + col_upd * face_width + (y_upd + row_upd * face_width) * data.width]
                        == b'#'
                    {
                        // wall, can't move any further
                        break;
                    }

                    // update
                    x = x_upd;
                    y = y_upd;
                    d = d_upd;
                    col = col_upd;
                    row = row_upd;
                    n_dir = n_dir_upd;
                    x_dir = x_dir_upd;
                    y_dir = y_dir_upd;

                    #[cfg(feature = "print-path")]
                    path.insert(
                        x + col * face_width + (y + row * face_width) * data.width,
                        d,
                    );
                }
            }
            Step::Left =&gt; d = (d + 3) % 4,
            Step::Right =&gt; d = (d + 1) % 4,
        }

        #[cfg(feature = "print-path")]
        path.insert(
            x + col * face_width + (y + row * face_width) * data.width,
            d,
        );
    }

    #[cfg(feature = "print-path")]
    for y in 0..data.grid.len() / data.width {
        for x in 0..data.width {
            let p = x + y * data.width;
            match (path.get(&amp;p), data.grid[p]) {
                (Some(0), b'.') =&gt; {
                    print!("&gt;");
                }
                (Some(1), b'.') =&gt; {
                    print!("v");
                }
                (Some(2), b'.') =&gt; {
                    print!("&lt;");
                }
                (Some(3), b'.') =&gt; {
                    print!("^");
                }
                (None, b'#') =&gt; {
                    print!("#");
                }
                (None, b'.') =&gt; {
                    print!(".");
                }
                (None, b' ') =&gt; {
                    print!(" ");
                }
                (a, b) =&gt; panic!("Unexpected {a:?}, {}", b as char),
            }
        }
        println!();
    }

    (y + row * face_width + 1) * 1000 + (x + col * face_width + 1) * 4 + d
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tests_23"><a class="anchor" href="#_tests_23"></a><a class="link" href="#_tests_23">Tests</a></h5>
<div class="paragraph">
<p>Tests were very necessary today to come up with a solution. I created several additional simple test cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">#[cfg(test)]
mod tests {
    use super::*;

    const CONTENT: &amp;str = r#"        ...#
        .#..
        #...
        ....
...#.......#
........#...
..#....#....
..........#.
        ...#....
        .....#..
        .#......
        ......#.

10R5L5R10L4R5L5
"#;

    #[test]
    pub fn test_from() {
        let data = PuzzleData::from(CONTENT);
        println!("{data:?}");
    }

    #[test]
    pub fn test_star_1() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(6_032, star_1(&amp;data));
    }

    #[test]
    pub fn test_star_2() {
        let data = PuzzleData::from(CONTENT);
        assert_eq!(5_031, star_2(&amp;data, 4));

        let data = PuzzleData::from(include_str!("../tests_1.txt"));
        assert_eq!(1_033, star_2(&amp;data, 5));

        let data = PuzzleData::from(include_str!("../tests_2.txt"));
        assert_eq!(1_033, star_2(&amp;data, 5));

        let data = PuzzleData::from(include_str!("../tests_3.txt"));
        assert_eq!(12_013, star_2(&amp;data, 5));

        let data = PuzzleData::from(include_str!("../tests_4.txt"));
        assert_eq!(3_028, star_2(&amp;data, 5));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>