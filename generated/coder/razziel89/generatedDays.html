<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: razziel89</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_razziel89">razziel89</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_01_calorie_counting">Day 01: Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_oveview">Oveview</a></li>
<li><a href="#_how_to_run">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_02_rock_paper_scissors">Day 02: Rock Paper Scissors</a>
<ul class="sectlevel4">
<li><a href="#_oveview_2">Oveview</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_how_to_run_2">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_03_rucksack_reorganization">Day 03: Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_oveview_3">Oveview</a></li>
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_how_to_run_3">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_04_camp_cleanup">Day 04: Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_oveview_4">Oveview</a></li>
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_how_to_run_4">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_05_supply_stacks">Day 05: Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_solution_4">Solution</a></li>
<li><a href="#_how_to_run_5">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_06_tuning_trouble">Day 06: Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_overview_2">Overview</a></li>
<li><a href="#_solution_5">Solution</a></li>
<li><a href="#_how_to_run_6">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_07_no_space_left_on_device">Day 07: No Space Left On device</a>
<ul class="sectlevel4">
<li><a href="#_oveview_5">Oveview</a></li>
<li><a href="#_solution_6">Solution</a></li>
<li><a href="#_how_to_run_7">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_rust">Day 08: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_08_treetop_tree_house">Day 08: Treetop Tree House</a>
<ul class="sectlevel4">
<li><a href="#_oveview_6">Oveview</a></li>
<li><a href="#_solution_7">Solution</a></li>
<li><a href="#_how_to_run_8">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_rust">Day 09: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_09_rope_bridge">Day 09: Rope Bridge</a>
<ul class="sectlevel4">
<li><a href="#_oveview_7">Oveview</a></li>
<li><a href="#_solution_8">Solution</a></li>
<li><a href="#_how_to_run_9">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_rust">Day 10: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a>
<ul class="sectlevel4">
<li><a href="#_oveview_8">Oveview</a></li>
<li><a href="#_solution_9">Solution</a></li>
<li><a href="#_how_to_run_10">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_11_rust">Day 11: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_11_monkey_in_the_middle">Day 11: Monkey in the Middle</a>
<ul class="sectlevel4">
<li><a href="#_oveview_9">Oveview</a></li>
<li><a href="#_solution_10">Solution</a></li>
<li><a href="#_how_to_run_11">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_12_rust">Day 12: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_12_hill_climbing_algorithm">Day 12: Hill Climbing Algorithm</a>
<ul class="sectlevel4">
<li><a href="#_oveview_10">Oveview</a></li>
<li><a href="#_solution_11">Solution</a></li>
<li><a href="#_how_to_run_12">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_13_rust">Day 13: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_13_distress_signal">Day 13: Distress Signal</a>
<ul class="sectlevel4">
<li><a href="#_oveview_11">Oveview</a></li>
<li><a href="#_solution_12">Solution</a></li>
<li><a href="#_how_to_run_13">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_14_rust">Day 14: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_14_regolith_reservoir">Day 14: Regolith Reservoir</a>
<ul class="sectlevel4">
<li><a href="#_oveview_12">Oveview</a></li>
<li><a href="#_solution_13">Solution</a></li>
<li><a href="#_how_to_run_14">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_15_rust">Day 15: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_15_beacon_exclusion_zone">Day 15: Beacon Exclusion Zone</a>
<ul class="sectlevel4">
<li><a href="#_oveview_13">Oveview</a></li>
<li><a href="#_solution_14">Solution</a></li>
<li><a href="#_how_to_run_15">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_16_rust">Day 16: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_16_proboscidea_volcanium">Day 16: Proboscidea Volcanium</a>
<ul class="sectlevel4">
<li><a href="#_oveview_14">Oveview</a></li>
<li><a href="#_solution_15">Solution</a></li>
<li><a href="#_how_to_run_16">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_17_rust">Day 17: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_17_pyroclastic_flow">Day 17: Pyroclastic Flow</a>
<ul class="sectlevel4">
<li><a href="#_oveview_15">Oveview</a></li>
<li><a href="#_solution_16">Solution</a></li>
<li><a href="#_how_to_run_17">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_18_rust">Day 18: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_18_boiling_boulders">Day 18: Boiling Boulders</a>
<ul class="sectlevel4">
<li><a href="#_oveview_16">Oveview</a></li>
<li><a href="#_solution_17">Solution</a></li>
<li><a href="#_how_to_run_18">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_19_rust">Day 19: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_19_not_enough_minerals">Day 19: Not Enough Minerals</a>
<ul class="sectlevel4">
<li><a href="#_oveview_17">Oveview</a></li>
<li><a href="#_solution_18">Solution</a></li>
<li><a href="#_how_to_run_19">How to run</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_razziel89"><a class="anchor" href="#_razziel89"></a><a class="link" href="#_razziel89">razziel89</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">image:[][]</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>razziel89</strong><br>
<span class="icon"><i class="fa fa-github"></i></span>: [][razziel89]</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>Nothing here yet. Update your profile at <a href="https://github.com/docToolchain/aoc-2022/blob/master/profiles/razziel89.adoc">/profiles/razziel89.adoc</a></p>
</div>
<a id="day01" />
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_01_calorie_counting"><a class="anchor" href="#_day_01_calorie_counting"></a><a class="link" href="#_day_01_calorie_counting">Day 01: Calorie Counting</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the calorie counting puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview"><a class="anchor" href="#_oveview"></a><a class="link" href="#_oveview">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.go</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
const NUM_ELVES: usize = 3;

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let baggage = io::parse_lines_to_data::&lt;data::Baggage&gt;(file, "baggage")?;

    let mut elves = data::baggages_to_elves(baggage);

    // Elf carrying the most calories will be first in line. It is inefficient to calculate total
    // calories for every comparison, but it's not really important for this exercise.
    elves.sort_by(|el1, el2| el2.total_calories().cmp(&amp;el1.total_calories()));

    match elves.len() {
        // Even though we could solve part 1 if we had 1..=2 elves, we ignore that case here.
        0..=2 =&gt; Err(Error::msg("somehow, we found too few elves :(")),
        _ =&gt; {
            // Part 1.
            println!(
                "elf carrying the most is num {} who carries {} calories",
                elves[0].get_idx(),
                elves[0].total_calories()
            );

            // Part 2.
            let total_calories: u64 = elves
                .iter()
                .take(NUM_ELVES)
                .map(|el| el.total_calories())
                .sum();

            println!(
                "the {} elves carrying the most carry {} in total\n",
                NUM_ELVES, total_calories
            );

            Ok(())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum Baggage {
    Calories(u64),
    EndOfElf,
}

#[derive(Debug)]
pub struct Elf {
    idx: usize,
    baggage: Vec&lt;Baggage&gt;,
}

impl FromStr for Baggage {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "" =&gt; Ok(Baggage::EndOfElf),
            val =&gt; Ok(Baggage::Calories(val.parse::&lt;u64&gt;()?)),
        }
    }
}

impl Elf {
    pub fn total_calories(&amp;self) -&gt; u64 {
        self.baggage
            .iter()
            .map(|el| match el {
                Baggage::Calories(val) =&gt; val,
                Baggage::EndOfElf =&gt; &amp;0,
            })
            .sum()
    }

    pub fn get_idx(&amp;self) -&gt; usize {
        self.idx
    }
}

pub fn baggages_to_elves(baggage: Vec&lt;Baggage&gt;) -&gt; Vec&lt;Elf&gt; {
    let mut elves = vec![];
    let mut elf = Elf {
        idx: 1,
        baggage: vec![],
    };

    for el in baggage {
        match el {
            Baggage::Calories(_) =&gt; {
                elf.baggage.push(el);
            }
            Baggage::EndOfElf =&gt; {
                let next_elf = Elf {
                    idx: elf.idx + 1,
                    baggage: vec![],
                };
                elves.push(elf);
                elf = next_elf;
            }
        }
    }

    elves
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run"><a class="anchor" href="#_how_to_run"></a><a class="link" href="#_how_to_run">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_02_rock_paper_scissors"><a class="anchor" href="#_day_02_rock_paper_scissors"></a><a class="link" href="#_day_02_rock_paper_scissors">Day 02: Rock Paper Scissors</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the RPS puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_2"><a class="anchor" href="#_oveview_2"></a><a class="link" href="#_oveview_2">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>This one was pretty straightforward.
I might have taken enums in Rust a bit far, here, but I wanted to use them since
Go, the language used last year, doesn&#8217;t have enums.
I also tried out a custom trait so that I could use generics to determine which
round it was.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;
// Constants.
// None yet.

fn solve&lt;T&gt;(file: &amp;str) -&gt; Result&lt;()&gt;
where
    T: FromStr&lt;Err = Error&gt;,
    T: data::Round,
{
    eprintln!("PROCESSING {}", file);

    let mut scores = (0, 0);

    // Read file and convert into data.
    let rounds = io::parse_lines_to_data::&lt;T&gt;(file, "rounds")?;

    for round in rounds {
        let round_scores = round.score();
        scores = (scores.0 + round_scores.0, scores.1 + round_scores.1);
    }

    println!("scores are opponent: {}, you: {}\n", scores.0, scores.1);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.
    solve::&lt;data::RoundPart1&gt;(SAMPLE)?;
    solve::&lt;data::RoundPart1&gt;(REAL)?;

    solve::&lt;data::RoundPart2&gt;(SAMPLE)?;
    solve::&lt;data::RoundPart2&gt;(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum RPS {
    R,
    P,
    S,
}

#[derive(Debug)]
pub enum Outcome {
    Win,
    Loss,
    Draw,
}

// This trait is used so that we don't have to care which round we're scoring.
pub trait Round {
    fn score(&amp;self) -&gt; (usize, usize);
}

#[derive(Debug)]
pub struct RoundPart1 {
    other: RPS,
    me: RPS,
}

#[derive(Debug)]
pub struct RoundPart2 {
    other: RPS,
    outcome: Outcome,
}

impl FromStr for RPS {
    type Err = Error;

    // This parser can be used for rounds 1 and 2.
    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "A" | "X" =&gt; Ok(RPS::R),
            "B" | "Y" =&gt; Ok(RPS::P),
            "C" | "Z" =&gt; Ok(RPS::S),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as RPS", s))),
        }
    }
}

impl FromStr for Outcome {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "X" =&gt; Ok(Outcome::Loss),
            "Y" =&gt; Ok(Outcome::Draw),
            "Z" =&gt; Ok(Outcome::Win),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as Outcome", s))),
        }
    }
}

impl FromStr for RoundPart1 {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [other, me] =&gt; {
                // Other error.
                if !["A", "B", "C"].contains(other) {
                    Err(Error::msg(format!("unknown value {} for other", other)))
                // Me error.
                } else if !["X", "Y", "Z"].contains(me) {
                    Err(Error::msg(format!("unknown value {} for me", me)))
                // Success case.
                } else {
                    Ok(RoundPart1 {
                        other: other.parse::&lt;RPS&gt;()?,
                        me: me.parse::&lt;RPS&gt;()?,
                    })
                }
            }
            _ =&gt; Err(Error::msg(format!("cannot parse {}", s))),
        }
    }
}

impl FromStr for RoundPart2 {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [other, result] =&gt; {
                // Other error.
                if !["A", "B", "C"].contains(other) {
                    Err(Error::msg(format!("unknown value {} for other", other)))
                // Success case.
                } else {
                    Ok(RoundPart2 {
                        other: other.parse::&lt;RPS&gt;()?,
                        outcome: result.parse::&lt;Outcome&gt;()?,
                    })
                }
            }
            _ =&gt; Err(Error::msg(format!("cannot parse {}", s))),
        }
    }
}

impl Outcome {
    fn score(&amp;self) -&gt; usize {
        match &amp;self {
            Outcome::Loss =&gt; 0,
            Outcome::Draw =&gt; 3,
            Outcome::Win =&gt; 6,
        }
    }
}

impl RPS {
    fn score(&amp;self) -&gt; usize {
        match self {
            RPS::R =&gt; 1,
            RPS::P =&gt; 2,
            RPS::S =&gt; 3,
        }
    }

    // Needed for round 1. This function could benefit from testing so that we know the result if
    // called with (a, b) and (b, a) make sense.
    fn check_win(&amp;self, other: &amp;RPS) -&gt; Outcome {
        match (self, other) {
            // Self rock.
            (RPS::R, RPS::R) =&gt; Outcome::Draw,
            (RPS::R, RPS::P) =&gt; Outcome::Loss,
            (RPS::R, RPS::S) =&gt; Outcome::Win,
            // Self paper.
            (RPS::P, RPS::R) =&gt; Outcome::Win,
            (RPS::P, RPS::P) =&gt; Outcome::Draw,
            (RPS::P, RPS::S) =&gt; Outcome::Loss,
            // Self scissors.
            (RPS::S, RPS::R) =&gt; Outcome::Loss,
            (RPS::S, RPS::P) =&gt; Outcome::Win,
            (RPS::S, RPS::S) =&gt; Outcome::Draw,
        }
    }

    // Needed for round 2. This is called on the other's value with a desired outcome.
    fn get_reply(&amp;self, result: &amp;Outcome) -&gt; RPS {
        match (self, result) {
            // Rock.
            (RPS::R, Outcome::Loss) =&gt; RPS::S,
            (RPS::R, Outcome::Draw) =&gt; RPS::R,
            (RPS::R, Outcome::Win) =&gt; RPS::P,
            // Paper.
            (RPS::P, Outcome::Loss) =&gt; RPS::R,
            (RPS::P, Outcome::Draw) =&gt; RPS::P,
            (RPS::P, Outcome::Win) =&gt; RPS::S,
            // Scissors.
            (RPS::S, Outcome::Loss) =&gt; RPS::P,
            (RPS::S, Outcome::Draw) =&gt; RPS::S,
            (RPS::S, Outcome::Win) =&gt; RPS::R,
        }
    }
}

// It turns out we do not need to track the other's score, but we only knew that after the fact...
impl Round for RoundPart1 {
    fn score(&amp;self) -&gt; (usize, usize) {
        (
            self.other.score() + self.other.check_win(&amp;self.me).score(),
            self.me.score() + self.me.check_win(&amp;self.other).score(),
        )
    }
}

impl Round for RoundPart2 {
    fn score(&amp;self) -&gt; (usize, usize) {
        let reply = self.other.get_reply(&amp;self.outcome);
        (
            self.other.score() + self.other.check_win(&amp;reply).score(),
            reply.score() + reply.check_win(&amp;self.other).score(),
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_2"><a class="anchor" href="#_how_to_run_2"></a><a class="link" href="#_how_to_run_2">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_03_rucksack_reorganization"><a class="anchor" href="#_day_03_rucksack_reorganization"></a><a class="link" href="#_day_03_rucksack_reorganization">Day 03: Rucksack Reorganization</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the rucksack reorganization puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_3"><a class="anchor" href="#_oveview_3"></a><a class="link" href="#_oveview_3">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_2"><a class="anchor" href="#_solution_2"></a><a class="link" href="#_solution_2">Solution</a></h5>
<div class="paragraph">
<p>This one was straightforward, but I am not too happy with how the solution
looks.
Working with the <code>HashSet</code> type was not as easy as I thought, e.g. when trying
to compute the overlap of multiple sets.
Furthermore, I somehow misunderstood part 2 at first, which lead me on a wild
goose chase.
Still, this works, but I lack the time to provid more details about the
implementation.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn ord(c: char) -&gt; Result&lt;usize&gt; {
    match c {
        'a'..='z' =&gt; Ok((c as usize - 'a' as usize) + 1),
        'A'..='Z' =&gt; Ok((c as usize - 'A' as usize) + 27),
        _ =&gt; Err(Error::msg(format!(
            "invalid character {} for ord conversion",
            c,
        ))),
    }
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let rucksacks = io::parse_lines_to_data::&lt;data::Rucksack&gt;(file, "rucksack")?;

    // Part 1.
    let common = rucksacks
        .iter()
        .map(|el| (&amp;el.left &amp; &amp;el.right).into_iter().collect::&lt;Vec&lt;_&gt;&gt;())
        .enumerate()
        .map(|(idx, el)| {
            if el.len() == 1 {
                ord(el[0])
            } else {
                Err(Error::msg(format!(
                    "entry {} has wrong length {}",
                    idx,
                    el.len()
                )))
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    {
        let mut has_err = false;
        for c in common.as_slice() {
            if let Err(err) = c {
                eprintln!("{:?}", err);
                has_err = true;
            }
        }
        if has_err {
            return Err(Error::msg("encountered at least one error"));
        }
    }

    println!(
        "part 1, total value is {}",
        common.iter().flatten().sum::&lt;usize&gt;()
    );

    // Part 2.
    let badges = rucksacks
        .iter()
        .map(|el| el.everything())
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .chunks_exact(3)
        .into_iter()
        .map(|sets| {
            if let [set1, set2, set3] = sets {
                (&amp;(set1 &amp; set2) &amp; set3).into_iter().collect::&lt;Vec&lt;_&gt;&gt;()
            } else {
                panic!("this will never happen due to the use of exact_chunk")
            }
        })
        .enumerate()
        .map(|(idx, el)| {
            if el.len() == 1 {
                ord(el[0])
            } else {
                Err(Error::msg(format!(
                    "entry {} has wrong length {}",
                    idx,
                    el.len()
                )))
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "part 2, total value is {}",
        badges.iter().flatten().sum::&lt;usize&gt;()
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
use std::str::FromStr;

#[derive(Debug)]
pub struct Rucksack {
    pub left: HashSet&lt;char&gt;,
    pub right: HashSet&lt;char&gt;,
}

impl Rucksack {
    pub fn everything(&amp;self) -&gt; HashSet&lt;char&gt; {
        &amp;self.left | &amp;self.right
    }
}

impl FromStr for Rucksack {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let left = str_to_set(&amp;s[..s.len() / 2]);
        let right = str_to_set(&amp;s[s.len() / 2..]);
        Ok(Rucksack { left, right })
    }
}

fn str_to_set(s: &amp;str) -&gt; HashSet&lt;char&gt; {
    HashSet::from_iter(s.chars())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_3"><a class="anchor" href="#_how_to_run_3"></a><a class="link" href="#_how_to_run_3">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_04_camp_cleanup"><a class="anchor" href="#_day_04_camp_cleanup"></a><a class="link" href="#_day_04_camp_cleanup">Day 04: Camp Cleanup</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the camp cleanup puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_4"><a class="anchor" href="#_oveview_4"></a><a class="link" href="#_oveview_4">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_3"><a class="anchor" href="#_solution_3"></a><a class="link" href="#_solution_3">Solution</a></h5>
<div class="paragraph">
<p>This one was straightforward, which is why I tried my luck with a generic pair
type.
It worked out nicely as I only had to implemeng the parsing logic once but could
use it for two concrete types.
Then, it was just a matter of creating the methods that compute whether there is
a full (part 1) or partial (part 2) overlap between two ranges and to check for
overlaps in both directions (which is strictly not needed for part 2 but doesn&#8217;t
hurt).</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let pairs = io::parse_lines_to_data::&lt;data::Pair&gt;(file, "pair")?;

    let full_overlaps = pairs
        .iter()
        .filter_map(|el| if el.full_overlap() { Some(el) } else { None })
        .count();

    println!("there are {} full overlaps", full_overlaps);

    let partial_overlaps = pairs
        .iter()
        .filter_map(|el| if el.partial_overlap() { Some(el) } else { None })
        .count();

    println!("there are {} partial overlaps", partial_overlaps);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct GenPair&lt;T, const SEP: char&gt; {
    pub left: T,
    pub right: T,
}

#[derive(Debug)]
pub struct Num(usize);

impl FromStr for Num {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        Ok(Self(s.parse::&lt;usize&gt;()?))
    }
}

impl&lt;T, const SEP: char&gt; FromStr for GenPair&lt;T, { SEP }&gt;
where
    T: FromStr&lt;Err = Error&gt;,
{
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split(SEP).collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [left_str, right_str] =&gt; Ok(Self {
                left: left_str.parse::&lt;T&gt;()?,
                right: right_str.parse::&lt;T&gt;()?,
            }),
            _ =&gt; Err(Error::msg(format!(
                "cannot parse {} as pair with sep {}",
                s, SEP
            ))),
        }
    }
}

pub type Range = GenPair&lt;Num, '-'&gt;;
pub type Pair = GenPair&lt;Range, ','&gt;;

impl Range {
    fn contains(&amp;self, other: &amp;Range) -&gt; bool {
        self.left.0 &lt;= other.left.0 &amp;&amp; self.right.0 &gt;= other.right.0
    }

    fn overlap(&amp;self, other: &amp;Range) -&gt; bool {
        (self.left.0 &lt;= other.right.0 &amp;&amp; self.left.0 &gt;= other.left.0)
            || (self.right.0 &gt;= other.left.0 &amp;&amp; self.right.0 &lt;= other.right.0)
    }
}

impl Pair {
    pub fn full_overlap(&amp;self) -&gt; bool {
        self.left.contains(&amp;self.right) || self.right.contains(&amp;self.left)
    }

    pub fn partial_overlap(&amp;self) -&gt; bool {
        self.left.overlap(&amp;self.right) || self.right.overlap(&amp;self.left)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_4"><a class="anchor" href="#_how_to_run_4"></a><a class="link" href="#_how_to_run_4">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_05_supply_stacks"><a class="anchor" href="#_day_05_supply_stacks"></a><a class="link" href="#_day_05_supply_stacks">Day 05: Supply Stacks</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the supply stacks puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_overview"><a class="anchor" href="#_overview"></a><a class="link" href="#_overview">Overview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_4"><a class="anchor" href="#_solution_4"></a><a class="link" href="#_solution_4">Solution</a></h5>
<div class="paragraph">
<p>Once the inputs have been parsed, this one was straightforward to solve.
You simply have to follow the instructions.
Solving part 2 was particulary nice as I could just pass in a different crate
movement function.
I took the lazy approach for part 2 and implemented it via a temporary stack as
intermediary.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks was a bit harder, on the other hand, because there was no
separator string in place that would make it possible to easily distinguish the
different stacks.
I was tempted to preprocess the input via a shell script or even manually, which
would have simplified parsing.
But then I realised that a filter function each could be used to extract all the
lines belonging to either the stack definition or the definition of movement
instructions.
The use of inexact chunking then made it possible to easily read in the
different stacks.</p>
</div>
<div class="paragraph">
<p>Note that I have used two types to represent stacks: <code>Vec&lt;StackLine&gt;</code>, which is
the type representing the stack input, and <code>Vec&lt;Stack&gt;</code>, which is basically the
transpose of the first type.
Maybe using an actual matrix would have been a beter idea, but this works, too.</p>
</div>
<div class="paragraph">
<p>I noted that many of the terms used in this challenge are reserved words in rust
such as "crate" or "move".</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn lines_to_stacks(lines: &amp;Vec&lt;data::StackLine&gt;) -&gt; Result&lt;Vec&lt;data::Stack&gt;&gt; {
    if let Some(num_stacks) = lines.iter().map(|el| el.stacks.len()).max() {
        let mut stacks = vec![];

        for stack_idx in 0..num_stacks {
            let mut stack: data::Stack = vec![];

            // We reverse the iterator because we obtained the lines from top to bottom but we need
            // to build the stacks from the ground up. Thus, we iterate from the ground to the
            // bottom.
            for line in lines.iter().rev() {
                // We cannot be sure that every stack line contains the same number of entries.
                // Thus, we use the ".get" method to be able to catch the case where one line ends
                // before another. It turns out that every line has the same number of entries,
                // making this safeguard unnecessary...
                if let Some(Some(elem)) = line.stacks.get(stack_idx) {
                    stack.push(*elem);
                }
            }

            stacks.push(stack);
        }

        Ok(stacks)
    } else {
        Err(Error::msg("only empty stacks obtained"))
    }
}

fn check_bounds(idx: usize, len: usize, name: &amp;str) -&gt; Result&lt;()&gt; {
    if idx &gt; len {
        return Err(Error::msg(format!(
            "{} stack {} is out of bounds",
            name, idx
        )));
    } else {
        Ok(())
    }
}

fn apply_move_part1(stacks: &amp;mut Vec&lt;data::Stack&gt;, mov: &amp;data::Move) -&gt; Result&lt;()&gt; {
    // Thanks to these two bounds checks, we know that the index operations below will never panic.
    check_bounds(mov.src, stacks.len(), "source")?;
    check_bounds(mov.dest, stacks.len(), "dest")?;

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;stacks[mov.src].pop() {
            stacks[mov.dest].push(*moved_elem);
        } else {
            return Err(Error::msg(format!("cannot apply move {:?}", mov)));
        }
    }
    Ok(())
}

fn apply_move_part2(stacks: &amp;mut Vec&lt;data::Stack&gt;, mov: &amp;data::Move) -&gt; Result&lt;()&gt; {
    // Thanks to these two bounds checks, we know that the index operations below will never panic.
    check_bounds(mov.src, stacks.len(), "source")?;
    check_bounds(mov.dest, stacks.len(), "dest")?;

    // We are being lazy and are using a temporary stack to stash the crates away. That way, we
    // keep the order intact when putting them back from the temporary stash to the final stash.
    let mut temp_stack: data::Stack = vec![];

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;stacks[mov.src].pop() {
            temp_stack.push(*moved_elem);
        } else {
            return Err(Error::msg(format!(
                "cannot apply 1st half of move {:?}",
                mov
            )));
        }
    }

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;temp_stack.pop() {
            stacks[mov.dest].push(*moved_elem);
        } else {
            return Err(Error::msg(format!(
                "cannot apply 2nd half of move {:?}",
                mov
            )));
        }
    }
    Ok(())
}

fn solve(
    file: &amp;str,
    apply_move: fn(&amp;mut Vec&lt;data::Stack&gt;, &amp;data::Move) -&gt; Result&lt;()&gt;,
) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let moves =
        io::parse_lines_to_data::&lt;data::Move&gt;(file, "move", Some(|el| el.contains("move")), None)?;

    let stack_lines = io::parse_lines_to_data::&lt;data::StackLine&gt;(
        file,
        "stack line",
        Some(|el| el.contains("[")),
        None,
    )?;

    let mut stacks = lines_to_stacks(&amp;stack_lines)?;

    for mov in &amp;moves {
        apply_move(&amp;mut stacks, mov)?;
    }

    let mut errs = vec![];

    println!(
        "the top elements are: {}",
        stacks
            .iter()
            .enumerate()
            .map(|(idx, el)| el
                .last()
                .map(|el| el.to_string())
                .ok_or(Error::msg(format!("stack {} is empty", idx))))
            .filter_map(|el| io::filter_and_remember_errs(el, &amp;mut errs))
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("")
    );

    io::process_remembered_errs(errs)
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE, apply_move_part1)?;
    solve(REAL, apply_move_part1)?;

    solve(SAMPLE, apply_move_part2)?;
    solve(REAL, apply_move_part2)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use crate::io;
use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Move {
    pub num: usize,
    pub src: usize,
    pub dest: usize,
}

// We are using our own stack type here just so that the code is easier to read.
pub type Stack = Vec&lt;char&gt;;

// This is a temporary data type that we use to parse each line of the top part of the input.
#[derive(Debug)]
pub struct StackLine {
    pub stacks: Vec&lt;Option&lt;char&gt;&gt;,
}

impl FromStr for Move {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["move", num, "from", src, "to", dest] =&gt; Ok(Self {
                num: num.parse()?,
                // We use zero-based indexing but the example uses one-based indxing. Thus, we
                // convert here.
                src: src
                    .parse::&lt;usize&gt;()?
                    .checked_sub(1)
                    .ok_or(Error::msg(format!("{} is not &gt;1", src)))?,
                dest: dest
                    .parse::&lt;usize&gt;()?
                    .checked_sub(1)
                    .ok_or(Error::msg(format!("{} is not &gt;1", dest)))?,
            }),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as move", s))),
        }
    }
}

// A hybrid between a result and an option.
pub enum Hybrid&lt;T, E&gt; {
    Some(T),
    Err(E),
    None,
}

impl FromStr for StackLine {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let mut errs = vec![];

        let stacks = s
            .chars()
            .collect::&lt;Vec&lt;_&gt;&gt;()
            // Chunking is important here. Each stack entry contains at most 4 characters.
            // Thus, by chunking this way, we make sure to get exactly one chunk per stack.
            // Luckily, none of the stacks contains multi-letter crates ^^.
            .chunks(4)
            .map(|el| match el {
                // Case with data, can be 3 or 4 characters long.
                ['[', ch, ']', ' '] | ['[', ch, ']'] =&gt; Hybrid::Some(ch.clone()),
                // Case without data.
                [' ', ' ', ' ', ' '] | [' ', ' ', ' '] =&gt; Hybrid::None,
                // Error case.
                _ =&gt; Hybrid::Err(Error::msg(format!("cannot parse line {} as stack line", s))),
            })
            .map(|el| match el {
                Hybrid::Some(val) =&gt; Some(val),
                Hybrid::Err(err) =&gt; {
                    errs.push(format!("{:?}", err));
                    None
                }
                Hybrid::None =&gt; None,
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        io::process_remembered_errs(errs).map(|_| Self { stacks })
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>io.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Context, Error, Result};
use std::fmt::Debug;
use std::str::FromStr;

fn read_lines_from_file(path: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
    Ok(std::fs::read_to_string(path)
        .context("reading from disk")?
        .trim_end()
        .split('\n')
        .map(|el| String::from(el))
        .collect())
}

pub type Predicate = fn(&amp;String) -&gt; bool;
pub type Transform = fn(String) -&gt; String;

pub fn parse_lines_to_data&lt;T&gt;(
    file: &amp;str,
    type_name: &amp;str,
    filter: Option&lt;Predicate&gt;,
    transform: Option&lt;Transform&gt;,
) -&gt; Result&lt;Vec&lt;T&gt;&gt;
where
    T: FromStr&lt;Err = Error&gt;,
{
    let filter_fn = filter.unwrap_or(|_| true);
    let transformer = transform.unwrap_or(|el| el);

    let mut errs: Vec&lt;String&gt; = vec![];

    // Read file and convert into actions.
    let data = read_lines_from_file(file)
        .context("reading lines")?
        .into_iter()
        .filter(filter_fn)
        .map(transformer)
        .enumerate()
        .filter_map(|(idx, el)| {
            match el
                .parse::&lt;T&gt;()
                .with_context(|| format!("cannot parse line {} as {}: {}", idx, type_name, el))
            {
                Ok(val) =&gt; Some(val),
                Err(err) =&gt; {
                    errs.push(format!("{:?}", err));
                    None
                }
            }
        })
        .collect();

    if errs.len() == 0 {
        Ok(data)
    } else {
        // Concatenate errors into one giant error message in case there were any in the file.
        Err(Error::msg(errs.join("\n------------------\n")))
    }
}

// Convert Result to Option but make sure to add all errors messages to a vector of strings. Use
// "process_errs" to check whethere there are any errors in the vector.
pub fn filter_and_remember_errs&lt;I, E&gt;(item: Result&lt;I, E&gt;, errs: &amp;mut Vec&lt;String&gt;) -&gt; Option&lt;I&gt;
where
    E: Debug,
{
    match item {
        Ok(val) =&gt; Some(val),
        Err(err) =&gt; {
            errs.push(format!("{:?}", err));
            None
        }
    }
}

// If there is any element in the string vector, concatenate all ements into an error. Do not
// return an error otherwise.
pub fn process_remembered_errs(errs: Vec&lt;String&gt;) -&gt; Result&lt;()&gt; {
    if errs.len() == 0 {
        Ok(())
    } else {
        // Concatenate errors into one giant error message in case there were any in the file.
        Err(Error::msg(errs.join("\n------------------\n")))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_5"><a class="anchor" href="#_how_to_run_5"></a><a class="link" href="#_how_to_run_5">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_06_tuning_trouble"><a class="anchor" href="#_day_06_tuning_trouble"></a><a class="link" href="#_day_06_tuning_trouble">Day 06: Tuning Trouble</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the touning trouble puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_overview_2"><a class="anchor" href="#_overview_2"></a><a class="link" href="#_overview_2">Overview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_5"><a class="anchor" href="#_solution_5"></a><a class="link" href="#_solution_5">Solution</a></h5>
<div class="paragraph">
<p>For this one, input parsing was non-existent.
Processing, on the other hand, was a bit harder.
At first, I thought about implementing the uniqueness condition manually,
considering that we only had to compare four entries in a pairwise fashion.
I&#8217;m glad I didn&#8217;t do that, though, because of part two.
Instead, it became clear that a set (<code>HashSet</code> in rust) could be used.</p>
</div>
<div class="paragraph">
<p>A set is a collection of unique entris.
Imagine converting a list of somethings into a set of somethings
The only way both the list and the set can have the same number of entries is if
and only if all entries in the list are unique.
That&#8217;s what this code uses.</p>
</div>
<div class="paragraph">
<p>My biggest struggle was rust&#8217;s ownership system and unsatisfied trait bounds
that I didn&#8217;t even know existed.
After the first functioning implementation, I cleaned the code up a bit.
It&#8217;s surprisingly concise.</p>
</div>
<div class="paragraph">
<p>I was happy to have discovered the <code>windows(size)</code> method usable with slices
that produces an iterator over overlapping chunks of <code>size</code> elements.
Now, I only had to check each of them for uniqueness.
That involved some slice-vector-iterator comversions, which appear to be very
common in rust.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.

fn solve(file: &amp;str, win: usize) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file.
    let lines = io::read_lines_from_file(file)?;

    for line in lines {
        let first_match = line
            .chars()
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .as_slice()
            .windows(win)
            .enumerate()
            .filter_map(|(idx, el)| {
                // If the size of a set is equal to the window size, then we have only unique
                // entries. There is no other way.
                if HashSet::&lt;char&gt;::from_iter(el.to_vec().into_iter()).len() == win {
                    Some(idx)
                } else {
                    None
                }
            })
            .take(1)
            .next()
            .ok_or(Error::msg("cannot find matching entry"))?;

        println!("first line that fits: {}", first_match + win)
    }

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE, 4)?;
    solve(REAL, 4)?;

    solve(SAMPLE, 14)?;
    solve(REAL, 14)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_6"><a class="anchor" href="#_how_to_run_6"></a><a class="link" href="#_how_to_run_6">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_07_no_space_left_on_device"><a class="anchor" href="#_day_07_no_space_left_on_device"></a><a class="link" href="#_day_07_no_space_left_on_device">Day 07: No Space Left On device</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_5"><a class="anchor" href="#_oveview_5"></a><a class="link" href="#_oveview_5">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_6"><a class="anchor" href="#_solution_6"></a><a class="link" href="#_solution_6">Solution</a></h5>
<div class="paragraph">
<p>This solution is not pretty but I kind of messed up a bit at first and then ran
out of time.
A lack of sleep could have contributed.</p>
</div>
<div class="paragraph">
<p>Parsing the input into a native data structure was straightforward thanks to
rust&#8217;s powerful enums.
But then the problems started.
For some reason, I decided to implement a fake directory structure manually as
an excercise and lost a lot of time that way.
As an alternative, I decided to take an idea from rsync&#8217;s cookbook and represent
files and directories a strings but ensure that direcotries always end with a
slash.
That way, I could have one set mapping paths to sizes but could easily determine
whether something was a file or a directory.</p>
</div>
<div class="paragraph">
<p>Then, the process was "just" building such a set of paths, finding all files
under a directory, and applying some operations to that.
I&#8217;m not happy with how the solution turned out but it works.
I was surprised by how much special care is needed when working with the root
directory <code>/</code>.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashMap;
// Constants.
// Part 1.
const MAX_SIZE: usize = 100000;
// Part 2.
const TOTAL_SIZE: usize = 70000000;
const REQUIRED_SIZE: usize = 30000000;

// We don'tuse a tree to represent the file system because trees are hard. Instead, we use a map
// mapping slash-separated strings to size values. An entry ending in a slash is a directory. That
// way, we can build everything up at once.
fn build_fs(entries: Vec&lt;data::Entry&gt;) -&gt; Result&lt;HashMap&lt;String, usize&gt;&gt; {
    let mut cwd = data::Stack::new();
    let mut fs = HashMap::&lt;String, usize&gt;::new();
    // This boolean serves as a way to check that we retrieve listed values only after the ls
    // command has been issued. It's just a sanity check for the input.
    let mut listing = false;

    fs.insert("/".to_string(), 0);

    // Build up the file system.
    for entry in entries {
        match entry {
            data::Entry::CD(dir) =&gt; {
                listing = false;
                match dir.as_str() {
                    ".." =&gt; cwd.popd(),
                    "/" =&gt; cwd.clear(),
                    _ =&gt; cwd.pushd(dir),
                }
                // Entries with a trailing slash are directories.
                let dir = cwd.pwd();
                if !fs.contains_key(&amp;dir) {
                    fs.insert(dir, 0);
                }
            }
            data::Entry::LS =&gt; {
                listing = true;
            }
            data::Entry::DIR(dir) =&gt; {
                if !listing {
                    return Err(Error::msg("found dir entry but not not in list mode"));
                }
                // Entries with a trailing slash are directories.
                fs.insert(format!("{}{}/", cwd.pwd(), dir), 0);
            }
            data::Entry::FILE { name, size } =&gt; {
                if !listing {
                    return Err(Error::msg("found file entry but not not in list mode"));
                }
                let dir = cwd.pwd();
                if !fs.contains_key(&amp;dir) {
                    return Err(Error::msg(format!("missing parent node {}", dir)));
                }
                // Entries without a trailing slash are files.
                fs.insert(format!("{}{}", dir, name), size);
                // Add directory sizes.
                for dir in &amp;mut cwd {
                    *fs.get_mut(&amp;dir)
                        .ok_or(Error::msg(format!("cannot read directory {}", dir)))? += size;
                }
            }
        }
    }

    Ok(fs)
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let entries = io::parse_lines_to_data::&lt;data::Entry&gt;(file, "entry", None, None)?;

    let filesystem = build_fs(entries)?;

    // Part 1.
    let result_part1 = filesystem
        .iter()
        .filter_map(|(name, size)| {
            if name.ends_with("/") &amp;&amp; size &lt;= &amp;MAX_SIZE {
                Some(size)
            } else {
                None
            }
        })
        .sum::&lt;usize&gt;();

    println!("requested size is {}", result_part1);

    // Part 2.
    // We already accumulated sizes, so getting this is easy. The amount of free space is the total
    // size minus what we currently occupy, which is the size of the root directory.
    // Note the use of checked_sub here because I wanted to try it out for subtracting from
    // unsigned values. Those checked_* methods allow graceful handling of overflows. Without them,
    // rust would panic if there was a violation of a type's value range.
    let used_space = *filesystem
        .get("/")
        .ok_or(Error::msg("cannot retrieve used space"))?;
    let free_space = TOTAL_SIZE
        .checked_sub(used_space)
        .ok_or(Error::msg("cannot compute free space"))?;
    let required_space = REQUIRED_SIZE
        .checked_sub(free_space)
        .ok_or(Error::msg("cannot compute required space"))?;

    eprintln!("need to free up at least {}", required_space);

    // Find the smallest directory that fulfils that condition.
    let min_free_size = filesystem
        .iter()
        .filter_map(|(name, size)| {
            if name.ends_with("/") &amp;&amp; size &gt;= &amp;required_space {
                Some(size)
            } else {
                None
            }
        })
        .min()
        .ok_or(Error::msg("cannot find any directory for part 2"))?;

    println!("freeing {} is enough", min_free_size);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use crate::io;
use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum Entry {
    CD(String),
    LS,
    DIR(String),
    FILE { name: String, size: usize },
}

impl FromStr for Entry {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["$", "cd", dir] =&gt; Ok(Self::CD(dir.to_string())),
            ["$", "ls"] =&gt; Ok(Self::LS),
            ["dir", dir] =&gt; Ok(Self::DIR(dir.to_string())),
            [size, name] =&gt; Ok(Self::FILE {
                name: name.to_string(),
                size: size.parse::&lt;usize&gt;()?,
            }),
            _ =&gt; Err(Error::msg(format!("canot parse {}", s))),
        }
    }
}

pub struct Stack {
    it_idx: usize,
    entries: Vec&lt;String&gt;,
}

impl Stack {
    pub fn new() -&gt; Self {
        Self {
            it_idx: 0,
            entries: vec![],
        }
    }

    pub fn pwd(&amp;self) -&gt; String {
        if self.entries.len() == 0 {
            "/".to_string()
        } else {
            format!("/{}/", self.entries.join("/"))
        }
    }

    pub fn pushd(&amp;mut self, dir: String) {
        self.entries.push(dir);
    }

    pub fn popd(&amp;mut self) {
        // Ignore this here.
        _ = self.entries.pop();
    }

    pub fn clear(&amp;mut self) {
        self.entries.clear();
    }
}

impl Iterator for Stack {
    type Item = String;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.it_idx &gt; self.entries.len() {
            self.it_idx = 0;
            None
        } else if self.it_idx == 0 {
            self.it_idx += 1;
            Some("/".to_string())
        } else {
            self.it_idx += 1;
            Some(format!("/{}/", self.entries[0..self.it_idx - 1].join("/")))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time, I&#8217;ve even added some tests for some helper functions.
Those tests lets me ensure that any special handling of the root direcotry works
as intended.
Adding tests to a file in rust was pretty easy and a nice experience.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_7"><a class="anchor" href="#_how_to_run_7"></a><a class="link" href="#_how_to_run_7">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_rust"><a class="anchor" href="#_day_08_rust"></a><a class="link" href="#_day_08_rust">Day 08: rust</a></h3>
<div class="sect3">
<h4 id="_day_08_treetop_tree_house"><a class="anchor" href="#_day_08_treetop_tree_house"></a><a class="link" href="#_day_08_treetop_tree_house">Day 08: Treetop Tree House</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_6"><a class="anchor" href="#_oveview_6"></a><a class="link" href="#_oveview_6">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_7"><a class="anchor" href="#_solution_7"></a><a class="link" href="#_solution_7">Solution</a></h5>
<div class="paragraph">
<p>I decided not to go the obvious route and use a <code>HashMap</code> mapping tree positions
to tree sizes instead.
I also increased all tree sizes by one so that I could use unsigned numbers for
tree sizes but still include the smallest trees.</p>
</div>
<div class="paragraph">
<p>The main part of this solution is a function that checks which trees are visible
and returns a <code>HashSet</code> of the positions of all visible trees.
I can then take the union of those sets to solve part 1.
The aforementioned function can scan several parallel lines one after the other.
The nice thing about using a <code>HashSet</code> is that I don&#8217;t have to cocern myself
with edges.
I can simply retrieve values until I can find none after displacing the checked
position and then stop iterating.</p>
</div>
<div class="paragraph">
<p>For part 2, I use the same function but modify the visibility condition.
That is, the maximum allowed height is that of the tree I look at.
Furthermore, we accept all trees smaller than our current tree.
I find that unrealistic, which caused some delay.
Imagine this (the tree height is at the top and the index at the bottom):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>4 3 3 1 4

|       |
| | |   |
| | |   |
| | | | |
0 1 2 3 4</pre>
</div>
</div>
<div class="paragraph">
<p>Tree 0 is the one we&#8217;re looking at.
For part 2, this would mean there are 4 trees visible from 0, namely 1, 2, 3,
and 4.
But, in my view, tree 3 is covered by trees 1 and 2 and should not be visible.
Anyway.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
// Constants.
// None yet.

// Count trees visible in a direction count_disp from all positions that can be reached from
// start_pos + n * outer_disp for all n that still yield a tree. If outer_disp is None, use only
// n==0. The search stops at the latest if no more trees can be found in that direction, assuming a
// dense forest.
//
// Whether a tree still counts as visible is defined by size_cmp. For part 1, it compares the
// current tree's size with the size of the largest tree found so far. For part 2, it always
// returns true because max_height has been set to that of the tree in consideration.
//
// A search in one direction stops early after a tree of max_height has been found because no trees
// behind it can be visible. The value for max_height differs between parts 1 and 2. For part 1,
// it's the global maximum and for part 2 it's the size of the tree in consideration.
fn count_visible(
    forest: &amp;HashMap&lt;(i64, i64), data::Tree&gt;,
    start_pos: &amp;data::Vec,
    count_disp: &amp;data::Vec,
    outer_disp: Option&lt;&amp;data::Vec&gt;,
    max_height: &amp;u8,
    size_cmp: fn(&amp;u8, &amp;u8) -&gt; bool,
) -&gt; HashSet&lt;(i64, i64)&gt; {
    let mut visible_forest = HashSet::&lt;(i64, i64)&gt;::new();

    let mut outer_start = start_pos.clone();

    // This will automatically stop if we cannot retrieve any more trees. Assuming a dense forest,
    // that means once we reached the edge.
    while let Some(_) = forest.get(&amp;outer_start.pos()) {
        let mut largest: u8 = 0;
        let mut pos = outer_start.clone();

        while &amp;largest &lt; max_height &amp;&amp; let Some(tree) = forest.get(&amp;pos.pos()) {
            let size = tree.size();
            // Remember the positions of trees that pass the size condition.
            if size_cmp(&amp;size, &amp;largest) {
                visible_forest.insert(pos.pos());
                largest = size;
            }
            pos = pos.add(&amp;count_disp);
        }

        // If we want to search in the same direction from different starting positions, update the
        // starting position and go on searching. If not, end the outer loop early.
        if let Some(disp) = outer_disp {
            outer_start = outer_start.add(disp);
        } else {
            break;
        }
    }

    visible_forest
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let forest = io::parse_chars_to_data::&lt;data::Tree&gt;(file, "tree")?;

    // Part 1.
    // Get dimensions of forest in all three directions. That could have been avoided by using some
    // matrix structure but I wanted to use a HashMap here, so this is necessary.
    let max_x = forest
        .keys()
        .map(|el| el.0)
        .max()
        .ok_or(Error::msg("cannot find max x index"))?;
    let max_y = forest
        .keys()
        .map(|el| el.1)
        .max()
        .ok_or(Error::msg("cannot find max y index"))?;
    let max_height = forest
        .values()
        .map(|val| val.size())
        .max()
        .ok_or(Error::msg("cannot find max height"))?;

    // Compute union of all visible forests (or rather, tree positions).
    let mut count = HashSet::&lt;(i64, i64)&gt;::new();
    // Top border rightwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(0, 0),
            &amp;data::Vec::new(0, 1),
            Some(&amp;data::Vec::new(1, 0)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );
    // Left border downwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(0, 0),
            &amp;data::Vec::new(1, 0),
            Some(&amp;data::Vec::new(0, 1)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );
    // Bottom border rightwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(0, max_y),
            &amp;data::Vec::new(0, -1),
            Some(&amp;data::Vec::new(1, 0)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );
    // Right border downwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(max_x, 0),
            &amp;data::Vec::new(-1, 0),
            Some(&amp;data::Vec::new(0, 1)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );

    println!("visible are {} trees", count.len());

    // Part 2.
    let disps = vec![
        data::Vec::new(0, -1),
        data::Vec::new(-1, 0),
        data::Vec::new(0, 1),
        data::Vec::new(1, 0),
    ];

    let best_view = forest
        .iter()
        .map(|(pos, height)| {
            disps
                .iter()
                .map(|disp| {
                    let tree_pos = data::Vec::new(pos.0, pos.1);
                    count_visible(
                        &amp;forest,
                        // Start searching at the first tree in the search direction from the
                        // starting position.
                        &amp;tree_pos.add(&amp;disp),
                        disp,
                        // Don't search along multiple parallel lines.
                        None,
                        &amp;height.size(),
                        |_size, _largest| true,
                    )
                    .len()
                })
                // The scenic score for a tree is the product of the number of trees it can see in
                // every direction.
                .product::&lt;usize&gt;()
        })
        .max()
        .ok_or(Error::msg("cannot find best view"))?;

    println!("best view is {}", best_view);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Tree(u8);

impl FromStr for Tree {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        // We increase the size by one to be able to perform simple unsigned size comparisons.
        Ok(Self(
            s.parse::&lt;u8&gt;()?
                .checked_add(1)
                .ok_or(Error::msg("cannot increase tree size"))?,
        ))
    }
}

impl Tree {
    pub fn size(&amp;self) -&gt; u8 {
        self.0
    }
}

#[derive(Debug, Clone)]
pub struct Vec {
    x: i64,
    y: i64,
}

impl Vec {
    pub fn add(&amp;self, other: &amp;Vec) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    pub fn pos(&amp;self) -&gt; (i64, i64) {
        (self.x, self.y)
    }

    pub fn new(x: i64, y: i64) -&gt; Self {
        Self { x, y }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_8"><a class="anchor" href="#_how_to_run_8"></a><a class="link" href="#_how_to_run_8">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_rust"><a class="anchor" href="#_day_09_rust"></a><a class="link" href="#_day_09_rust">Day 09: rust</a></h3>
<div class="sect3">
<h4 id="_day_09_rope_bridge"><a class="anchor" href="#_day_09_rope_bridge"></a><a class="link" href="#_day_09_rope_bridge">Day 09: Rope Bridge</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_7"><a class="anchor" href="#_oveview_7"></a><a class="link" href="#_oveview_7">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_8"><a class="anchor" href="#_solution_8"></a><a class="link" href="#_solution_8">Solution</a></h5>
<div class="paragraph">
<p>Solving this was quite a bit of fun!</p>
</div>
<div class="paragraph">
<p>I created a <code>Vec</code> class to represent 2d vectors and was quite happy to have
outsourced a lot of the logic into that class.
For example, the class offers a <code>mv</code> method, which only ever lets it move by one
space, which is a safeguard against trying to move too far at once.
I haven&#8217;t tried moving by more than one space at a time because it seemed overly
complicated.</p>
</div>
<div class="paragraph">
<p>Furthermore, the custom <code>Vec</code> class has an <code>iter</code> method that provides an
iterator over unit-size steps (unit vectors in the sense of the manhattan
metric) that, if followed, ensure the same distance has been traveled as
described by the original vector.
That way, a simple iteration over iterators gave us all the steps we needed.</p>
</div>
<div class="paragraph">
<p>For solving part 2, one problem was borrowing two elements of the rope
simultaneously while one was even borrowed mutably.
That won&#8217;t work in rust.
Instead, I use a temporary variable to keep track of the updated position of the
previous knot in the rope.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve also played around with lifetimes a bit.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.
// None yet.

// Define some helper functions that allow easy conversions from an Option&lt;data::Vec&gt; to a
// Result&lt;data::Vec&gt; because the latter lets us use the question mark operator for unobstrusive
// error forwarding.
fn tail(rope: &amp;Vec&lt;data::Vec&gt;) -&gt; Result&lt;data::Vec&gt; {
    rope.last()
        .map(|el| el.clone())
        .ok_or(Error::msg("cannot get tail"))
}

// Yeah, playing with lifetimes.
fn get_mut&lt;'a&gt;(rope: &amp;'a mut Vec&lt;data::Vec&gt;, idx: usize) -&gt; Result&lt;&amp;'a mut data::Vec&gt; {
    rope.get_mut(idx)
        .ok_or(Error::msg("cannot get element mutably"))
}

fn get&lt;'a&gt;(rope: &amp;'a Vec&lt;data::Vec&gt;, idx: usize) -&gt; Result&lt;&amp;'a data::Vec&gt; {
    rope.get(idx).ok_or(Error::msg("cannot get element"))
}

fn solve(file: &amp;str, length: usize) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {} WITH LENGTH {}", file, length);

    // Read file and convert into data.
    let updates = io::parse_lines_to_data::&lt;data::Vec&gt;(file, "vec", None, None)?;

    // All knots start at the very same position.
    let mut rope = vec![data::NULL_VEC; length + 2];
    let mut visited_by_tail = HashSet::&lt;data::Vec&gt;::new();

    visited_by_tail.insert(tail(&amp;rope)?);

    // Part 1.
    // The `iter` method for a vector provides an iterator over a set of unit-size steps that, if
    // followed, will ensure that we have traveled the entire distance described by the vector.
    for update in updates.iter().map(|el| el.iter()).flatten() {
        // The mv method will make sure we never move the head farther than one space. This is just
        // a safeguard for errors in the code.
        get_mut(&amp;mut rope, 0)?.mv(&amp;update)?;
        // Remember only the position of the reference vector, which is the head so far. That
        // involves a clone.
        let mut ref_vec = *get(&amp;rope, 0)?;

        // Update all others with reference to their previous entry.
        for knot in rope.iter_mut() {
            // Move the knot with respect to the reference knot, which is always the previous one.
            *knot = knot.add(&amp;ref_vec.get_tail_update(&amp;knot));
            // Update the reference knot's position. Because we can only ever borrow one element as
            // mutable in rust and once we did so, we cannot borrow anything else, we clone it
            // here. That's inefficient but I couldn't find an easy way around it without resorting
            // to `unsafe`, which I want to avoid. Sadly, it seems as if `split_at_mut` involves
            // `unsafe`.
            ref_vec = *knot;
        }
        visited_by_tail.insert(tail(&amp;rope)?);
    }

    println!(
        "the tail visited {} unique spots for a rope of length {}",
        visited_by_tail.len(),
        rope.len(),
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Part 1.
    solve(SAMPLE1, 0)?;
    solve(SAMPLE2, 0)?;
    solve(REAL, 0)?;

    // Part 2.
    solve(SAMPLE1, 8)?;
    solve(SAMPLE2, 8)?;
    solve(REAL, 8)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug, Clone, Hash, PartialEq, Eq, Copy)]
pub struct Vec {
    x: i64,
    y: i64,
}

pub const NULL_VEC: Vec = Vec { x: 0, y: 0 };

impl FromStr for Vec {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s
            .split_whitespace()
            .collect::&lt;std::vec::Vec&lt;_&gt;&gt;()
            .as_slice()
        {
            ["R", dist] =&gt; Ok(Self {
                x: dist.parse()?,
                y: 0,
            }),
            ["L", dist] =&gt; Ok(Self {
                x: -dist.parse()?,
                y: 0,
            }),
            ["U", dist] =&gt; Ok(Self {
                x: 0,
                y: dist.parse()?,
            }),
            ["D", dist] =&gt; Ok(Self {
                x: 0,
                y: -dist.parse()?,
            }),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as vector", s))),
        }
    }
}

impl Vec {
    pub fn add(&amp;self, other: &amp;Vec) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    // Length in infinity metric.
    fn infinity_len(&amp;self) -&gt; usize {
        self.x.abs() as usize + self.y.abs() as usize
    }

    fn is_infinity_unit(&amp;self) -&gt; bool {
        self.infinity_len() == 1
    }

    // Map to the 2d unit sphere in manhattan metric. The null vector cannot be mapped and, thus,
    // remains unchanged.
    fn as_manhattan_unit(&amp;self) -&gt; Self {
        Self {
            x: self.x.clamp(-1, 1),
            y: self.y.clamp(-1, 1),
        }
    }

    // Move the vector exactly one space along one direction.
    pub fn mv(&amp;mut self, other: &amp;Vec) -&gt; Result&lt;()&gt; {
        if other.is_infinity_unit() {
            *self = self.add(other);
            Ok(())
        } else {
            Err(Error::msg(format!("cannot move by {:?}", other)))
        }
    }

    // Provide an iterator over unit-sized steps (unit in manhattan metric not infinity metric)
    // that, if followed, describes the same distance traveled as `self`.
    pub fn iter(&amp;self) -&gt; std::vec::IntoIter&lt;Self&gt; {
        let unit = self.as_manhattan_unit();
        let mut pos = self.as_manhattan_unit();
        // As this is my second time working with a custom iterator, I was not sure how to avoid
        // cloning here.
        let mut disps = vec![];
        while &amp;pos != self {
            let new_pos = pos.add(&amp;unit);
            disps.push(unit);
            pos = new_pos;
        }
        disps.push(unit);

        disps.into_iter()
    }

    pub fn get_tail_update(&amp;self, other: &amp;Self) -&gt; Self {
        let diff = Self {
            x: self.x - other.x,
            y: self.y - other.y,
        };

        // We want to update with a unit vector in manhattan metric, but only if that would not
        // mean that `other` is on the same space as `self`.
        if &amp;other.add(&amp;diff.as_manhattan_unit()) == self {
            NULL_VEC
        } else {
            diff.as_manhattan_unit()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_9"><a class="anchor" href="#_how_to_run_9"></a><a class="link" href="#_how_to_run_9">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_rust"><a class="anchor" href="#_day_10_rust"></a><a class="link" href="#_day_10_rust">Day 10: rust</a></h3>
<div class="sect3">
<h4 id="_day_10_cathode_ray_tube"><a class="anchor" href="#_day_10_cathode_ray_tube"></a><a class="link" href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_8"><a class="anchor" href="#_oveview_8"></a><a class="link" href="#_oveview_8">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_9"><a class="anchor" href="#_solution_9"></a><a class="link" href="#_solution_9">Solution</a></h5>
<div class="paragraph">
<p>It&#8217;s getting really interesting now.
I quite liked how part 2 didn&#8217;t require you to compute a number or a sequence of
letters but instead required you to render something on screen.
My solution is less nice, but there is not much time on the weekend.</p>
</div>
<div class="paragraph">
<p>Quite early on, I decided to ignore all the weirdness due to a noop taking one
cycle an an addition taking two cycles.
Instead, I moved to a parallel world where each instruction took exactly one
cycle, which meant replacing each 2-cycle addition by a noop followed by a
1-cycle addition.
So far so straightforward.</p>
</div>
<div class="paragraph">
<p>Furthermore, I ignored all the weirdness due to what is at the beginning,
during, or at the end of a cycle, but instead only looked at the register during
each cycle.
I also had my 1-cycle addition act during its cycle instead of at the cycle&#8217;s
end.
I also started cycle counting at 0 instead of 1.</p>
</div>
<div class="paragraph">
<p>To map the register value during a cycle from my ficticious world back to the
world of the puzzle, I only had to add 2 to the cycle count.
That also means my world had no real cycle one, which meant I had to treat that
one separately for part 2.
For part one, in order to look at the value during cycle 20, I had to skip only
the first 18 entries.</p>
</div>
<div class="paragraph">
<p>Today, I learnt that rust really will panic if you try to subtract 1 from an
unsigned value that is 0.
And off-by-one errors really are the two worst types of bugs that plague
software development.
I also played around with closures that move values into them for the first
time.
They are quite useful!</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::Result;
// Constants.
const WIDTH: usize = 40;

fn render(crt: &amp;Vec&lt;bool&gt;, width: usize, fill: char) -&gt; String {
    crt.iter()
        .enumerate()
        .map(|(idx, el)| {
            let ch = if *el { '#' } else { fill };
            if (idx + 1) % width == 0 {
                format!("{}\n", ch)
            } else {
                ch.to_string()
            }
        })
        .collect::&lt;String&gt;()
}

fn maybe_draw(crt: &amp;mut Vec&lt;bool&gt;, reg: isize, cycle: usize, width: usize) {
    let pixel_idx = cycle - 1;
    let horizontal_pos = (pixel_idx % width) as isize;

    // Used to avoid drawing past the edges. It turns out the register value is nice and those
    // checks would not have been needed.
    let sprite_at_left_edge = reg == 0;
    let sprite_at_right_edge = reg == width as isize - 1;

    if reg == horizontal_pos {
        crt[pixel_idx] = true;
    } else if reg + 1 == horizontal_pos &amp;&amp; !sprite_at_right_edge {
        crt[pixel_idx] = true;
    } else if reg - 1 == horizontal_pos &amp;&amp; !sprite_at_left_edge {
        crt[pixel_idx] = true;
    }
}

// This function likely performs a lot of allocations that are not needed but it makes the rest of
// the problem so much easier to solve.
fn extend(input: Vec&lt;data::Op&gt;) -&gt; Vec&lt;data::Op&gt; {
    input
        .into_iter()
        .map(|el| match el {
            data::Op::None =&gt; vec![data::Op::None].into_iter(),
            data::Op::Some(_) =&gt; vec![data::Op::None, el].into_iter(),
        })
        .flatten()
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

fn solve(file: &amp;str, part1: bool, fill: char) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let ops =
        io::parse_chunks_to_data::&lt;data::Op&gt;(io::read_lines_from_file(file, 1)?, "op", None, None)?;

    // We avoid that one-cycle-two-cycle weridness by replacing each addx operation by a noop and
    // an addx operation that is assumed to take only one cycle.
    let extended_ops = extend(ops);

    let mut reg = 1;
    let reg_vals = extended_ops.into_iter().map(move |el| {
        reg += match el {
            data::Op::None =&gt; 0,
            data::Op::Some(val) =&gt; val,
        };
        reg
    });

    if part1 {
        // There is a lot of potential for off-by-one errors in this one.
        //
        // We skip the first 18 entries here because we want to start with the value during cycle
        // 20, which is the value after cycle 19, and this solution ignores what happens during the
        // first cycle, because that is trivial.
        let skip = 18;
        let mut skipper: isize = -1;
        let interesting = reg_vals
            .skip(skip)
            .enumerate()
            .filter_map(move |(step, reg)| {
                // Now convert from our weird way of counting to that of the puzzle.
                // We wanted to skip the first 19 cycles (add skip + 1) and cycle counting starts
                // at one (add 1).
                let current_cycle = step + 1 + skip + 1;
                skipper += 1;
                if skipper % 40 == 0 {
                    Some(reg * current_cycle as isize)
                } else {
                    None
                }
            })
            .sum::&lt;isize&gt;();

        println!("{:?}", interesting);
    } else {
        let mut crt = vec![false; WIDTH * 6];

        // We need to handle the first cycle separately because the cycle number used here is
        // always that of the cycle we are in. During the first cycle, the register has a value of
        // 1.
        maybe_draw(&amp;mut crt, 1, 1, WIDTH);

        // Here, current_cycle is the cycle we are currently in. Thus, the number is one larger
        // than what the example shows because the example usually taks about the value after a
        // cycle but the value during a cycle is important. This also erroneously assumes the
        // existence 241'th cycle, but that's not really a problem because the value after the
        // 240'th cycle is the value during the 241th cycle, so it's consistent.
        for (current_cycle, reg) in reg_vals.enumerate().map(|(step, el)| (step + 2, el)) {
            maybe_draw(&amp;mut crt, reg, current_cycle, WIDTH);
        }
        println!("\n{}\n", render(&amp;crt, WIDTH, fill));
    }

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Part 1.
    // The last argument is not important here.
    solve(SAMPLE1, true, '.')?;
    solve(SAMPLE2, true, '.')?;
    solve(REAL, true, '.')?;

    // Part 2.
    solve(SAMPLE2, false, '.')?;
    // Use a space as filler for the real solution to make the letters easier to read.
    solve(REAL, false, ' ')?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug, Clone, Hash, PartialEq, Eq, Copy)]
pub enum Op {
    None,
    Some(isize),
}

impl FromStr for Op {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s
            .split_whitespace()
            .collect::&lt;std::vec::Vec&lt;_&gt;&gt;()
            .as_slice()
        {
            ["noop"] =&gt; Ok(Self::None),
            ["addx", val] =&gt; Ok(Self::Some(val.parse()?)),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as op", s))),
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_10"><a class="anchor" href="#_how_to_run_10"></a><a class="link" href="#_how_to_run_10">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day11" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_11_rust"><a class="anchor" href="#_day_11_rust"></a><a class="link" href="#_day_11_rust">Day 11: rust</a></h3>
<div class="sect3">
<h4 id="_day_11_monkey_in_the_middle"><a class="anchor" href="#_day_11_monkey_in_the_middle"></a><a class="link" href="#_day_11_monkey_in_the_middle">Day 11: Monkey in the Middle</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_9"><a class="anchor" href="#_oveview_9"></a><a class="link" href="#_oveview_9">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_10"><a class="anchor" href="#_solution_10"></a><a class="link" href="#_solution_10">Solution</a></h5>
<div class="paragraph">
<p>No time to write much.
The code has comments that should explain the solution.
In part 1, you simply have to code what the task says.
In part 2, the realisation helps that you can display any number as <code>c=n*p+m</code> with
<code>n</code> being a natural number.
Then, you can subtract as many multiples of <code>p</code> from <code>c</code> and not change
divisibility conditions, especially since all <code>p</code> are prime numbers here.
If you pick <code>p</code> to the the product of all unique prime numbers against which
divisibility is being checked, you can keep your numbers small.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::Result;
use std::collections::HashSet;
// Constants.

fn solve(file: &amp;str, part1: bool) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let mut monkeys = io::parse_chunks_to_data::&lt;data::Monkey&gt;(
        io::read_lines_from_file(file, 7)?,
        "monkey",
        None,
        None,
    )?;

    let prod_of_div_vals = monkeys
        .iter()
        .map(|el| el.get_div())
        .collect::&lt;HashSet&lt;_&gt;&gt;()
        .into_iter()
        .product::&lt;isize&gt;();

    if !part1 {
        for monkey in &amp;mut monkeys {
            monkey.set_all_divs(prod_of_div_vals);
        }
    }

    let rounds = if part1 { 20 } else { 10_000 };

    for _round in 0..rounds {
        for monkey_idx in 0..monkeys.len() {
            // println!("check: {:?}", monkeys[monkey_idx]);
            for (target, item) in monkeys[monkey_idx].inspect_and_toss().into_iter() {
                monkeys[target].catch(item);
                // println!("toss:  {:?} &lt;- {}", monkeys[target], item);
            }
            // println!("\n")
        }
    }

    monkeys.sort_by(|monkey1, monkey2| monkey1.how_active().cmp(&amp;monkey2.how_active()));
    monkeys.reverse();

    println!(
        "most active: {} &amp; {}",
        monkeys[0].whoami(),
        monkeys[1].whoami(),
    );
    println!(
        "monkey business is {}",
        monkeys[0].how_active() * monkeys[1].how_active()
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1, true)?;
    solve(REAL, true)?;

    solve(SAMPLE1, false)?;
    solve(REAL, false)?;
    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Context, Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Monkey {
    idx: usize,
    activity: usize,
    items: Vec&lt;isize&gt;,
    op: QuadraticOp,
    test: DivisitilibytTest,
}

impl Monkey {
    pub fn inspect_and_toss(&amp;mut self) -&gt; Vec&lt;(usize, isize)&gt; {
        let result = self
            .items
            .iter()
            .map(|item_val| {
                self.activity += 1;
                let new_item_val = self.op.apply(item_val);
                (self.test.which_monkey(&amp;new_item_val), new_item_val)
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        self.items = vec![];

        result
    }

    pub fn catch(&amp;mut self, item: isize) {
        self.items.push(item);
    }

    pub fn whoami(&amp;self) -&gt; usize {
        self.idx
    }

    pub fn how_active(&amp;self) -&gt; usize {
        self.activity
    }

    pub fn set_all_divs(&amp;mut self, prod: isize) {
        self.op.prod = Some(prod);
    }

    pub fn get_div(&amp;self) -&gt; isize {
        self.test.div_val
    }
}

// All operations can be realised as a*x^2 + b*x + c
#[derive(Debug)]
struct QuadraticOp {
    a: isize,
    b: isize,
    c: isize,
    prod: Option&lt;isize&gt;,
}

impl QuadraticOp {
    fn apply(&amp;self, val: &amp;isize) -&gt; isize {
        if let Some(prod) = self.prod {
            // We update our worry level but don't divide by anything. Instead, to keep the numbers
            // small and avoid weirdness due to divisibility checks, we take the modulo with
            // respect to the product of all unique divisibility checks. Doing so never influences
            // any of the divisibility checks.
            (self.a * val * val + self.b * val + self.c) % prod
        } else {
            // We update our worry level but always divide by 3 in the end. This is for part 1.
            (self.a * val * val + self.b * val + self.c) / 3
        }
    }
}

#[derive(Debug)]
struct DivisitilibytTest {
    div_val: isize,
    true_monkey: usize,
    false_monkey: usize,
}

impl DivisitilibytTest {
    fn which_monkey(&amp;self, val: &amp;isize) -&gt; usize {
        if val % self.div_val == 0 {
            self.true_monkey
        } else {
            self.false_monkey
        }
    }
}

// This one is not pretty but it works and correctly reports errors. More context can always be
// added if there are unexpected errors.
impl FromStr for Monkey {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let lines = s
            .split("\n")
            .map(|el| el.trim())
            .collect::&lt;std::vec::Vec&lt;_&gt;&gt;();

        let idx = if let ["Monkey", idx_str] =
            lines[0].split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice()
        {
            idx_str.trim_end_matches(":").parse().context("monkey id")?
        } else {
            return Err(Error::msg("canot find monkey id string"));
        };

        let maybe_items = if let ["Starting items", items_str] =
            lines[1].split(":").collect::&lt;Vec&lt;_&gt;&gt;().as_slice()
        {
            items_str
                .split(", ")
                .map(|el| el.trim().parse::&lt;isize&gt;())
                .collect::&lt;Vec&lt;_&gt;&gt;()
        } else {
            return Err(Error::msg("canot find items line"));
        };

        if maybe_items
            .iter()
            .any(|el| if let Err(_) = el { true } else { false })
        {
            return Err(Error::msg("cannot parse items line"));
        }

        // The next line can never panic.
        let items = maybe_items
            .into_iter()
            .map(|el| el.unwrap())
            .collect::&lt;Vec&lt;_&gt;&gt;();

        let op = if let ["Operation: new ", op_str] =
            lines[2].split("=").collect::&lt;Vec&lt;_&gt;&gt;().as_slice()
        {
            match op_str.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
                ["old", "*", "old"] =&gt; Ok(QuadraticOp {
                    a: 1,
                    b: 0,
                    c: 0,
                    prod: None,
                }),
                ["old", "*", num] =&gt; Ok(QuadraticOp {
                    a: 0,
                    b: num.parse().context("multiplier")?,
                    c: 0,
                    prod: None,
                }),
                ["old", "+", num] =&gt; Ok(QuadraticOp {
                    a: 0,
                    b: 1,
                    c: num.parse().context("adder")?,
                    prod: None,
                }),
                _ =&gt; Err(Error::msg("cannot build op")),
            }
        } else {
            return Err(Error::msg("cannot find operations line"));
        }
        .context("operation")?;

        let div_val = if let ["Test:", "divisible", "by", val] =
            lines[3].split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice()
        {
            val.parse().context("divisibility")?
        } else {
            return Err(Error::msg("cannot find divisibility line"));
        };

        let true_monkey = if let ["If", "true:", "throw", "to", "monkey", val] =
            lines[4].split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice()
        {
            val.parse().context("true monkey")?
        } else {
            return Err(Error::msg("cannot find true monkey line"));
        };

        let false_monkey = if let ["If", "false:", "throw", "to", "monkey", val] =
            lines[5].split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice()
        {
            val.parse().context("false monkey")?
        } else {
            return Err(Error::msg("cannot find false monkey line"));
        };

        if idx == true_monkey || idx == false_monkey {
            return Err(Error::msg("trying to toss to myself"));
        }

        if !is_prime(div_val) {
            return Err(Error::msg("div val is no prime"));
        }

        let test = DivisitilibytTest {
            div_val,
            true_monkey,
            false_monkey,
        };

        let activity = 0;

        Ok(Self {
            idx,
            activity,
            items,
            op,
            test,
        })
    }
}

// This is a quick check for being prime.
fn is_prime(val: isize) -&gt; bool {
    for i in 2..val {
        if val % i == 0 {
            return false;
        }
    }
    true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_11"><a class="anchor" href="#_how_to_run_11"></a><a class="link" href="#_how_to_run_11">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day12" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_12_rust"><a class="anchor" href="#_day_12_rust"></a><a class="link" href="#_day_12_rust">Day 12: rust</a></h3>
<div class="sect3">
<h4 id="_day_12_hill_climbing_algorithm"><a class="anchor" href="#_day_12_hill_climbing_algorithm"></a><a class="link" href="#_day_12_hill_climbing_algorithm">Day 12: Hill Climbing Algorithm</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_10"><a class="anchor" href="#_oveview_10"></a><a class="link" href="#_oveview_10">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_11"><a class="anchor" href="#_solution_11"></a><a class="link" href="#_solution_11">Solution</a></h5>
<div class="paragraph">
<p>No time to write much.
This might be the most complex puzzle this year so far.</p>
</div>
<div class="paragraph">
<p>Part 1 can be solved by implementing <code>A*</code> on a directed acyclic graph where each
step has unit cost.
Then, have it search for the path from start to finish, making sure to have a
sane heuristic.</p>
</div>
<div class="paragraph">
<p>With a directed acyclic graph, part 2 can be solved very easily by adding a new,
virtual node and connecting it to all nodes of height <code>a</code>.
Then, search for the shortest path from that virtual node to the end and
subtract 1 from the length of the path (the virtual node).</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
// Constants.

fn build_graph(map: &amp;HashMap&lt;data::Point, data::Height&gt;) -&gt; HashSet&lt;data::Node&gt; {
    map.iter()
        .map(|(&amp;p, &amp;h)| {
            let neighbours = p
                .env()
                .into_iter()
                .filter_map(|el| match map.get(&amp;el) {
                    Some(other_h) =&gt; {
                        if other_h.height() &lt;= h.height() + 1 {
                            Some(el)
                        } else {
                            None
                        }
                    }
                    None =&gt; None,
                })
                .collect::&lt;HashSet&lt;_&gt;&gt;();
            data::Node::new(p, h, neighbours)
        })
        .collect::&lt;HashSet&lt;data::Node&gt;&gt;()
}

fn find_path&lt;'a&gt;(
    start: &amp;'a data::Node,
    end: &amp;'a data::Node,
    graph: &amp;'a HashSet&lt;data::Node&gt;,
    estimator_fn: fn(&amp;data::Node, &amp;data::Point) -&gt; usize,
) -&gt; Result&lt;HashMap&lt;&amp;'a data::Node, (Option&lt;data::Point&gt;, usize)&gt;&gt; {
    let ref_point = end.pos();
    let estimator = move |node: &amp;data::Node| estimator_fn(node, &amp;ref_point);
    let get_node = move |node: &amp;data::Point| {
        graph
            .get(&amp;node.as_node())
            .ok_or(Error::msg(format!("cannot get node {:?}", node)))
    };

    let mut connections = HashMap::&lt;&amp;'a data::Node, (Option&lt;data::Point&gt;, usize)&gt;::new();
    let mut checkable = HashMap::&lt;&amp;data::Node, (data::Point, usize)&gt;::new();

    // Add starting point to resulting path.
    connections.insert(&amp;start, (None, 0));
    // Add neighbours of starting point to list of checkable values.
    for neigh in start.neighbours() {
        let neigh_node = get_node(neigh)?;
        // Estimated costs are the most direct possible connection plus 1, since every step costs
        // one.
        checkable.insert(neigh_node, (start.pos(), estimator(neigh_node)));
        // connections.insert(neigh_node, (Some(start.pos()), 1));
    }

    // Search until we added the final node to the path or until there is nothing more to check.
    while !connections.contains_key(&amp;end) &amp;&amp; checkable.len() &gt; 0 {
        // Get node with minimum _estimated_ cost.
        let next_best_node = checkable
            .iter_mut()
            // Get node with minimum estimated cost.
            .min_by(|(_node1, (_pre1, cost1)), (_node2, (_pre2, cost2))| cost1.cmp(&amp;cost2))
            .ok_or(Error::msg("cannot find next node"))?
            .0
            .clone();
        let (_, (predecessor, _old_estimate)) = checkable
            .remove_entry(next_best_node)
            .ok_or(Error::msg("cannot find predecessor"))?;

        let cost_of_predecessor = connections
            .get(&amp;predecessor.as_node())
            .ok_or(Error::msg("predecessor has not been visited"))?
            .1;

        // Add point to resulting path.
        connections.insert(next_best_node, (Some(predecessor), cost_of_predecessor + 1));

        // Add neighbours of point to list of checkable values.
        for neigh in next_best_node.neighbours() {
            let neigh_node = get_node(neigh)?;
            if !connections.contains_key(neigh_node) {
                let estimate = cost_of_predecessor + estimator(neigh_node);
                let previous_best = checkable
                    .get(neigh_node)
                    .unwrap_or(&amp;(*neigh, std::usize::MAX))
                    .1;
                if previous_best &gt; estimate {
                    checkable.insert(neigh_node, (next_best_node.pos(), estimate));
                }
                // connections.insert(neigh_node, Some(start.pos()));
            }
        }
    }

    Ok(connections)
}

fn extract_shortest_path&lt;'a&gt;(
    end: &amp;'a data::Node,
    points: HashMap&lt;&amp;'a data::Node, (Option&lt;data::Point&gt;, usize)&gt;,
    graph: &amp;'a HashSet&lt;data::Node&gt;,
) -&gt; Result&lt;Vec&lt;&amp;'a data::Node&gt;&gt; {
    let mut path = vec![end];

    let mut check_node = end;
    while let Some((Some(pre), _)) = points.get(check_node) {
        let node = graph
            .get(&amp;pre.as_node())
            .ok_or(Error::msg("cannot find node in graph"))?;
        path.push(node);
        check_node = node;
    }

    Ok(path)
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let height_map = io::parse_chars_to_data::&lt;data::Height&gt;(file, "vec")?;

    // Create graph. To avoid self-referencing data types, we identify each node only by its
    // position.
    let mut graph = build_graph(&amp;height_map);

    // Find start and end nodes. Also adjust heights to use actual values. This is a bit of a pain
    // in rust...
    let mut start_node = graph
        .iter()
        .find(|&amp;el| el.get_height() == data::Height::Start)
        .ok_or(Error::msg("cannot find start node"))?
        .clone();
    start_node.set_height(data::Height::Normal(0));
    graph
        .replace(start_node.clone())
        .ok_or(Error::msg("cannot replace end node"))?;

    let mut end_node = graph
        .iter()
        .find(|&amp;el| el.get_height() == data::Height::End)
        .ok_or(Error::msg("cannot find end node"))?
        .clone();
    end_node.set_height(data::Height::Normal(25));
    graph
        .replace(end_node.clone())
        .ok_or(Error::msg("cannot replace end node"))?;

    let estimator = |node: &amp;data::Node, ref_point: &amp;data::Point| node.infinity_dist(&amp;ref_point);

    let path = find_path(&amp;start_node, &amp;end_node, &amp;graph, estimator)
        .map(|el| extract_shortest_path(&amp;end_node, el, &amp;graph))??;

    println!("part 1: {}", path.len() - 1);

    // Part 2.
    // Add an additional node at a position that hadn't yet been part of the graph and connect it
    // to all nodes of zero elevation.
    let possible_starts = graph
        .iter()
        .filter(|node| node.get_height().height() == 0)
        .map(|node| node.pos())
        .collect::&lt;HashSet&lt;_&gt;&gt;();

    let far_away_fake_node = data::Node::new(
        data::Point { x: -10, y: -10 },
        data::Height::Normal(0),
        possible_starts,
    );

    if !graph.insert(far_away_fake_node) {
        return Err(Error::msg(
            "refusing to overwrite existing node for fake nod",
        ));
    }

    let path2 = find_path(&amp;start_node, &amp;end_node, &amp;graph, estimator)
        .map(|el| extract_shortest_path(&amp;end_node, el, &amp;graph))??;

    // We have to ignore the first two steps here because of the real and fake start nodes.
    println!("part 2: {}", path2.len() - 2);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1)?;
    solve(REAL)?;
    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::str::FromStr;

#[derive(Debug, Hash, Eq, PartialEq, Copy, Clone)]
pub struct Point {
    pub x: isize,
    pub y: isize,
}

impl Point {
    pub fn new(x: isize, y: isize) -&gt; Self {
        Self { x, y }
    }

    pub fn env(&amp;self) -&gt; Vec&lt;Self&gt; {
        vec![
            Self {
                x: self.x - 1,
                y: self.y,
            },
            Self {
                x: self.x + 1,
                y: self.y,
            },
            Self {
                x: self.x,
                y: self.y - 1,
            },
            Self {
                x: self.x,
                y: self.y + 1,
            },
        ]
    }

    pub fn as_node(&amp;self) -&gt; Node {
        Node {
            p: *self,
            h: Height::End,
            neighbours: HashSet::&lt;Point&gt;::new(),
        }
    }
}

#[derive(Copy, Clone, Debug, Hash, PartialEq)]
pub enum Height {
    Normal(usize),
    Start,
    End,
}

impl Height {
    pub fn height(&amp;self) -&gt; usize {
        match self {
            &amp;Self::End =&gt; 25,
            &amp;Self::Start =&gt; 0,
            &amp;Self::Normal(val) =&gt; val,
        }
    }
}

// This one is not pretty but it works and correctly reports errors. More context can always be
// added if there are unexpected errors.
impl FromStr for Height {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        if s.len() == 1 {
            Ok(match s {
                "S" =&gt; Self::Start,
                "E" =&gt; Self::End,
                // The next line can never panic.
                _ =&gt; Self::Normal(s.chars().next().unwrap() as usize - 'a' as usize),
            })
        } else {
            Err(Error::msg("received several characters or none"))
        }
    }
}

#[derive(Debug, Clone)]
pub struct Node {
    p: Point,
    h: Height,
    neighbours: HashSet&lt;Point&gt;,
}

impl Node {
    pub fn pos(&amp;self) -&gt; Point {
        self.p
    }

    pub fn neighbours&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a HashSet&lt;Point&gt; {
        &amp;self.neighbours
    }

    pub fn new(p: Point, h: Height, neighbours: HashSet&lt;Point&gt;) -&gt; Self {
        Self { p, h, neighbours }
    }

    pub fn get_height(&amp;self) -&gt; Height {
        self.h
    }

    pub fn set_height(&amp;mut self, height: Height) {
        self.h = height;
    }

    pub fn infinity_dist(&amp;self, other: &amp;Point) -&gt; usize {
        ((self.p.x - other.x).abs() + (self.p.y - other.y).abs()) as usize
    }
}

// We identify a node only by its position and never by its associated height.
impl Hash for Node {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.p.hash(state)
    }
}

impl PartialEq for Node {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.p == other.p
    }
}
impl Eq for Node {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_12"><a class="anchor" href="#_how_to_run_12"></a><a class="link" href="#_how_to_run_12">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day13" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_13_rust"><a class="anchor" href="#_day_13_rust"></a><a class="link" href="#_day_13_rust">Day 13: rust</a></h3>
<div class="sect3">
<h4 id="_day_13_distress_signal"><a class="anchor" href="#_day_13_distress_signal"></a><a class="link" href="#_day_13_distress_signal">Day 13: Distress Signal</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_11"><a class="anchor" href="#_oveview_11"></a><a class="link" href="#_oveview_11">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_12"><a class="anchor" href="#_solution_12"></a><a class="link" href="#_solution_12">Solution</a></h5>
<div class="paragraph">
<p>Input parsing was a pain.
The idea I used is to split each package at the given commas, but to only use
those commas that are at the correct nesting level.
Then, the parser is called again for each individual entry.
Special care has to be taken since there are empty lists, too.</p>
</div>
<div class="paragraph">
<p>This time, I did not try to get around self-referencing data types, which means
I got to use <code>Box&lt;T&gt;</code> for the first time.
It was nicer than expected.
It&#8217;s good to know that Rust will ensure memory safety also for data on the heap.</p>
</div>
<div class="paragraph">
<p>Part 1 was straightforward once the inputs had been parsed.
Luckily, I had decided to create <code>compare</code> methods for each separate data type
(<code>Pkg</code> and <code>Elem</code>) that returned a triplet indicating the ordering.
Thus, in part 2, I could use the very same comparison methods to have Rust sort
the vector of packges.</p>
</div>
<div class="paragraph">
<p>In order to find out the indices of the divider packages but avoid implementing
a comparison operation for packages, I sorted a vector of tuples that contained
a package and a marker.
Once sorted, I could just retrieve the indices of the markers.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let pairs = io::parse_chunks_to_data::&lt;data::Input&gt;(
        io::read_lines_from_file(file, 3)?,
        "package",
        None,
        None,
    )?;

    // Part 1.
    let ordered_correctly = pairs
        .iter()
        .enumerate()
        .filter_map(|(idx, el)| {
            if el.is_ordered_correctly() {
                Some(idx + 1)
            } else {
                None
            }
        })
        .sum::&lt;usize&gt;();

    println!("correctly ordered: {}", ordered_correctly);

    // Part 2.
    // Create divider packages. We wrote a parser so we might as well use it for easy creation of
    // the divider packages.
    let div1 = "[[2]]".parse::&lt;data::Pkg&gt;()?;
    let div2 = "[[6]]".parse::&lt;data::Pkg&gt;()?;

    // A value of "true" means this package is a marker.
    let mut all_pkgs = vec![(true, &amp;div1), (true, &amp;div2)];
    all_pkgs.extend(
        pairs
            .iter()
            .map(|el| vec![(false, &amp;el.left), (false, &amp;el.right)].into_iter())
            .flatten(),
    );

    // Sort using the comparison method created for part 1.
    all_pkgs.sort_by(|(_marker1, pkg1), (_marker2, pkg2)| pkg1.compare(pkg2));

    let decoder_key = all_pkgs
        .iter()
        .enumerate()
        .filter(|(_idx, (marker, _pkg))| *marker)
        .map(|(idx, (_marker, _pkg))| idx + 1)
        .product::&lt;usize&gt;();

    println!("decoder key is {}", decoder_key);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::cmp::Ordering;
use std::str::FromStr;

#[derive(Debug)]
pub struct Input {
    pub left: Pkg,
    pub right: Pkg,
}

#[derive(Debug)]
pub struct Pkg(Vec&lt;Elem&gt;);

#[derive(Debug)]
pub enum Elem {
    Num(isize),
    Dat(Box&lt;Pkg&gt;),
}

impl Input {
    pub fn is_ordered_correctly(&amp;self) -&gt; bool {
        self.left.compare(&amp;self.right) == Ordering::Less
    }
}

impl Pkg {
    // This is run on the left value with the right value as argument.
    pub fn compare(&amp;self, other: &amp;Self) -&gt; Ordering {
        // The zip operator will end the iteration as soon as one of the two iterators runs out.
        for (left, right) in self.0.iter().zip(other.0.iter()) {
            match left.compare(&amp;right) {
                Ordering::Equal =&gt; {}
                ord @ Ordering::Less | ord @ Ordering::Greater =&gt; return ord,
            }
        }

        // If we reach here, all value comparisons turned out equal so far. Thus, perform the
        // length comparison.
        self.0.len().cmp(&amp;other.0.len())
    }
}

impl Elem {
    fn compare(&amp;self, other: &amp;Self) -&gt; Ordering {
        match (self, other) {
            // If both are numbers, compare the numbers.
            (&amp;Elem::Num(left), &amp;Elem::Num(right)) =&gt; left.cmp(&amp;right),
            // If both are lists, compare the lists.
            (&amp;Elem::Dat(ref left), &amp;Elem::Dat(ref right)) =&gt; left.compare(&amp;right),
            // If one is a number and the other one is a list, wrap the number in the list and
            // comapre again.
            (&amp;Elem::Num(left), &amp;Elem::Dat(ref right)) =&gt; Pkg(vec![Elem::Num(left)]).compare(&amp;right),
            (&amp;Elem::Dat(ref left), &amp;Elem::Num(right)) =&gt; left.compare(&amp;Pkg(vec![Elem::Num(right)])),
        }
    }
}

impl FromStr for Input {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let mut lines = s.split("\n");
        let left = lines
            .next()
            .ok_or(Error::msg("cannot find left line"))?
            .parse::&lt;Pkg&gt;()?;
        let right = lines
            .next()
            .ok_or(Error::msg("cannot find right line"))?
            .parse::&lt;Pkg&gt;()?;

        Ok(Self { left, right })
    }
}

// This one is not pretty but it works and correctly reports errors.
impl FromStr for Pkg {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let mut nesting_level: usize = 0;
        let mut chars = String::new();

        if !s.starts_with("[") || !s.ends_with("]") {
            return Err(Error::msg("string is no real package"));
        }

        let mut elems_at_level = vec![];

        // Skip the opening bracket and extract all elements at this level of the hierarchy. This
        // is not pretty but seems to work.
        for char in s[1..s.len()].chars() {
            let val = match char {
                '[' =&gt; {
                    // Since we skip the very first "[", this indicates the start of a nested list.
                    chars.push(char);
                    nesting_level += 1;
                    None
                }
                ']' =&gt; {
                    if nesting_level == 0 {
                        // Emit what we found so far. This will be the very last element. We use
                        // this closing bracket to ensure we do emit the very last value.
                        let result = chars;
                        chars = String::new();
                        Some(result)
                    } else {
                        // We found the end of a nested list. Remember the current character.
                        chars.push(char);
                        nesting_level -= 1;
                        None
                    }
                }
                ',' =&gt; {
                    if nesting_level == 0 {
                        // Emit one value. This is one element of the list at this level.
                        let result = chars;
                        chars = String::new();
                        Some(result)
                    } else {
                        // We are still not at the top nesting level.
                        chars.push(char);
                        None
                    }
                }
                _ =&gt; {
                    // Remember all other characters.
                    chars.push(char);
                    None
                }
            };

            if let Some(entry) = val {
                elems_at_level.push(entry);
            }
        }

        // Parse all entries at this level of the hierarchy into "Elem"s. Errors are being handled
        // further down.
        let maybe_parsed_elems = elems_at_level
            .into_iter()
            .map(|el| el.parse::&lt;Elem&gt;())
            .collect::&lt;Vec&lt;_&gt;&gt;();

        let mut has_err = false;
        for el in &amp;maybe_parsed_elems {
            if let Err(err) = el {
                has_err = true;
                eprintln!("{:?}", err);
            }
        }

        if has_err {
            Err(Error::msg("cannot parse package"))
        } else {
            let parsed_elems = maybe_parsed_elems
                .into_iter()
                // This line can never panic.
                .map(|el| el.unwrap())
                .collect::&lt;Vec&lt;_&gt;&gt;();

            Ok(Self(parsed_elems))
        }
    }
}

impl FromStr for Elem {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        if s.len() == 0 {
            // Empty package.
            Ok(Self::Dat(Box::new(Pkg(vec![]))))
        } else if s.starts_with("[") {
            // This is itself a non-empty package.
            Ok(Self::Dat(Box::new(s.parse::&lt;Pkg&gt;()?)))
        } else {
            // Otherwise, this is a number.
            Ok(Self::Num(s.parse::&lt;isize&gt;()?))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_13"><a class="anchor" href="#_how_to_run_13"></a><a class="link" href="#_how_to_run_13">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day14" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_14_rust"><a class="anchor" href="#_day_14_rust"></a><a class="link" href="#_day_14_rust">Day 14: rust</a></h3>
<div class="sect3">
<h4 id="_day_14_regolith_reservoir"><a class="anchor" href="#_day_14_regolith_reservoir"></a><a class="link" href="#_day_14_regolith_reservoir">Day 14: Regolith Reservoir</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_12"><a class="anchor" href="#_oveview_12"></a><a class="link" href="#_oveview_12">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_13"><a class="anchor" href="#_solution_13"></a><a class="link" href="#_solution_13">Solution</a></h5>
<div class="paragraph">
<p>Today&#8217;s puzzle was rather straightforward.
Just follow each grain of sand on its way down.
I tracked positions of sand that settled via a <code>HashSet</code> to be able to check
whether a position has been occupied very easily.
For the rocks, I went a different route, though.
Expecting some twist in part 2 that would increase the size of the playing field
a lot, I did not fill the positions of rocks into an occupation map.
Instead, I remembered them as one-dimensional ranges and checked whether a point
was on that range.
I have no clue whether that provides better performance than using a set.</p>
</div>
<div class="paragraph">
<p>Today, I learned that the difference between a <code>cargo run</code> and a <code>cargo run
--release</code> in terms of runtime can be a factor of 55!</p>
</div>
<div class="paragraph">
<p>I also wrote a stepwise visualiser.
To use it, set the env var <code>RENDER</code> to <code>1</code> and select the part of the puzzle you
want to run with the env var <code>RUN</code>.
Set the env var <code>RUN</code> to 0, 1, 2, or 3 for the sample part 1, the real puzzle
part 1, the sample part 2, or the real puzzle part 2.
After printing the final resting place of one grain of sand, you have to hit
return to resume.
To get a nicely rendered view, pipe the output of <code>yes</code> into the executable.
Warning: This will tax your CPU quite significantly.
Only run in release more for <code>RUN==3</code>.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.
const SOURCE: data::Point = data::Point { x: 500, y: 0 };

fn is_blocked(
    p: &amp;data::Point,
    rocks: &amp;Vec&lt;data::Rocks&gt;,
    sands: &amp;HashSet&lt;data::Point&gt;,
    max_y: Option&lt;isize&gt;,
) -&gt; bool {
    if let Some(_) = sands.get(p) {
        true
    } else if let Some(bottom) = max_y &amp;&amp; p.y &gt;= bottom {
        true
    } else {
        rocks.iter().any(|el| el.contains(*p))
    }
}

fn render(
    rocks: &amp;Vec&lt;data::Rocks&gt;,
    sands: &amp;HashSet&lt;data::Point&gt;,
    fov: (isize, isize, isize, isize),
) -&gt; String {
    let dist = 10;
    let mut image = String::new();
    let empty = HashSet::&lt;data::Point&gt;::new();
    let min_y = if fov.1 - 4 &lt;= -2 { fov.1 - 2 } else { -2 };

    for y in min_y..fov.3 + 4 {
        for x in fov.0 - dist..fov.2 + dist {
            let p = data::Point { x, y };
            // This point is a rock.
            let char = if p == SOURCE {
                'S'
            } else if p.y == fov.3 + 2 {
                '#'
            } else if is_blocked(&amp;p, rocks, &amp;empty, None) {
                '#'
            // This point is sand.
            } else if is_blocked(&amp;p, rocks, sands, None) {
                '.'
            // This point is free.
            } else {
                ' '
            };
            image.push(char);
        }
        image.push('\n');
    }
    image
}

fn is_env(var: &amp;str, val: &amp;str, def: &amp;str) -&gt; bool {
    std::env::var(var).unwrap_or(def.to_string()) == val
}

fn solve(file: &amp;str, part1: bool) -&gt; Result&lt;()&gt; {
    println!("PROCESSING {}", file);

    // Read file and convert into data.
    let rocks = io::parse_chunks_to_data::&lt;data::Rocks&gt;(
        io::read_lines_from_file(file, 1)?,
        "rocks",
        None,
        None,
    )?;

    // Coordinates for rendering. This is just lazy copy-pasting.
    let min_x_rocks = rocks
        .iter()
        .map(|el| el.edges.iter())
        .flatten()
        .map(|el| el.x)
        .min()
        .ok_or(Error::msg("cannot find xmin"))?;
    let min_y_rocks = rocks
        .iter()
        .map(|el| el.edges.iter())
        .flatten()
        .map(|el| el.y)
        .min()
        .ok_or(Error::msg("cannot find ymin"))?;
    let max_x_rocks = rocks
        .iter()
        .map(|el| el.edges.iter())
        .flatten()
        .map(|el| el.x)
        .max()
        .ok_or(Error::msg("cannot find xmax"))?;
    let max_y_rocks = rocks
        .iter()
        .map(|el| el.edges.iter())
        .flatten()
        .map(|el| el.y)
        .max()
        .ok_or(Error::msg("cannot find ymax"))?;
    let render_coords = (min_x_rocks, min_y_rocks, max_x_rocks, max_y_rocks);
    let mut highest_y = SOURCE.y;

    let max_y = if part1 { max_y_rocks } else { max_y_rocks + 2 };

    let mut sands = HashSet::&lt;data::Point&gt;::new();

    let blocked_y = if part1 { None } else { Some(max_y) };

    let do_render = is_env("RENDER", "1", "0");

    // If this condition is no longer fulfilled, a piece of sand has exceeded our world and will
    // fall to infinity.
    loop {
        // Spawn new sand.
        if do_render {
            // Clear screen and print view.
            println!("\x1bc{}", render(&amp;rocks, &amp;sands, render_coords));
            // Only continue after the user confirmed.
            std::io::stdin().lines().next();
        }
        let mut sand = SOURCE;
        let mut has_settled = false;
        while !has_settled &amp;&amp; sand.y &lt;= max_y {
            // Find the highest point that contains either sand or is a rock.
            let mut next = sand.down();
            while !is_blocked(&amp;next, &amp;rocks, &amp;sands, blocked_y) &amp;&amp; sand.y &lt;= max_y {
                sand = next;
                next = sand.down()
            }
            // If we reach here, that piece of sand has hit an occupied tile on its way down.
            // We don't check again whether we exceeded our world because that will be checked the
            // nxt time we reach the top of the while loop.
            //
            // Check down to the left first.
            next = sand.left_down();
            if !is_blocked(&amp;next, &amp;rocks, &amp;sands, blocked_y) {
                sand = next;
                continue;
            }
            // Check down to the right next.
            next = sand.right_down();
            if !is_blocked(&amp;next, &amp;rocks, &amp;sands, blocked_y) {
                sand = next;
                continue;
            }
            has_settled = true;
            sands.insert(sand);
        }
        if sand.y &gt; highest_y {
            highest_y = sand.y;
        }
        if part1 {
            if highest_y &gt;= max_y {
                break;
            }
        } else {
            // Break if the source has been blocked.
            if let Some(_) = sands.get(&amp;SOURCE) {
                break;
            }
        }
    }

    let mut sorted = Vec::&lt;data::Point&gt;::from_iter(sands.into_iter());
    sorted.sort_by(|el1, el2| {
        let x_cmp = el1.x.cmp(&amp;el2.x);
        if x_cmp == std::cmp::Ordering::Equal {
            el1.y.cmp(&amp;el2.y)
        } else {
            x_cmp
        }
    });

    println!("amount of sand is {:?}", sorted.len());

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Run all by default or if a specific one was chosen. Useful for rendering just one.
    if is_env("RUN", "0", "0") {
        solve(SAMPLE1, true)?;
    }
    if is_env("RUN", "1", "1") {
        solve(REAL, true)?;
    }

    if is_env("RUN", "2", "2") {
        solve(SAMPLE1, false)?;
    }
    if is_env("RUN", "3", "3") {
        solve(REAL, false)?;
    }

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::hash::Hash;
use std::str::FromStr;

#[derive(Debug, Hash, Eq, PartialEq, Copy, Clone)]
pub struct Point {
    pub x: isize,
    pub y: isize,
}

#[derive(Debug)]
pub struct Rocks {
    pub edges: Vec&lt;Point&gt;,
}

impl Point {
    fn dist(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: other.x - self.x,
            y: other.y - self.y,
        }
    }

    fn contains(&amp;self, other: &amp;Self) -&gt; bool {
        if other.x == 0 &amp;&amp; other.y == 0 {
            true
        } else if self.x != 0 {
            other.y == 0
                &amp;&amp; self.x.clamp(-1, 1) == other.x.clamp(-1, 1)
                &amp;&amp; self.x.abs() &gt;= other.x.abs()
        } else {
            other.x == 0
                &amp;&amp; self.y.clamp(-1, 1) == other.y.clamp(-1, 1)
                &amp;&amp; self.y.abs() &gt;= other.y.abs()
        }
    }

    pub fn down(&amp;self) -&gt; Self {
        Self {
            x: self.x,
            y: self.y + 1,
        }
    }

    pub fn left_down(&amp;self) -&gt; Self {
        Self {
            x: self.x - 1,
            y: self.y + 1,
        }
    }

    pub fn right_down(&amp;self) -&gt; Self {
        Self {
            x: self.x + 1,
            y: self.y + 1,
        }
    }
}

impl Rocks {
    pub fn contains(&amp;self, p: Point) -&gt; bool {
        for (left, right) in self.edges.iter().zip(self.edges.iter().skip(1)) {
            let edge_diff = right.dist(left);
            let point_diff = p.dist(left);
            if edge_diff.contains(&amp;point_diff) {
                return true;
            }
        }
        false
    }
}

impl FromStr for Point {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split(",").collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [x, y] =&gt; Ok(Self {
                x: x.parse()?,
                y: y.parse()?,
            }),
            _ =&gt; Err(Error::msg("cannot parse point")),
        }
    }
}

impl FromStr for Rocks {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let maybe_edges = s
            .split(" -&gt; ")
            .map(|el| el.parse::&lt;Point&gt;())
            .collect::&lt;Vec&lt;_&gt;&gt;();

        let mut has_err = false;
        for edge in &amp;maybe_edges {
            if let Err(err) = edge {
                eprintln!("{:?}", err);
                has_err = true;
            }
        }

        if has_err {
            Err(Error::msg("cannot parse as edges"))
        } else {
            let edges = maybe_edges
                .into_iter()
                .map(|el| el.unwrap())
                .collect::&lt;Vec&lt;_&gt;&gt;();

            // Check whether edges go diagonally.
            for (left, right) in edges.iter().zip(edges.iter().skip(1)) {
                let edge_diff = right.dist(left);
                if edge_diff.x != 0 &amp;&amp; edge_diff.y != 0 {
                    return Err(Error::msg("found an edge that isn't straight"));
                }
            }

            Ok(Self { edges })
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_14"><a class="anchor" href="#_how_to_run_14"></a><a class="link" href="#_how_to_run_14">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute the command
<code>cargo run --release</code> to run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day15" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_15_rust"><a class="anchor" href="#_day_15_rust"></a><a class="link" href="#_day_15_rust">Day 15: rust</a></h3>
<div class="sect3">
<h4 id="_day_15_beacon_exclusion_zone"><a class="anchor" href="#_day_15_beacon_exclusion_zone"></a><a class="link" href="#_day_15_beacon_exclusion_zone">Day 15: Beacon Exclusion Zone</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_13"><a class="anchor" href="#_oveview_13"></a><a class="link" href="#_oveview_13">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_14"><a class="anchor" href="#_solution_14"></a><a class="link" href="#_solution_14">Solution</a></h5>
<div class="paragraph">
<p>Part 1 was easy enough, I simply gave each exclusion zone a function that
provided all points within it at a certain y-coordinate, fed all of them into a
set, and then checked how many elements it had.
Not very pretty but worked well enough.</p>
</div>
<div class="paragraph">
<p>At first, I brute-forced part 2 and got lucky.
However, that solution wasn&#8217;t satisfying and then I found some more time to look
into this today.
Yeah!</p>
</div>
<div class="paragraph">
<p>The final solution to part 2 turned out to be one that I never expected to
perform well but that did, as it turns out.
What I do is I basically perform a line scan along the x axis for all y
coordinates.
For each y, I extract all non-empty overlaps between exclusion zones and the
scanning line and discarded those that were outside the playing field.
Then, I merged those overlaps.</p>
</div>
<div class="paragraph">
<p>To make merging overlaps, which are ranges, very easy, I sorted all of then
first by their x_min coordinate and, if those are equal, by their x_max
coordinate.
I never thought that sorting them would be efficient enough, but it is.
Once they have been sorted, merging them is easy.
If x_min of the first entry is not 0, we&#8217;ve found the coordinates.
Otherwise, we check whether x_min of the next range in line is greater than the
current x_max.
If so, we&#8217;ve found the empty spot.
If not, we increase our currently known x_max to the x_max of that range.
Once the known x_max reached 4,000,000, we know that this line doesn&#8217;t contain
the beacon.
Rinse repeat for every y until the distress beacon has been found.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.

fn find_missing_x(
    diamonds: &amp;Vec&lt;data::Diamond&gt;,
    outer_min: isize,
    outer_max: isize,
    y: isize,
) -&gt; Option&lt;(isize, isize)&gt; {
    // Extract all ranges at the given y-coordinate first.
    let mut ranges = diamonds
        .iter()
        .map(|el| el.xrange_at_y(&amp;y).clamp(outer_min, outer_max))
        .filter(|el| el != &amp;data::NULL_RANGE)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Then, we sort by left coordinate first and by right coordinate second. That makes finding
    // the missing x spot trivial.
    ranges.sort_by(|range1, range2| {
        let left_cmp = range1.left.cmp(&amp;range2.left);
        if left_cmp == std::cmp::Ordering::Equal {
            range1.right.cmp(&amp;range2.right)
        } else {
            left_cmp
        }
    });

    let mut max = ranges[0].right;
    if ranges[0].left != outer_min {
        // Wouldn't that be nice.
        Some((outer_min, y))
    } else {
        for range in ranges[1..].into_iter() {
            // We can never find a left coordinate that is smaller than what we already have.
            if range.left &gt; max {
                // Yeah, found it!
                return Some((max, y));
            } else if range.right &gt; max {
                max = range.right;
            } else if range.right &lt;= max {
                // Don't do anything here.
            } else {
                unreachable!("there are no more conditions");
            }
        }

        None
    }
}

fn solve(file: &amp;str, y: isize, (min, max): (isize, isize)) -&gt; Result&lt;()&gt; {
    println!("PROCESSING {} WITH Y {}", file, y);

    // Read file and convert into data.
    let exclusion_zones = io::parse_chunks_to_data::&lt;data::Diamond&gt;(
        io::read_lines_from_file(file, 1)?,
        "diamonds",
        None,
        None,
    )?;
    println!("number of diamons is {}", exclusion_zones.len());

    let beacons = exclusion_zones
        .iter()
        .map(|el| (el.bx, el.by))
        .collect::&lt;HashSet&lt;_&gt;&gt;();
    let sensors = exclusion_zones
        .iter()
        .map(|el| (el.x, el.y))
        .collect::&lt;HashSet&lt;_&gt;&gt;();
    let objects = &amp;beacons | &amp;sensors;

    // Part 1.
    let count = exclusion_zones
        .iter()
        .map(|el| el.xs_at_y(&amp;y))
        .flatten()
        // This is a lazy filter to detect clashes with existing objects but I didn't want to put
        // too much effort into part 1.
        .filter(|el| !objects.contains(&amp;(*el, y)))
        .collect::&lt;HashSet&lt;_&gt;&gt;()
        .len();

    println!("number of points along {} is {}", y, count);

    // Part 2.
    // There is guaranteed to be exactly one point.
    let missing = (min..max + 1).find_map(|y| find_missing_x(&amp;exclusion_zones, min, max + 1, y));

    if let Some((x, y)) = missing {
        println!("tuning frequency is {}", x * max + y);
        Ok(())
    } else {
        Err(Error::msg("there is no distress beacon"))
    }
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1, 10, (0, 20))?;
    solve(REAL, 2_000_000, (0, 4_000_000))?;
    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug, Eq, PartialEq, Copy, Clone)]
pub struct Diamond {
    pub x: isize,
    pub y: isize,
    pub bx: isize,
    pub by: isize,
    pub dist: isize,
}

#[derive(Debug, Eq, PartialEq)]
pub struct Range {
    pub left: isize,
    pub right: isize,
}

impl Range {
    pub fn clamp(&amp;self, min: isize, max: isize) -&gt; Range {
        if self.right &lt;= min || self.left &gt;= max {
            NULL_RANGE
        } else {
            Range {
                left: self.left.clamp(min, max),
                right: self.right.clamp(min, max),
            }
        }
    }
}

pub const NULL_RANGE: Range = Range { left: 0, right: 0 };

impl FromStr for Diamond {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["Sensor", "at", sensor_x, sensor_y, "closest", "beacon", "is", "at", beacon_x, beacon_y] =&gt;
            {
                if !sensor_x.starts_with("x=") || !sensor_y.starts_with("y=") {
                    return Err(Error::msg("malformed sensor coordinates"));
                }
                if !beacon_x.starts_with("x=") || !beacon_y.starts_with("y=") {
                    return Err(Error::msg("malformed beacon coordinates"));
                }
                let conv = |val: &amp;str| {
                    val.trim_start_matches("x=")
                        .trim_start_matches("y=")
                        .trim_end_matches(",")
                        .trim_end_matches(":")
                        .parse::&lt;isize&gt;()
                };
                let x = conv(sensor_x)?;
                let y = conv(sensor_y)?;
                let bx = conv(beacon_x)?;
                let by = conv(beacon_y)?;
                let dist = (bx - x).abs() + (by - y).abs();
                if dist &gt; 0 {
                    Ok(Self { x, y, bx, by, dist })
                } else {
                    Err(Error::msg("negative distance encountered"))
                }
            }
            _ =&gt; Err(Error::msg("cannot parse point")),
        }
    }
}

impl Diamond {
    pub fn xs_at_y(&amp;self, y: &amp;isize) -&gt; std::ops::Range&lt;isize&gt; {
        let dist = (y - self.y).abs();
        if dist &lt;= self.dist {
            let remaining = self.dist - dist;
            self.x - remaining..self.x + remaining + 1
        } else {
            0..0
        }
    }

    pub fn xrange_at_y(&amp;self, y: &amp;isize) -&gt; Range {
        let dist = (y - self.y).abs();
        if dist &lt;= self.dist {
            let remaining = self.dist - dist;
            Range {
                left: self.x - remaining,
                right: self.x + remaining + 1,
            }
        } else {
            NULL_RANGE
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_15"><a class="anchor" href="#_how_to_run_15"></a><a class="link" href="#_how_to_run_15">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute the command
<code>cargo run --release</code> to run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day16" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_16_rust"><a class="anchor" href="#_day_16_rust"></a><a class="link" href="#_day_16_rust">Day 16: rust</a></h3>
<div class="sect3">
<h4 id="_day_16_proboscidea_volcanium"><a class="anchor" href="#_day_16_proboscidea_volcanium"></a><a class="link" href="#_day_16_proboscidea_volcanium">Day 16: Proboscidea Volcanium</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_14"><a class="anchor" href="#_oveview_14"></a><a class="link" href="#_oveview_14">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_15"><a class="anchor" href="#_solution_15"></a><a class="link" href="#_solution_15">Solution</a></h5>
<div class="paragraph">
<p>Today&#8217;s part 2 was pretty tricky and I guess rust&#8217;s efficiency kind of saved me.
I actually assumed something completely different, but luckily I refrained from
overcomplicating part 1 because of that.</p>
</div>
<div class="paragraph">
<p>Part 1 was a straightforward backtracking problem.
A stupid mistake caused me to lose quite some time, though, which meant I had a
lot less time for part 2.
The main idea I had was not to simulate the passing of time but instead have
each valve contribute directly to the overall release value because we know for
how long it will be opened.
Furthermore, I computed pairwise distances before running any backtracking and
ignored all those valves that had a zero release rate.
Pairwise distances can be computed easily by bubbling a nearest neighbour sphere
outwards.</p>
</div>
<div class="paragraph">
<p>I still solved part 2 like a backtracking problem.
The added complexity comes from the fact that the elephant can also act.</p>
</div>
<div class="paragraph">
<p>I modelled the world in a way that had the human act first on a specific number
of valves.
Then time is reset, and the elephant acts on as many valves at it likes from
among those valves that the human hasn&#8217;t acted on, yet, until there are no more
valves left or time runs out.
I then decrease the number of valves the human acts on in steps of 1 starting at
the maximum possible number and take the overall highest release value.</p>
</div>
<div class="paragraph">
<p>I added a quick stopping condition, which worked for my inputs but might not
translate.
Set the env var <code>QUICK=0</code> to disable quick mode, which is enabled by default.
Quick mode assumes that, as the number of valves opened by the human decreases,
the best possible release value will only ever increase.
With quick mode enabled, this runs in &lt;20s on my &gt;10year old business notebook.
Without quick mode, it takes &lt;3min.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
// Constants.
// We map each set of two chars to one usize. Since there are 26 letters in the alphabet, we map
// each pair to 100*ord(first) + ord(second) where ord("A")==0 and ord("Z")==25. Thus, "AA" maps to
// zero.
const START: u8 = 0;

fn pairwise_distances(valve_map: &amp;HashMap&lt;u8, &amp;data::Valve&gt;) -&gt; HashMap&lt;(u8, u8), usize&gt; {
    let mut result = HashMap::&lt;(u8, u8), usize&gt;::new();

    for (name, valve) in valve_map {
        let mut curr_dist = 1 as usize;
        // All neighbours have a distance of one.
        let mut distances = valve
            .neighbours
            .iter()
            .map(|el| (el.clone(), curr_dist))
            .collect::&lt;HashMap&lt;_, _&gt;&gt;();
        // We always remeber new points we added. Those points have a distance of one more than the
        // previous max.
        let mut new_valves = distances
            .iter()
            .map(|el| el.0.clone())
            .collect::&lt;HashSet&lt;_&gt;&gt;();
        // We include the point itself for ease of use later on.
        distances.insert(name.clone(), 0);

        // Repeat until no more neighbours have been added.
        while new_valves.len() != 0 {
            curr_dist += 1;
            // Determine those valve names that are at the next distance.
            new_valves = new_valves
                .iter()
                // Extract the actual valve data.
                .filter_map(|el| valve_map.get(el))
                // Get all neighbours of those valves we just extracted in one big iterator.
                .map(|el| el.neighbours.iter())
                .flatten()
                // Get a unique set of the names of those valves that may have been added in this
                // iteration.
                .collect::&lt;HashSet&lt;_&gt;&gt;()
                .into_iter()
                // Keep only those to which we haven't yet computed distances.
                .filter_map(|el| {
                    if let Some(_) = distances.get(el) {
                        None
                    } else {
                        Some(el.clone())
                    }
                })
                .collect::&lt;HashSet&lt;_&gt;&gt;();
            // Add those distances.
            distances.extend(new_valves.iter().map(|el| (el.clone(), curr_dist)));
        }

        result.extend(
            distances
                .into_iter()
                .map(|(new_valve, dist)| ((name.clone(), new_valve), dist)),
        );
    }

    result
}

fn backtrack(
    valve_name_map: &amp;HashMap&lt;u8, &amp;data::Valve&gt;,
    distances: &amp;HashMap&lt;(u8, u8), usize&gt;,
    relevant_valves: &amp;Vec&lt;Option&lt;u8&gt;&gt;,
    current_spot: &amp;u8,
    current_time: usize,
    max_time: usize,
    current_best: usize,
    visited: &amp;mut HashSet&lt;u8&gt;,
    allow_elephant: bool,
    elephant_depth: usize,
) -&gt; Result&lt;usize&gt; {
    // Check that None is the first entry in the list of relevant_valves.
    if allow_elephant &amp;&amp; !relevant_valves[0].as_ref().is_none() {
        return Err(Error::msg("the first relevant valve has to be None"));
    }
    let mut next_best = current_best;

    for maybe_next_spot in relevant_valves.iter() {
        let possible_best = if let Some(next_spot) = maybe_next_spot {
            // Let the human do their thing.
            // Skip spots we've already seen.
            if visited.contains(next_spot) {
                continue;
            }

            let time_spent_traveling = distances
                .get(&amp;(current_spot.clone(), next_spot.clone()))
                .ok_or(Error::msg("cannot retrieve distance"))?;

            // We add 1 because of the time it takes to open the valve.
            let time_of_next_valve_opening = current_time + time_spent_traveling + 1;

            // Check whether we have any time left to open another valve.
            if time_of_next_valve_opening &gt;= max_time {
                // If not, we found the best we can using this route. Skip this spot.
                continue;
            } else {
                // We will be able to open that valve.
                // Remember that we visited it.
                visited.insert(next_spot.clone());

                // Check by how much the next valve can increase our release value.
                let next_valve_rate = valve_name_map
                    .get(next_spot)
                    .ok_or(Error::msg("cannot retrieve valve"))?
                    .rate;
                let benefit = (max_time - time_of_next_valve_opening) * next_valve_rate;

                backtrack(
                    valve_name_map,
                    distances,
                    relevant_valves,
                    &amp;next_spot,
                    time_of_next_valve_opening,
                    max_time,
                    current_best + benefit,
                    visited,
                    allow_elephant,
                    elephant_depth,
                )?
            }
        } else if allow_elephant &amp;&amp; visited.len() == elephant_depth {
            // Let the elephant also do its thing, allowing it only to visit those points that we
            // haven't yet visited. Actually, this has to be the first step we do for the algorithm
            // to work. Otherwise, better paths will be missed.
            backtrack(
                valve_name_map,
                distances,
                relevant_valves,
                // The elephant starts at the start.
                &amp;START,
                // Time is reset.
                0,
                max_time,
                // We will still have acted, meaning the elephant can only ever increase the
                // release value.
                next_best,
                // The elephant may only visit those valves that we haven't yet visited.
                visited,
                // Don't allow yet another elephant to explore.
                false,
                elephant_depth,
            )?
        } else {
            // This block allows us to still run part 1 despite all the code related to elephants.
            0
        };
        if possible_best &gt; next_best {
            next_best = possible_best;
        }

        // Forget that we visited the point but only if this isn't the elephant's turn.
        if let Some(next_spot) = maybe_next_spot {
            visited.remove(next_spot);
        }
    }
    // Return the bext one we found.
    Ok(next_best)
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    println!("PROCESSING {}", file);

    // Read file and convert into data.
    let valves = io::parse_chunks_to_data::&lt;data::Valve&gt;(
        io::read_lines_from_file(file, 1)?,
        "valves",
        None,
        None,
    )?;
    // We only want to look at valves that have non-zero rates for part 1. I suspect it's gonna be
    // different for part 2. Nope, it's not.
    let relevant_valves = valves
        .iter()
        .filter_map(|el| {
            if el.rate &gt; 0 {
                Some(el.name.clone())
            } else {
                None
            }
        })
        .map(|el| Some(el))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Compute pairwise distances.
    let valve_name_map = valves
        .iter()
        .map(|el| (el.name.clone(), el))
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();
    let distances = pairwise_distances(&amp;valve_name_map);

    // Backtrack the solution.
    let start_time = 0;
    let max_time = 30;
    let start_release = 0;
    let mut visited = HashSet::&lt;_&gt;::with_capacity(relevant_valves.len());

    let max_part1 = backtrack(
        &amp;valve_name_map,
        &amp;distances,
        &amp;relevant_valves,
        &amp;START,
        start_time,
        max_time,
        start_release,
        &amp;mut visited,
        false,
        0,
    )?;
    println!("part 1: {}", max_part1);

    // Part 2.
    // Backtrack the solution.

    let max_time_part2 = 26;
    // A value of None means that the human should stop what they are doing and let the elephant do
    // its thing. It has to be the first entry in relevant_valves. Otherwise, better paths are
    // lost, somehow.
    let mut relevant_with_elephant = vec![None];
    relevant_with_elephant.extend_from_slice(&amp;relevant_valves);

    // Quick mode uses the below assumptions and we use it by default.
    let quick_mode = std::env::var("QUICK").unwrap_or("1".to_string()) == "1";

    let mut best = 0;
    // This is a bit hacky but it works. We check what happens if the human is guaranteed a certain
    // number of valves because the elephant can only open those that the human didn't approach.
    // Then, we assume that, the fewer valves the human opens, the higher the overal pressure
    // release gets because the elephant can open some. At some point, since this is at least a
    // certain number of steps, there will no longer be an increase followed by a decrease, which
    // is our stopping point. This is an assumption, which tunrs out to hold, but it might not for
    // all possible inputs. If it doesn't simply disable quick mode.
    for num_human_valves in (0..relevant_valves.len()).rev() {
        // Reset some mutable data structures.
        visited = HashSet::&lt;_&gt;::with_capacity(relevant_valves.len());

        let max = backtrack(
            &amp;valve_name_map,
            &amp;distances,
            &amp;relevant_with_elephant,
            &amp;START,
            start_time,
            max_time_part2,
            start_release,
            &amp;mut visited,
            true,
            num_human_valves,
        )?;
        println!(
            "part 2: with {} guaranteed human valves: {}",
            num_human_valves, max
        );
        if quick_mode {
            if max &lt; best {
                break;
            } else {
                best = max;
            }
        } else {
            if max &gt; best {
                best = max;
            }
        }
    }
    println!("part 2: {}", best);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1)?;
    solve(REAL)?;
    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Valve {
    pub name: u8,
    pub rate: usize,
    pub neighbours: Vec&lt;u8&gt;,
}

// Using u8 instead of two-character strings speeds the entire thing up by about a factor of 4. If
// you have other character combinations, simply add them here.
pub fn str_to_usize(s: &amp;str) -&gt; Option&lt;u8&gt; {
    match s {
        "AA" =&gt; Some(0),
        "AF" =&gt; Some(1),
        "AK" =&gt; Some(2),
        "BB" =&gt; Some(3),
        "BC" =&gt; Some(4),
        "BF" =&gt; Some(5),
        "BV" =&gt; Some(6),
        "CA" =&gt; Some(7),
        "CC" =&gt; Some(8),
        "CM" =&gt; Some(9),
        "DD" =&gt; Some(10),
        "DO" =&gt; Some(11),
        "DW" =&gt; Some(12),
        "EE" =&gt; Some(13),
        "EI" =&gt; Some(14),
        "EJ" =&gt; Some(15),
        "EV" =&gt; Some(16),
        "FD" =&gt; Some(17),
        "FF" =&gt; Some(18),
        "FN" =&gt; Some(19),
        "GG" =&gt; Some(20),
        "GO" =&gt; Some(21),
        "GW" =&gt; Some(22),
        "HH" =&gt; Some(23),
        "HO" =&gt; Some(24),
        "HP" =&gt; Some(25),
        "HR" =&gt; Some(26),
        "HX" =&gt; Some(27),
        "II" =&gt; Some(28),
        "IR" =&gt; Some(29),
        "JJ" =&gt; Some(30),
        "JQ" =&gt; Some(31),
        "JS" =&gt; Some(32),
        "KH" =&gt; Some(33),
        "KL" =&gt; Some(34),
        "KQ" =&gt; Some(35),
        "KX" =&gt; Some(36),
        "LR" =&gt; Some(37),
        "MS" =&gt; Some(38),
        "MW" =&gt; Some(39),
        "NB" =&gt; Some(40),
        "NC" =&gt; Some(41),
        "NQ" =&gt; Some(42),
        "OF" =&gt; Some(43),
        "OM" =&gt; Some(44),
        "OQ" =&gt; Some(45),
        "OX" =&gt; Some(46),
        "PC" =&gt; Some(47),
        "PD" =&gt; Some(48),
        "PH" =&gt; Some(49),
        "PU" =&gt; Some(50),
        "QE" =&gt; Some(51),
        "RX" =&gt; Some(52),
        "RZ" =&gt; Some(53),
        "SG" =&gt; Some(54),
        "SM" =&gt; Some(55),
        "SY" =&gt; Some(56),
        "TN" =&gt; Some(57),
        "TS" =&gt; Some(58),
        "TY" =&gt; Some(59),
        "UE" =&gt; Some(60),
        "VL" =&gt; Some(61),
        "WE" =&gt; Some(62),
        "WU" =&gt; Some(63),
        "WW" =&gt; Some(64),
        "XG" =&gt; Some(65),
        "XN" =&gt; Some(66),
        "YD" =&gt; Some(67),
        "YQ" =&gt; Some(68),
        "ZQ" =&gt; Some(69),
        "ZX" =&gt; Some(70),
        _ =&gt; None,
    }
}

impl FromStr for Valve {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let name;
        let rate: usize;
        let neighbours: Vec&lt;_&gt;;

        match s.split(";").collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [valve_data, tunnel_data] =&gt; {
                match valve_data.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
                    ["Valve", id, "has", "flow", rate_str] =&gt; {
                        name =
                            str_to_usize(id).ok_or(Error::msg("cannot convert chars to usize"))?;
                        rate = rate_str.trim_start_matches("rate=").parse()?;
                    }
                    _ =&gt; {
                        return Err(Error::msg("cannot parse valve data"));
                    }
                }
                if !tunnel_data.starts_with(" tunnels lead to valve")
                    &amp;&amp; !tunnel_data.starts_with(" tunnel leads to valve")
                {
                    return Err(Error::msg("cannot parse tunnel data"));
                }
                let maybe_neighbours = tunnel_data
                    .split_whitespace()
                    .skip(4)
                    .map(|el| str_to_usize(el.trim().trim_end_matches(",")))
                    .collect::&lt;Vec&lt;_&gt;&gt;();
                // We let this panic if it wants to.
                neighbours = maybe_neighbours
                    .into_iter()
                    .map(|el| el.unwrap())
                    .collect::&lt;Vec&lt;_&gt;&gt;();
                Ok(Self {
                    name,
                    rate,
                    neighbours,
                })
            }
            _ =&gt; Err(Error::msg("cannot parse valve")),
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_16"><a class="anchor" href="#_how_to_run_16"></a><a class="link" href="#_how_to_run_16">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day17" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_17_rust"><a class="anchor" href="#_day_17_rust"></a><a class="link" href="#_day_17_rust">Day 17: rust</a></h3>
<div class="sect3">
<h4 id="_day_17_pyroclastic_flow"><a class="anchor" href="#_day_17_pyroclastic_flow"></a><a class="link" href="#_day_17_pyroclastic_flow">Day 17: Pyroclastic Flow</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_15"><a class="anchor" href="#_oveview_15"></a><a class="link" href="#_oveview_15">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_16"><a class="anchor" href="#_solution_16"></a><a class="link" href="#_solution_16">Solution</a></h5>
<div class="paragraph">
<p>Part 1 was a straightforward implementation of a tetris-like game.
I used a <code>HashMap</code> of 2d vectors to represent spots that were occupied by rocks.
If you read the rules carefully and don&#8217;t make a mistake with the shape of the
rocks, you&#8217;re good.</p>
</div>
<div class="paragraph">
<p>Part 2 was very tricky for me and I fell into so many traps that I almost gave
up.
It was clear from the start that you can&#8217;t simply keep expanding the playing
field until the 1 billionth rock had dropped.
Instead, there had to be some repetition involved.
Finding the correct point from which to extrapolate into the future was the crux
here.
It basically took an entire day of background thinking and trying it out every
now and again to solve.</p>
</div>
<div class="paragraph">
<p>There are two infinite streams that need to repeat, the stream of rocks and the
stream of air.
For the example, the lengths of both are nicely divisible.
not so much for the real puzzle.
Instead, I check the ground each square rock has settled on after it settled as
well as the position in the infinite air stream at that time.
If the shape of the ground, the type of rock, and the position in the air stream
have the same values again, we found our repetition.
Ground extraction is explained in the code and works reasonably well.
I even neglect some grounds that would be tricky to work with, which is maybe
not even needed.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
use std::iter::Cycle;
use std::vec::IntoIter;
// Constants.

fn render(field: &amp;HashSet&lt;data::Pos&gt;, rock: &amp;data::Rock, pos: &amp;data::Pos) {
    let max_x = 8;
    let max_y = field.iter().map(|el| el.y).max().unwrap_or(10) + 10;
    let min_x = 0;
    let min_y = 0;

    let rock_fields = rock.occupied_fields(pos).collect::&lt;HashSet&lt;_&gt;&gt;();

    for y in (min_y..max_y).rev() {
        for x in min_x..=max_x {
            let pos = data::Pos { x, y };
            if field.contains(&amp;pos) &amp;&amp; rock_fields.contains(&amp;pos) {
                // This a conflict field.
                print!("X")
            } else if field.contains(&amp;pos) {
                print!("#")
            } else if rock_fields.contains(&amp;pos) {
                print!("@")
            } else if y == 0 {
                print!("-")
            } else if x == 0 || x == 8 {
                print!("|")
            } else {
                print!(".");
            }
        }
        print!("\n");
    }
    print!("\n");
}

fn is_blocked(field: &amp;HashSet&lt;data::Pos&gt;, check: &amp;data::Pos, width: isize) -&gt; data::Blocked {
    if check.x &lt;= 0 || check.x &gt;= width {
        data::Blocked::Wall
    } else if field.contains(check) {
        data::Blocked::Rock
    } else if check.y == 0 {
        // This is hacky but we simulate a floor of rocks so that a downward operation will have
        // the rock to settle on.
        data::Blocked::Rock
    } else {
        data::Blocked::None
    }
}

// Nice means no rock can muddle its way through. There is a direct connection from the left wall
// to the right wall.
fn is_nice_ground(ground: &amp;HashSet&lt;data::Pos&gt;, field: &amp;HashSet&lt;data::Pos&gt;) -&gt; bool {
    let mut x = 1;
    let mut candidates = ground
        .iter()
        .filter_map(|el| if el.x == x { Some(el.clone()) } else { None })
        .collect::&lt;HashSet&lt;data::Pos&gt;&gt;();
    candidates = &amp;candidates &amp; field;

    while candidates.len() != 0 {
        x += 1;
        candidates = candidates
            .into_iter()
            .map(|el| el.right_env())
            .flatten()
            .collect::&lt;HashSet&lt;data::Pos&gt;&gt;();
        candidates = &amp;candidates &amp; field;
    }

    x == 8
}

// We try to find the ground the last rock settled on. We basically go from top to the bottom until
// we have found at least one rock at each of the possible 7 x positions. For piece of mind, we
// only consider nice grounds (see is_nice_ground for a definition).
fn get_ground(field: &amp;HashSet&lt;data::Pos&gt;, top_rock: isize) -&gt; Option&lt;HashSet&lt;data::Pos&gt;&gt; {
    let mut found = vec![false; 7];
    let mut bottom = HashSet::&lt;data::Pos&gt;::new();
    let mut min_y = top_rock;

    for y in (1..=top_rock).rev() {
        min_y = y;
        for x in 1..=7 {
            let check = data::Pos { x, y };
            if field.contains(&amp;check) {
                found[(x - 1) as usize] = true;
                bottom.insert(check);
            }
        }
        if found.iter().all(|el| *el) {
            break;
        }
    }

    if is_nice_ground(&amp;bottom, field) {
        let disp = data::Pos { x: 0, y: -min_y };
        Some(bottom.into_iter().map(|el| el.add(&amp;disp)).collect())
    } else {
        None
    }
}

// Rep stands for repetition.
#[derive(Debug)]
struct Rep {
    round: usize,
    top_rock: isize,
    ground: HashSet&lt;data::Pos&gt;,
}

// Yeah, we are playing tetris today.
// This function looked OK until after part 1 but now it's horrible, but I don't want to take any
// time to refactor.
fn play_tetris(
    mut stream: Cycle&lt;IntoIter&lt;data::Push&gt;&gt;,
    mut rocks: Cycle&lt;IntoIter&lt;data::Rock&gt;&gt;,
    max_num_rocks: usize,
    num_steam_steps: usize,
    num_rock_steps: usize,
    // trigger for part 2.
    do_repeat: bool,
) -&gt; usize {
    let mut possible_rep_store = HashMap::&lt;(usize, usize), Vec&lt;Rep&gt;&gt;::new();
    // We will track the positions of all rocks with this.
    let mut field = HashSet::&lt;data::Pos&gt;::new();
    // At the beginning, there is no rock yet. Thus, the top position is the floor.
    let mut top_rock = 0;
    // Round counts rocks.
    let mut round = 0;
    // Step counts gusts of air.
    let mut step = 0;
    while round &lt; max_num_rocks {
        round += 1;
        let rock = rocks.next().expect("weren't there infinitely many rocks");
        // Spwan a rock.
        let mut pos = data::Pos {
            // There also have to be 2 free spaces in x direction. Thus, it spawns at x
            // coordinate 3.
            x: 3,
            // There have to be 3 free spaces in y direction. Thus, it spwans 4 units
            // further above.
            y: top_rock + 4,
        };
        let mut has_settled = false;
        while !has_settled {
            // Get the next stream element. This is an infinite iterator.
            let push = stream.next().expect("wasn't this supposed to be infinite");
            step += 1;

            // Apply the movement operation to the side.
            let next_pushed = push.apply(&amp;pos);
            // Check whether there is any collision.
            let push_blocked_check = rock
                .occupied_fields(&amp;next_pushed)
                .map(|el| is_blocked(&amp;field, &amp;el, 8))
                .find(|el| el != &amp;data::Blocked::None);
            // Accept the movement only if we haven't been blocked.
            if let None = push_blocked_check {
                pos = next_pushed;
            }

            // Move downwards and check again.
            let next_dropped = pos.drop();
            // Check whether there is any collision.
            let drop_blocked_check = rock
                .occupied_fields(&amp;next_dropped)
                .map(|el| is_blocked(&amp;field, &amp;el, 8))
                .find(|el| el == &amp;data::Blocked::Rock);
            // Accept the movement only if we haven't been blocked.
            if let Some(_) = drop_blocked_check {
                // The rock has settled!
                has_settled = true;
                // Find the topmost position and occupy all fields of the rock.
                field.extend(rock.occupied_fields(&amp;pos));
                // Check whether the rock that just settled reaches higher than before.
                let possible_top_rock = rock
                    .occupied_fields(&amp;pos)
                    .map(|el| el.y)
                    .max()
                    .expect("cannot find top rock");
                if possible_top_rock &gt; top_rock {
                    top_rock = possible_top_rock;
                }
            } else {
                // The rock hasn't settled yet. Accept the update.
                pos = next_dropped;
            }
        }
        // This entire block is horrible and takes care of part 2. Ignore it for part 1.
        if do_repeat &amp;&amp; round % num_rock_steps == 0 {
            // If we're in here, a square block has settled.
            // Determine our position in the repeating rock and steam streams.
            let rep_key = (round % num_rock_steps, step % num_steam_steps);
            if let Some(ground) = get_ground(&amp;field, top_rock) {
                // If we're in here, then the rock has settled on a patch of ground that is nice
                // (i.e. where no rock can muddle its way through).
                if let Some(possible_rep) = possible_rep_store.get_mut(&amp;rep_key) {
                    // If we're in here, we have already found this type of rock settling at this
                    // position in the stream/gust of air sequence.
                    // Check whether the ground repeated, too.
                    if let Some(rep) = possible_rep.iter().find_map(|el| {
                        if el.ground.len() == ground.len() &amp;&amp; (&amp;el.ground ^ &amp;ground).len() == 0 {
                            Some(el)
                        } else {
                            None
                        }
                    }) {
                        // If we're in here, we found the same type of rock that settled at the
                        // same position in the steam stream AND that rock settled on an identical
                        // patch of ground as a previous rock. That means everything will repeat
                        // from here on out.
                        //
                        // Clear the field to save memory. Then, fast forward time and use the most
                        // recently found ground to reinitialise the field.
                        field.clear();
                        let rounds_in_loop = round - rep.round;
                        let increase_per_loop = (top_rock - rep.top_rock) as usize;
                        let loops_remaining = (max_num_rocks - round) / rounds_in_loop;
                        round += loops_remaining * rounds_in_loop;
                        top_rock += (loops_remaining * increase_per_loop) as isize;
                        // Displace the ground to where it belongs. It will not form the top of the
                        // field. Because the ground is nice, no rock can fall through it.
                        let top_rock_in_ground = ground
                            .iter()
                            .map(|el| el.y)
                            .max()
                            .expect("there is no ground");
                        let disp = data::Pos {
                            x: 0,
                            y: top_rock - top_rock_in_ground,
                        };
                        field = ground.into_iter().map(|el| el.add(&amp;disp)).collect();
                    } else {
                        // Remember this ground.
                        possible_rep.push(Rep {
                            round,
                            top_rock,
                            ground,
                        });
                    }
                } else {
                    // Remember the ground for this combination of rock and position in the steam
                    // stream.
                    let rep_val = Rep {
                        round,
                        top_rock,
                        ground,
                    };
                    possible_rep_store.insert(rep_key, vec![rep_val]);
                }
            }
        }
    }

    top_rock as usize
}

fn solve(file: &amp;str, max_num_rocks: usize) -&gt; Result&lt;()&gt; {
    println!("PROCESSING {}", file);

    // Read file and convert into data.
    let stream = io::parse_chunks_to_data::&lt;data::Stream&gt;(
        io::read_lines_from_file(file, 1)?,
        "stream",
        None,
        None,
    )?
    .into_iter()
    .nth(0)
    .ok_or(Error::msg("found no stream"))?;

    let num_pushes = stream.flow.len();
    println!("push sequence has {} elements", num_pushes);
    let num_rocks = std::mem::variant_count::&lt;data::Rock&gt;();
    println!("rock sequence has {} elements", num_rocks);

    let tallness = play_tetris(
        stream.infinite(),
        data::Rock::infinite_stream(),
        max_num_rocks,
        num_pushes,
        num_rocks,
        // Works but hacky trigger for part 2 ^^.
        max_num_rocks &gt; 10_000,
    );
    println!(
        "tower will be {} tall after {} rocks",
        tallness, max_num_rocks
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1, 2022)?;
    solve(REAL, 2022)?;

    solve(SAMPLE1, 1_000_000_000_000)?;
    solve(REAL, 1_000_000_000_000)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug, Clone)]
pub enum Push {
    Left,
    Right,
}

#[derive(Debug, Hash, Eq, PartialEq, Clone)]
pub struct Pos {
    pub x: isize,
    pub y: isize,
}

#[derive(Debug)]
pub struct Stream {
    pub flow: Vec&lt;Push&gt;,
}

// The position of each rock is indicated by the point in its bottom left. There doesn't have to be
// anything there?
#[derive(Debug, Clone, PartialEq)]
pub enum Rock {
    Minus,
    Plus,
    InverseL,
    I,
    Block,
}

#[derive(Debug, PartialEq)]
pub enum Blocked {
    Rock,
    Wall,
    None,
}

impl Pos {
    pub fn add(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    pub fn drop(&amp;self) -&gt; Self {
        Self {
            x: self.x,
            y: self.y - 1,
        }
    }

    pub fn right_env(&amp;self) -&gt; Vec&lt;Self&gt; {
        vec![
            Self {
                x: self.x + 1,
                y: self.y + 1,
            },
            Self {
                x: self.x + 1,
                y: self.y,
            },
            Self {
                x: self.x + 1,
                y: self.y - 1,
            },
        ]
    }
}

impl Push {
    pub fn apply(&amp;self, start: &amp;Pos) -&gt; Pos {
        match self {
            Self::Left =&gt; Pos {
                x: -1 + start.x,
                y: start.y,
            },
            Self::Right =&gt; Pos {
                x: 1 + start.x,
                y: start.y,
            },
        }
    }
}

impl Rock {
    // Get an infinite stream of rocks in the correct order.
    pub fn infinite_stream() -&gt; std::iter::Cycle&lt;std::vec::IntoIter&lt;Rock&gt;&gt; {
        vec![
            Self::Minus,
            Self::Plus,
            Self::InverseL,
            Self::I,
            Self::Block,
        ]
        .into_iter()
        .cycle()
    }

    // We order the returned positions in such a way that we have the highest likelihood of getting
    // a collision early on.
    pub fn occupied_fields(&amp;self, start: &amp;Pos) -&gt; std::vec::IntoIter&lt;Pos&gt; {
        match self {
            Self::Minus =&gt; vec![
                Pos {
                    x: 0 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 3 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 1 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 2 + start.x,
                    y: 0 + start.y,
                },
            ],
            // This one has no rock at 0,0!
            Self::Plus =&gt; vec![
                Pos {
                    x: 1 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 2 + start.x,
                    y: 1 + start.y,
                },
                Pos {
                    x: 0 + start.x,
                    y: 1 + start.y,
                },
                Pos {
                    x: 1 + start.x,
                    y: 1 + start.y,
                },
                Pos {
                    x: 1 + start.x,
                    y: 2 + start.y,
                },
            ],
            Self::Block =&gt; vec![
                Pos {
                    x: 0 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 1 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 0 + start.x,
                    y: 1 + start.y,
                },
                Pos {
                    x: 1 + start.x,
                    y: 1 + start.y,
                },
            ],
            Self::I =&gt; vec![
                Pos {
                    x: 0 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 0 + start.x,
                    y: 3 + start.y,
                },
                Pos {
                    x: 0 + start.x,
                    y: 1 + start.y,
                },
                Pos {
                    x: 0 + start.x,
                    y: 2 + start.y,
                },
            ],
            Self::InverseL =&gt; vec![
                Pos {
                    x: 0 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 1 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 2 + start.x,
                    y: 0 + start.y,
                },
                Pos {
                    x: 2 + start.x,
                    y: 1 + start.y,
                },
                Pos {
                    x: 2 + start.x,
                    y: 2 + start.y,
                },
            ],
        }
        .into_iter()
    }
}

impl Stream {
    // This consumes the stream object, but we don't need it anymore.
    pub fn infinite(self) -&gt; std::iter::Cycle&lt;std::vec::IntoIter&lt;Push&gt;&gt; {
        self.flow.into_iter().cycle()
    }
}

impl FromStr for Stream {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        Ok(Self {
            flow: s
                .chars()
                .map(|el| match el {
                    '&gt;' =&gt; Push::Right,
                    '&lt;' =&gt; Push::Left,
                    _ =&gt; panic!("oh no, we got weird input"),
                })
                .collect(),
        })
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_17"><a class="anchor" href="#_how_to_run_17"></a><a class="link" href="#_how_to_run_17">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day18" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_18_rust"><a class="anchor" href="#_day_18_rust"></a><a class="link" href="#_day_18_rust">Day 18: rust</a></h3>
<div class="sect3">
<h4 id="_day_18_boiling_boulders"><a class="anchor" href="#_day_18_boiling_boulders"></a><a class="link" href="#_day_18_boiling_boulders">Day 18: Boiling Boulders</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_16"><a class="anchor" href="#_oveview_16"></a><a class="link" href="#_oveview_16">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_17"><a class="anchor" href="#_solution_17"></a><a class="link" href="#_solution_17">Solution</a></h5>
<div class="paragraph">
<p>Today was easy, yeah!
For part 1, simply put all lava points in a set.
Then, for each lava point, check for each neighbour whether that one is a lava
point itself.
If not, count it.</p>
</div>
<div class="paragraph">
<p>Part 2 was a bit more tricky and I lost some time due to an overflow that I
didn&#8217;t notice at first.
(Note to self: Always run in development mode first and only switch to release
mode if the speed up is needed because release mode will silently ignore
overflows.)</p>
</div>
<div class="paragraph">
<p>I was wondering how to detect air pockets.
My idea was to repurpose the <code>A*</code> algorithm developed for day 12.
I first extended it to 3 dimensions, which was straightforward.
Then, I found the smallest cuboid that contains all lava.
Then, I had <code>A*</code> search a path from each block in that cuboid to a block in a
top corner.
To ensure that I would always be able to find a path from any block that is
conncted to the outside, I added one layer of air to each of the 6 sides of the
cuboid.
Whenever I could not find a path, all blocks that the algorithm looked at are
known to be part of air pockets.
Whenever a path could be found, all blocks that the algorithm looked at are
known to not be air pockets.
That helps reduce the number of blocks to look at.</p>
</div>
<div class="paragraph">
<p>In the end, I fill all air pockets with fake lava and apply the same algorithm
from part 1 again.
I guess a breadth first search would have been more applicable, but I already
had a working pathfinding algorithm, so I repurposed it.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
// Constants.

fn find_path&lt;'a&gt;(
    start: &amp;'a data::Node,
    end: &amp;'a data::Node,
    graph: &amp;'a HashSet&lt;data::Node&gt;,
    estimator_fn: fn(&amp;data::Node, &amp;data::Point) -&gt; usize,
) -&gt; Result&lt;HashMap&lt;&amp;'a data::Node, (Option&lt;data::Point&gt;, usize)&gt;&gt; {
    let ref_point = end.pos();
    let estimator = move |node: &amp;data::Node| estimator_fn(node, &amp;ref_point);
    let get_node = move |node: &amp;data::Point| {
        graph
            .get(&amp;node.as_node())
            .ok_or(Error::msg("node not found"))
    };

    let mut connections = HashMap::&lt;&amp;'a data::Node, (Option&lt;data::Point&gt;, usize)&gt;::new();
    let mut checkable = HashMap::&lt;&amp;data::Node, (data::Point, usize)&gt;::new();

    // Add starting point to resulting path.
    connections.insert(&amp;start, (None, 0));
    // Add neighbours of starting point to list of checkable values. Ignore neighbouring points
    // that are not part of the graph.
    for neigh in start.neighbours() {
        let neigh_node = get_node(neigh)?;
        // Estimated costs are the most direct possible connection plus 1, since every step costs
        // one.
        checkable.insert(neigh_node, (start.pos(), estimator(neigh_node)));
        // connections.insert(neigh_node, (Some(start.pos()), 1));
    }

    // Search until we added the final node to the path or until there is nothing more to check.
    while !connections.contains_key(&amp;end) &amp;&amp; checkable.len() &gt; 0 {
        // Get node with minimum _estimated_ cost.
        let next_best_node = checkable
            .iter_mut()
            // Get node with minimum estimated cost.
            .min_by(|(_node1, (_pre1, cost1)), (_node2, (_pre2, cost2))| cost1.cmp(&amp;cost2))
            .ok_or(Error::msg("cannot find next node"))?
            .0
            .clone();
        let (_, (predecessor, _old_estimate)) = checkable
            .remove_entry(next_best_node)
            .ok_or(Error::msg("cannot find predecessor"))?;

        let cost_of_predecessor = connections
            .get(&amp;predecessor.as_node())
            .ok_or(Error::msg("predecessor has not been visited"))?
            .1;

        // Add point to resulting path.
        connections.insert(next_best_node, (Some(predecessor), cost_of_predecessor + 1));

        // Add neighbours of point to list of checkable values.
        for neigh in next_best_node.neighbours() {
            let neigh_node = get_node(neigh)?;
            if !connections.contains_key(neigh_node) {
                let estimate = cost_of_predecessor + estimator(neigh_node);
                let previous_best = checkable
                    .get(neigh_node)
                    .unwrap_or(&amp;(*neigh, std::usize::MAX))
                    .1;
                if previous_best &gt; estimate {
                    checkable.insert(neigh_node, (next_best_node.pos(), estimate));
                }
                // connections.insert(neigh_node, Some(start.pos()));
            }
        }
    }

    Ok(connections)
}

fn build_graph(
    lava: &amp;HashSet&lt;data::Point&gt;,
    min: &amp;data::Point,
    max: &amp;data::Point,
) -&gt; HashSet&lt;data::Node&gt; {
    let mut graph = HashSet::&lt;data::Node&gt;::new();

    for x in min.x..=max.x {
        for y in min.y..=max.y {
            for z in min.z..=max.z {
                let point = data::Point { x, y, z };
                // Ignore points that are themselves lava.
                if let Some(_) = lava.get(&amp;point) {
                    continue;
                }
                // Find all neihhbours, which are points that are still within the boundaries and
                // not lava.
                let neighbours = point
                    .env()
                    .into_iter()
                    .filter_map(|el| {
                        // The point does not contain lava.
                        if let None = lava.get(&amp;el) {
                            // The point is still within the cube boundaries.
                            if el.x &gt;= min.x
                                &amp;&amp; el.x &lt;= max.x
                                &amp;&amp; el.y &gt;= min.y
                                &amp;&amp; el.y &lt;= max.y
                                &amp;&amp; el.z &gt;= min.z
                                &amp;&amp; el.z &lt;= max.z
                            {
                                Some(el)
                            } else {
                                None
                            }
                        } else {
                            None
                        }
                    })
                    .collect();
                let node = data::Node {
                    p: point,
                    neighbours,
                };
                graph.insert(node);
            }
        }
    }

    graph
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    println!("PROCESSING {}", file);

    // Read file and convert into data.
    let lava_lines = io::parse_chunks_to_data::&lt;data::Point&gt;(
        io::read_lines_from_file(file, 1)?,
        "pos",
        None,
        None,
    )?;

    // Part 1.

    let lava = HashSet::&lt;data::Point&gt;::from_iter(lava_lines.into_iter());

    let surface_area_part1 = lava
        .iter()
        .map(|el| el.env().into_iter())
        .flatten()
        .filter(|el| !lava.contains(el))
        .count();

    println!("for part 1, the surface area is {}", surface_area_part1);

    // Part 2.
    let min_x = lava
        .iter()
        .map(|el| el.x)
        .min()
        .ok_or(Error::msg("min x"))?;
    let max_x = lava
        .iter()
        .map(|el| el.x)
        .max()
        .ok_or(Error::msg("max x"))?;
    let min_y = lava
        .iter()
        .map(|el| el.y)
        .min()
        .ok_or(Error::msg("min y"))?;
    let max_y = lava
        .iter()
        .map(|el| el.y)
        .max()
        .ok_or(Error::msg("max y"))?;
    let min_z = lava
        .iter()
        .map(|el| el.z)
        .min()
        .ok_or(Error::msg("min z"))?;
    let max_z = lava
        .iter()
        .map(|el| el.z)
        .max()
        .ok_or(Error::msg("max z"))?;

    let min = data::Point {
        x: min_x - 1,
        y: min_y - 1,
        z: min_z - 1,
    };
    // Max is also the target for the pahtfinding algorithm.
    let max = data::Point {
        x: max_x + 1,
        y: max_y + 1,
        z: max_z + 1,
    };

    // Construct graph that does not contain diagonal connections.
    let graph = build_graph(&amp;lava, &amp;min, &amp;max);
    // This is the heuristic needed for A*.
    let estimator = |node: &amp;data::Node, ref_point: &amp;data::Point| node.infinity_dist(&amp;ref_point);
    // Define the end point of the paht finding.
    let end = graph
        .get(&amp;max.as_node())
        .ok_or(Error::msg("cannot find end node in graph"))?;

    // println!("{:?}", graph);

    let mut air_pockets = HashSet::&lt;data::Point&gt;::new();
    let mut no_air_pockets = HashSet::&lt;data::Point&gt;::new();

    for x in min.x..=max.x {
        for y in min.y..=max.y {
            for z in min.z..=max.z {
                let start_point = data::Point { x, y, z };
                if let Some(_) = lava.get(&amp;start_point) {
                    // Do not try to find paths that start at lava.
                    continue;
                }
                if let Some(_) = air_pockets.get(&amp;start_point) {
                    // Do not try to find paths that start at air pockets.
                    continue;
                }
                if let Some(_) = no_air_pockets.get(&amp;start_point) {
                    // Do not try to find paths that start at a connected point.
                    continue;
                }
                let start = graph
                    .get(&amp;start_point.as_node())
                    .ok_or(Error::msg("cannot find start node in graph"))?;
                // try to find the path to the max node.
                let path = find_path(&amp;start, &amp;end, &amp;graph, estimator)?;
                // If the end node is not in the found path, we discovered an air pocket.
                if let None = path.get(&amp;end) {
                    air_pockets = &amp;air_pockets | &amp;path.into_iter().map(|el| el.0.p).collect();
                } else {
                    no_air_pockets = &amp;no_air_pockets | &amp;path.into_iter().map(|el| el.0.p).collect();
                }
            }
        }
    }

    let lava_with_filled_pockets = &amp;lava | &amp;air_pockets;

    // println!("{} =&gt; {:?} {:?}", lava.len(), min, max,);

    let surface_area_part2 = lava_with_filled_pockets
        .iter()
        .map(|el| el.env().into_iter())
        .flatten()
        .filter(|el| !lava_with_filled_pockets.contains(el))
        .count();

    println!("for part 2, the surface area is {}", surface_area_part2);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE1)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::str::FromStr;

#[derive(Debug, Hash, Eq, PartialEq, Clone, Copy)]
pub struct Point {
    pub x: i8,
    pub y: i8,
    pub z: i8,
}

impl Point {
    pub fn add(&amp;self, other: &amp;Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
        }
    }

    pub fn env(&amp;self) -&gt; Vec&lt;Self&gt; {
        vec![
            Self {
                x: self.x - 1,
                y: self.y,
                z: self.z,
            },
            Self {
                x: self.x + 1,
                y: self.y,
                z: self.z,
            },
            Self {
                x: self.x,
                y: self.y - 1,
                z: self.z,
            },
            Self {
                x: self.x,
                y: self.y + 1,
                z: self.z,
            },
            Self {
                x: self.x,
                y: self.y,
                z: self.z - 1,
            },
            Self {
                x: self.x,
                y: self.y,
                z: self.z + 1,
            },
        ]
    }

    pub fn as_node(&amp;self) -&gt; Node {
        Node {
            p: *self,
            neighbours: HashSet::&lt;Point&gt;::new(),
        }
    }
}

impl FromStr for Point {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split(",").collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [x, y, z] =&gt; Ok(Self {
                x: x.parse()?,
                y: y.parse()?,
                z: z.parse()?,
            }),
            _ =&gt; Err(Error::msg("cannot parse pos")),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Node {
    pub p: Point,
    pub neighbours: HashSet&lt;Point&gt;,
}

impl Node {
    pub fn pos(&amp;self) -&gt; Point {
        self.p
    }

    pub fn neighbours&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a HashSet&lt;Point&gt; {
        &amp;self.neighbours
    }

    pub fn infinity_dist(&amp;self, other: &amp;Point) -&gt; usize {
        (self.p.x - other.x).abs() as usize
            + (self.p.y - other.y).abs() as usize
            + (self.p.z - other.z).abs() as usize
    }
}

// We identify a node only by its position.
impl Hash for Node {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.p.hash(state)
    }
}

impl PartialEq for Node {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.p == other.p
    }
}
impl Eq for Node {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_18"><a class="anchor" href="#_how_to_run_18"></a><a class="link" href="#_how_to_run_18">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day19" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_19_rust"><a class="anchor" href="#_day_19_rust"></a><a class="link" href="#_day_19_rust">Day 19: rust</a></h3>
<div class="sect3">
<h4 id="_day_19_not_enough_minerals"><a class="anchor" href="#_day_19_not_enough_minerals"></a><a class="link" href="#_day_19_not_enough_minerals">Day 19: Not Enough Minerals</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_17"><a class="anchor" href="#_oveview_17"></a><a class="link" href="#_oveview_17">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_18"><a class="anchor" href="#_solution_18"></a><a class="link" href="#_solution_18">Solution</a></h5>
<div class="paragraph">
<p>Today, I first went on a wild goose chase because I had a fancy idea, which
totally didn&#8217;t work out but cost quite a bit of time.
My second attempt was thus a straightforward implementation of the instructions
with a cache because state values often reapeat themselves.
The cache associates each world state with its best geode value.
Note that a state includes the remaining simulation time.
Thus, if we find a value that&#8217;s in the cache, we can avoid go compute the same
world progression again because the state uniquely identifies how the world will
progress from that point on.</p>
</div>
<div class="paragraph">
<p>In my input for part 1, there was one blueprint that didn&#8217;t work out with a
straightforward implementation of the cache.
That is, the cache grew so large that my computer ran out of RAM.
Thus, I only cached values until some time steps before the end.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
// Constants.
const LRU_THRESHOLD: data::Size = 8;

fn is_env(var: &amp;str, val: &amp;str, def: &amp;str) -&gt; bool {
    std::env::var(var).unwrap_or(def.to_string()) == val
}

fn exhaustive_search(
    state: data::State,
    bp: &amp;data::Blueprint,
    actions: &amp;Vec&lt;data::WhatToBuild&gt;,
    lru: &amp;mut HashMap&lt;data::State, data::Size&gt;,
    total_best: &amp;mut data::Size,
) -&gt; data::Size {
    if state.time == 0 {
        return state.geode;
    } else if state.time &gt;= LRU_THRESHOLD {
        if let Some(lru_val) = lru.get(&amp;state) {
            return *lru_val;
        }
    } else if state.geode + state.time * state.geode_robots + state.time * state.time &lt; *total_best
    {
        // Return early if a very optimistic estimate of what we can still achieve is lower than
        // the best we've already found.
        return state.geode;
    }

    let mut best = state.geode;

    for act in actions.iter() {
        if let Some(next) = state.next(bp, act) {
            let possible_best = exhaustive_search(next, bp, actions, lru, total_best);
            if possible_best &gt; best {
                best = possible_best;
                if best &gt; *total_best {
                    *total_best = best;
                }
            }
        }
    }

    // Remember the value we found, but only for early ones.
    if state.time &gt;= LRU_THRESHOLD {
        lru.insert(state, best);
    }

    return best;
}

fn solve(file: &amp;str, part1: bool) -&gt; Result&lt;()&gt; {
    println!("PROCESSING {}", file);

    // Read file and convert into data.
    let blueprints = io::parse_chunks_to_data::&lt;data::Blueprint&gt;(
        io::read_lines_from_file(file, 1)?,
        "blueprint",
        None,
        None,
    )?;

    let actions = vec![
        data::WhatToBuild::GeodeR,
        data::WhatToBuild::ObsidianR,
        data::WhatToBuild::ClayR,
        data::WhatToBuild::OreR,
        data::WhatToBuild::Nothing,
    ];

    if part1 {
        let mut best_vals = vec![];

        for (idx, bp) in blueprints.iter().enumerate() {
            let mut lru = HashMap::&lt;data::State, data::Size&gt;::new();
            let state = data::State::start(24);
            let mut best_cache = 0;
            let best = exhaustive_search(state, bp, &amp;actions, &amp;mut lru, &amp;mut best_cache);
            println!("best for {} is {}", idx + 1, best);
            best_vals.push(best);
        }

        let quality_level = best_vals
            .into_iter()
            .zip(blueprints.iter())
            .map(|(val, bp)| bp.id as usize * val as usize)
            .sum::&lt;usize&gt;();

        println!("the overall quality level is: {}", quality_level);
    } else {
        let mut best_vals = vec![];

        for (idx, bp) in blueprints.iter().take(3).enumerate() {
            // Sadly, we cannot reuse the LRU cache for other blueprints.
            let mut lru = HashMap::&lt;data::State, data::Size&gt;::new();
            let mut best_cache = 0;
            let state = data::State::start(32);
            let best = exhaustive_search(state, bp, &amp;actions, &amp;mut lru, &amp;mut best_cache);
            println!("best for {} is {}", idx + 1, best);
            best_vals.push(best);
        }

        let quality_level = best_vals
            .into_iter()
            .map(|el| el as usize)
            .product::&lt;usize&gt;();

        println!("the overall quality level is: {}", quality_level);
    }

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Run none by default.
    if is_env("RUN", "0", "") {
        solve(SAMPLE1, true)?;
    }
    if is_env("RUN", "1", "") {
        solve(REAL, true)?;
    }

    if is_env("RUN", "2", "") {
        solve(SAMPLE1, false)?;
    }
    if is_env("RUN", "3", "") {
        solve(REAL, false)?;
    }

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use rand::distributions::{Distribution, Standard};
use rand::Rng;
use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::str::FromStr;

pub type Size = u16;

#[derive(Debug, Clone)]
pub struct Blueprint {
    pub id: Size,
    pub ore_ore_cost: Size,
    pub clay_ore_cost: Size,
    pub obsidian_ore_cost: Size,
    pub obsidian_clay_cost: Size,
    pub geode_ore_cost: Size,
    pub geode_obsidian_cost: Size,
}

#[derive(Debug, PartialEq)]
pub enum WhatToBuild {
    OreR,
    ClayR,
    ObsidianR,
    GeodeR,
    Nothing,
}

impl FromStr for Blueprint {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["Blueprint", id, "Each", "ore", "robot", "costs", ore_ore_cost, "ore.", "Each", "clay", "robot", "costs", clay_ore_cost, "ore.", "Each", "obsidian", "robot", "costs", obsidian_ore_cost, "ore", "and", obsidian_clay_cost, "clay.", "Each", "geode", "robot", "costs", geode_ore_cost, "ore", "and", geode_obsidian_cost, "obsidian."] =&gt; {
                Ok(Self {
                    id: id.trim_end_matches(":").parse()?,
                    ore_ore_cost: ore_ore_cost.parse()?,
                    clay_ore_cost: clay_ore_cost.parse()?,
                    obsidian_ore_cost: obsidian_ore_cost.parse()?,
                    obsidian_clay_cost: obsidian_clay_cost.parse()?,
                    geode_ore_cost: geode_ore_cost.parse()?,
                    geode_obsidian_cost: geode_obsidian_cost.parse()?,
                })
            }
            _ =&gt; Err(Error::msg("cannot parse blueprint")),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Hash)]
pub struct State {
    pub time: Size,
    pub ore: Size,
    pub ore_robots: Size,
    pub clay: Size,
    pub clay_robots: Size,
    pub obsidian: Size,
    pub obsidian_robots: Size,
    pub geode: Size,
    pub geode_robots: Size,
}

impl State {
    pub fn start(available_time: Size) -&gt; Self {
        Self {
            time: available_time,
            ore: 0,
            ore_robots: 1,
            clay: 0,
            clay_robots: 0,
            obsidian: 0,
            obsidian_robots: 0,
            geode: 0,
            geode_robots: 0,
        }
    }

    pub fn next(&amp;self, bp: &amp;Blueprint, act: &amp;WhatToBuild) -&gt; Option&lt;Self&gt; {
        // Only perform the drawn operation if we have enough resources for it. Otherwise,
        // implicitly perform a "nothing" operation.
        match act {
            WhatToBuild::Nothing =&gt; {
                Some(Self {
                    time: self.time - 1,
                    // Materials.
                    ore: self.ore + self.ore_robots,
                    clay: self.clay + self.clay_robots,
                    obsidian: self.obsidian + self.obsidian_robots,
                    geode: self.geode + self.geode_robots,
                    // Robots.
                    ore_robots: self.ore_robots,
                    clay_robots: self.clay_robots,
                    obsidian_robots: self.obsidian_robots,
                    geode_robots: self.geode_robots,
                })
            }
            WhatToBuild::OreR =&gt; {
                if self.ore &lt; bp.ore_ore_cost {
                    None
                } else {
                    Some(Self {
                        time: self.time - 1,
                        // Materials.
                        ore: self.ore + self.ore_robots - bp.ore_ore_cost,
                        clay: self.clay + self.clay_robots,
                        obsidian: self.obsidian + self.obsidian_robots,
                        geode: self.geode + self.geode_robots,
                        // Robots.
                        ore_robots: self.ore_robots + 1,
                        clay_robots: self.clay_robots,
                        obsidian_robots: self.obsidian_robots,
                        geode_robots: self.geode_robots,
                    })
                }
            }
            WhatToBuild::ClayR =&gt; {
                if self.ore &lt; bp.clay_ore_cost {
                    None
                } else {
                    Some(Self {
                        time: self.time - 1,
                        // Materials.
                        ore: self.ore + self.ore_robots - bp.clay_ore_cost,
                        clay: self.clay + self.clay_robots,
                        obsidian: self.obsidian + self.obsidian_robots,
                        geode: self.geode + self.geode_robots,
                        // Robots.
                        ore_robots: self.ore_robots,
                        clay_robots: self.clay_robots + 1,
                        obsidian_robots: self.obsidian_robots,
                        geode_robots: self.geode_robots,
                    })
                }
            }
            WhatToBuild::ObsidianR =&gt; {
                if self.ore &lt; bp.obsidian_ore_cost || self.clay &lt; bp.obsidian_clay_cost {
                    None
                } else {
                    Some(Self {
                        time: self.time - 1,
                        // Materials.
                        ore: self.ore + self.ore_robots - bp.obsidian_ore_cost,
                        clay: self.clay + self.clay_robots - bp.obsidian_clay_cost,
                        obsidian: self.obsidian + self.obsidian_robots,
                        geode: self.geode + self.geode_robots,
                        // Robots.
                        ore_robots: self.ore_robots,
                        clay_robots: self.clay_robots,
                        obsidian_robots: self.obsidian_robots + 1,
                        geode_robots: self.geode_robots,
                    })
                }
            }
            WhatToBuild::GeodeR =&gt; {
                if self.ore &lt; bp.geode_ore_cost || self.obsidian &lt; bp.geode_obsidian_cost {
                    None
                } else {
                    Some(Self {
                        time: self.time - 1,
                        // Materials.
                        ore: self.ore + self.ore_robots - bp.geode_ore_cost,
                        clay: self.clay + self.clay_robots,
                        obsidian: self.obsidian + self.obsidian_robots - bp.geode_obsidian_cost,
                        geode: self.geode + self.geode_robots,
                        // Robots.
                        ore_robots: self.ore_robots,
                        clay_robots: self.clay_robots,
                        obsidian_robots: self.obsidian_robots,
                        geode_robots: self.geode_robots + 1,
                    })
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_19"><a class="anchor" href="#_how_to_run_19"></a><a class="link" href="#_how_to_run_19">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>