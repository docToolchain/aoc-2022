<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: razziel89</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_razziel89">razziel89</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_01_calorie_counting">Day 01: Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_oveview">Oveview</a></li>
<li><a href="#_how_to_run">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_02_rock_paper_scissors">Day 02: Rock Paper Scissors</a>
<ul class="sectlevel4">
<li><a href="#_oveview_2">Oveview</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_how_to_run_2">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_03_rucksack_reorganization">Day 03: Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_oveview_3">Oveview</a></li>
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_how_to_run_3">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_04_camp_cleanup">Day 04: Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_oveview_4">Oveview</a></li>
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_how_to_run_4">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_05_supply_stacks">Day 05: Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_solution_4">Solution</a></li>
<li><a href="#_how_to_run_5">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_06_tuning_trouble">Day 06: Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_overview_2">Overview</a></li>
<li><a href="#_solution_5">Solution</a></li>
<li><a href="#_how_to_run_6">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_rust">Day 07: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_07_no_space_left_on_device">Day 07: No Space Left On device</a>
<ul class="sectlevel4">
<li><a href="#_oveview_5">Oveview</a></li>
<li><a href="#_solution_6">Solution</a></li>
<li><a href="#_how_to_run_7">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_rust">Day 08: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_08_treetop_tree_house">Day 08: Treetop Tree House</a>
<ul class="sectlevel4">
<li><a href="#_oveview_6">Oveview</a></li>
<li><a href="#_solution_7">Solution</a></li>
<li><a href="#_how_to_run_8">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_09_rust">Day 09: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_09_rope_bridge">Day 09: Rope Bridge</a>
<ul class="sectlevel4">
<li><a href="#_oveview_7">Oveview</a></li>
<li><a href="#_solution_8">Solution</a></li>
<li><a href="#_how_to_run_9">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_10_rust">Day 10: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a>
<ul class="sectlevel4">
<li><a href="#_oveview_8">Oveview</a></li>
<li><a href="#_solution_9">Solution</a></li>
<li><a href="#_how_to_run_10">How to run</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_razziel89"><a class="anchor" href="#_razziel89"></a><a class="link" href="#_razziel89">razziel89</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/10134766?v=4" alt="10134766?v=4"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>razziel89</strong><br>
<span class="icon"><i class="fa fa-github"></i></span>: <a href="https://github.com/razziel89">razziel89</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>Nothing here yet. Update your profile at <a href="https://github.com/docToolchain/aoc-2022/blob/master/profiles/razziel89.adoc">/profiles/razziel89.adoc</a></p>
</div>
<a id="day01" />
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_01_calorie_counting"><a class="anchor" href="#_day_01_calorie_counting"></a><a class="link" href="#_day_01_calorie_counting">Day 01: Calorie Counting</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the calorie counting puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview"><a class="anchor" href="#_oveview"></a><a class="link" href="#_oveview">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.go</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
const NUM_ELVES: usize = 3;

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let baggage = io::parse_lines_to_data::&lt;data::Baggage&gt;(file, "baggage")?;

    let mut elves = data::baggages_to_elves(baggage);

    // Elf carrying the most calories will be first in line. It is inefficient to calculate total
    // calories for every comparison, but it's not really important for this exercise.
    elves.sort_by(|el1, el2| el2.total_calories().cmp(&amp;el1.total_calories()));

    match elves.len() {
        // Even though we could solve part 1 if we had 1..=2 elves, we ignore that case here.
        0..=2 =&gt; Err(Error::msg("somehow, we found too few elves :(")),
        _ =&gt; {
            // Part 1.
            println!(
                "elf carrying the most is num {} who carries {} calories",
                elves[0].get_idx(),
                elves[0].total_calories()
            );

            // Part 2.
            let total_calories: u64 = elves
                .iter()
                .take(NUM_ELVES)
                .map(|el| el.total_calories())
                .sum();

            println!(
                "the {} elves carrying the most carry {} in total\n",
                NUM_ELVES, total_calories
            );

            Ok(())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum Baggage {
    Calories(u64),
    EndOfElf,
}

#[derive(Debug)]
pub struct Elf {
    idx: usize,
    baggage: Vec&lt;Baggage&gt;,
}

impl FromStr for Baggage {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "" =&gt; Ok(Baggage::EndOfElf),
            val =&gt; Ok(Baggage::Calories(val.parse::&lt;u64&gt;()?)),
        }
    }
}

impl Elf {
    pub fn total_calories(&amp;self) -&gt; u64 {
        self.baggage
            .iter()
            .map(|el| match el {
                Baggage::Calories(val) =&gt; val,
                Baggage::EndOfElf =&gt; &amp;0,
            })
            .sum()
    }

    pub fn get_idx(&amp;self) -&gt; usize {
        self.idx
    }
}

pub fn baggages_to_elves(baggage: Vec&lt;Baggage&gt;) -&gt; Vec&lt;Elf&gt; {
    let mut elves = vec![];
    let mut elf = Elf {
        idx: 1,
        baggage: vec![],
    };

    for el in baggage {
        match el {
            Baggage::Calories(_) =&gt; {
                elf.baggage.push(el);
            }
            Baggage::EndOfElf =&gt; {
                let next_elf = Elf {
                    idx: elf.idx + 1,
                    baggage: vec![],
                };
                elves.push(elf);
                elf = next_elf;
            }
        }
    }

    elves
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run"><a class="anchor" href="#_how_to_run"></a><a class="link" href="#_how_to_run">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_02_rock_paper_scissors"><a class="anchor" href="#_day_02_rock_paper_scissors"></a><a class="link" href="#_day_02_rock_paper_scissors">Day 02: Rock Paper Scissors</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the RPS puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_2"><a class="anchor" href="#_oveview_2"></a><a class="link" href="#_oveview_2">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>This one was pretty straightforward.
I might have taken enums in Rust a bit far, here, but I wanted to use them since
Go, the language used last year, doesn&#8217;t have enums.
I also tried out a custom trait so that I could use generics to determine which
round it was.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;
// Constants.
// None yet.

fn solve&lt;T&gt;(file: &amp;str) -&gt; Result&lt;()&gt;
where
    T: FromStr&lt;Err = Error&gt;,
    T: data::Round,
{
    eprintln!("PROCESSING {}", file);

    let mut scores = (0, 0);

    // Read file and convert into data.
    let rounds = io::parse_lines_to_data::&lt;T&gt;(file, "rounds")?;

    for round in rounds {
        let round_scores = round.score();
        scores = (scores.0 + round_scores.0, scores.1 + round_scores.1);
    }

    println!("scores are opponent: {}, you: {}\n", scores.0, scores.1);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.
    solve::&lt;data::RoundPart1&gt;(SAMPLE)?;
    solve::&lt;data::RoundPart1&gt;(REAL)?;

    solve::&lt;data::RoundPart2&gt;(SAMPLE)?;
    solve::&lt;data::RoundPart2&gt;(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum RPS {
    R,
    P,
    S,
}

#[derive(Debug)]
pub enum Outcome {
    Win,
    Loss,
    Draw,
}

// This trait is used so that we don't have to care which round we're scoring.
pub trait Round {
    fn score(&amp;self) -&gt; (usize, usize);
}

#[derive(Debug)]
pub struct RoundPart1 {
    other: RPS,
    me: RPS,
}

#[derive(Debug)]
pub struct RoundPart2 {
    other: RPS,
    outcome: Outcome,
}

impl FromStr for RPS {
    type Err = Error;

    // This parser can be used for rounds 1 and 2.
    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "A" | "X" =&gt; Ok(RPS::R),
            "B" | "Y" =&gt; Ok(RPS::P),
            "C" | "Z" =&gt; Ok(RPS::S),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as RPS", s))),
        }
    }
}

impl FromStr for Outcome {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "X" =&gt; Ok(Outcome::Loss),
            "Y" =&gt; Ok(Outcome::Draw),
            "Z" =&gt; Ok(Outcome::Win),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as Outcome", s))),
        }
    }
}

impl FromStr for RoundPart1 {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [other, me] =&gt; {
                // Other error.
                if !["A", "B", "C"].contains(other) {
                    Err(Error::msg(format!("unknown value {} for other", other)))
                // Me error.
                } else if !["X", "Y", "Z"].contains(me) {
                    Err(Error::msg(format!("unknown value {} for me", me)))
                // Success case.
                } else {
                    Ok(RoundPart1 {
                        other: other.parse::&lt;RPS&gt;()?,
                        me: me.parse::&lt;RPS&gt;()?,
                    })
                }
            }
            _ =&gt; Err(Error::msg(format!("cannot parse {}", s))),
        }
    }
}

impl FromStr for RoundPart2 {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [other, result] =&gt; {
                // Other error.
                if !["A", "B", "C"].contains(other) {
                    Err(Error::msg(format!("unknown value {} for other", other)))
                // Success case.
                } else {
                    Ok(RoundPart2 {
                        other: other.parse::&lt;RPS&gt;()?,
                        outcome: result.parse::&lt;Outcome&gt;()?,
                    })
                }
            }
            _ =&gt; Err(Error::msg(format!("cannot parse {}", s))),
        }
    }
}

impl Outcome {
    fn score(&amp;self) -&gt; usize {
        match &amp;self {
            Outcome::Loss =&gt; 0,
            Outcome::Draw =&gt; 3,
            Outcome::Win =&gt; 6,
        }
    }
}

impl RPS {
    fn score(&amp;self) -&gt; usize {
        match self {
            RPS::R =&gt; 1,
            RPS::P =&gt; 2,
            RPS::S =&gt; 3,
        }
    }

    // Needed for round 1. This function could benefit from testing so that we know the result if
    // called with (a, b) and (b, a) make sense.
    fn check_win(&amp;self, other: &amp;RPS) -&gt; Outcome {
        match (self, other) {
            // Self rock.
            (RPS::R, RPS::R) =&gt; Outcome::Draw,
            (RPS::R, RPS::P) =&gt; Outcome::Loss,
            (RPS::R, RPS::S) =&gt; Outcome::Win,
            // Self paper.
            (RPS::P, RPS::R) =&gt; Outcome::Win,
            (RPS::P, RPS::P) =&gt; Outcome::Draw,
            (RPS::P, RPS::S) =&gt; Outcome::Loss,
            // Self scissors.
            (RPS::S, RPS::R) =&gt; Outcome::Loss,
            (RPS::S, RPS::P) =&gt; Outcome::Win,
            (RPS::S, RPS::S) =&gt; Outcome::Draw,
        }
    }

    // Needed for round 2. This is called on the other's value with a desired outcome.
    fn get_reply(&amp;self, result: &amp;Outcome) -&gt; RPS {
        match (self, result) {
            // Rock.
            (RPS::R, Outcome::Loss) =&gt; RPS::S,
            (RPS::R, Outcome::Draw) =&gt; RPS::R,
            (RPS::R, Outcome::Win) =&gt; RPS::P,
            // Paper.
            (RPS::P, Outcome::Loss) =&gt; RPS::R,
            (RPS::P, Outcome::Draw) =&gt; RPS::P,
            (RPS::P, Outcome::Win) =&gt; RPS::S,
            // Scissors.
            (RPS::S, Outcome::Loss) =&gt; RPS::P,
            (RPS::S, Outcome::Draw) =&gt; RPS::S,
            (RPS::S, Outcome::Win) =&gt; RPS::R,
        }
    }
}

// It turns out we do not need to track the other's score, but we only knew that after the fact...
impl Round for RoundPart1 {
    fn score(&amp;self) -&gt; (usize, usize) {
        (
            self.other.score() + self.other.check_win(&amp;self.me).score(),
            self.me.score() + self.me.check_win(&amp;self.other).score(),
        )
    }
}

impl Round for RoundPart2 {
    fn score(&amp;self) -&gt; (usize, usize) {
        let reply = self.other.get_reply(&amp;self.outcome);
        (
            self.other.score() + self.other.check_win(&amp;reply).score(),
            reply.score() + reply.check_win(&amp;self.other).score(),
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_2"><a class="anchor" href="#_how_to_run_2"></a><a class="link" href="#_how_to_run_2">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_03_rucksack_reorganization"><a class="anchor" href="#_day_03_rucksack_reorganization"></a><a class="link" href="#_day_03_rucksack_reorganization">Day 03: Rucksack Reorganization</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the rucksack reorganization puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_3"><a class="anchor" href="#_oveview_3"></a><a class="link" href="#_oveview_3">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_2"><a class="anchor" href="#_solution_2"></a><a class="link" href="#_solution_2">Solution</a></h5>
<div class="paragraph">
<p>This one was straightforward, but I am not too happy with how the solution
looks.
Working with the <code>HashSet</code> type was not as easy as I thought, e.g. when trying
to compute the overlap of multiple sets.
Furthermore, I somehow misunderstood part 2 at first, which lead me on a wild
goose chase.
Still, this works, but I lack the time to provid more details about the
implementation.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn ord(c: char) -&gt; Result&lt;usize&gt; {
    match c {
        'a'..='z' =&gt; Ok((c as usize - 'a' as usize) + 1),
        'A'..='Z' =&gt; Ok((c as usize - 'A' as usize) + 27),
        _ =&gt; Err(Error::msg(format!(
            "invalid character {} for ord conversion",
            c,
        ))),
    }
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let rucksacks = io::parse_lines_to_data::&lt;data::Rucksack&gt;(file, "rucksack")?;

    // Part 1.
    let common = rucksacks
        .iter()
        .map(|el| (&amp;el.left &amp; &amp;el.right).into_iter().collect::&lt;Vec&lt;_&gt;&gt;())
        .enumerate()
        .map(|(idx, el)| {
            if el.len() == 1 {
                ord(el[0])
            } else {
                Err(Error::msg(format!(
                    "entry {} has wrong length {}",
                    idx,
                    el.len()
                )))
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    {
        let mut has_err = false;
        for c in common.as_slice() {
            if let Err(err) = c {
                eprintln!("{:?}", err);
                has_err = true;
            }
        }
        if has_err {
            return Err(Error::msg("encountered at least one error"));
        }
    }

    println!(
        "part 1, total value is {}",
        common.iter().flatten().sum::&lt;usize&gt;()
    );

    // Part 2.
    let badges = rucksacks
        .iter()
        .map(|el| el.everything())
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .chunks_exact(3)
        .into_iter()
        .map(|sets| {
            if let [set1, set2, set3] = sets {
                (&amp;(set1 &amp; set2) &amp; set3).into_iter().collect::&lt;Vec&lt;_&gt;&gt;()
            } else {
                panic!("this will never happen due to the use of exact_chunk")
            }
        })
        .enumerate()
        .map(|(idx, el)| {
            if el.len() == 1 {
                ord(el[0])
            } else {
                Err(Error::msg(format!(
                    "entry {} has wrong length {}",
                    idx,
                    el.len()
                )))
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "part 2, total value is {}",
        badges.iter().flatten().sum::&lt;usize&gt;()
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
use std::str::FromStr;

#[derive(Debug)]
pub struct Rucksack {
    pub left: HashSet&lt;char&gt;,
    pub right: HashSet&lt;char&gt;,
}

impl Rucksack {
    pub fn everything(&amp;self) -&gt; HashSet&lt;char&gt; {
        &amp;self.left | &amp;self.right
    }
}

impl FromStr for Rucksack {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let left = str_to_set(&amp;s[..s.len() / 2]);
        let right = str_to_set(&amp;s[s.len() / 2..]);
        Ok(Rucksack { left, right })
    }
}

fn str_to_set(s: &amp;str) -&gt; HashSet&lt;char&gt; {
    HashSet::from_iter(s.chars())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_3"><a class="anchor" href="#_how_to_run_3"></a><a class="link" href="#_how_to_run_3">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_04_camp_cleanup"><a class="anchor" href="#_day_04_camp_cleanup"></a><a class="link" href="#_day_04_camp_cleanup">Day 04: Camp Cleanup</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the camp cleanup puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_4"><a class="anchor" href="#_oveview_4"></a><a class="link" href="#_oveview_4">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_3"><a class="anchor" href="#_solution_3"></a><a class="link" href="#_solution_3">Solution</a></h5>
<div class="paragraph">
<p>This one was straightforward, which is why I tried my luck with a generic pair
type.
It worked out nicely as I only had to implemeng the parsing logic once but could
use it for two concrete types.
Then, it was just a matter of creating the methods that compute whether there is
a full (part 1) or partial (part 2) overlap between two ranges and to check for
overlaps in both directions (which is strictly not needed for part 2 but doesn&#8217;t
hurt).</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let pairs = io::parse_lines_to_data::&lt;data::Pair&gt;(file, "pair")?;

    let full_overlaps = pairs
        .iter()
        .filter_map(|el| if el.full_overlap() { Some(el) } else { None })
        .count();

    println!("there are {} full overlaps", full_overlaps);

    let partial_overlaps = pairs
        .iter()
        .filter_map(|el| if el.partial_overlap() { Some(el) } else { None })
        .count();

    println!("there are {} partial overlaps", partial_overlaps);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct GenPair&lt;T, const SEP: char&gt; {
    pub left: T,
    pub right: T,
}

#[derive(Debug)]
pub struct Num(usize);

impl FromStr for Num {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        Ok(Self(s.parse::&lt;usize&gt;()?))
    }
}

impl&lt;T, const SEP: char&gt; FromStr for GenPair&lt;T, { SEP }&gt;
where
    T: FromStr&lt;Err = Error&gt;,
{
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split(SEP).collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [left_str, right_str] =&gt; Ok(Self {
                left: left_str.parse::&lt;T&gt;()?,
                right: right_str.parse::&lt;T&gt;()?,
            }),
            _ =&gt; Err(Error::msg(format!(
                "cannot parse {} as pair with sep {}",
                s, SEP
            ))),
        }
    }
}

pub type Range = GenPair&lt;Num, '-'&gt;;
pub type Pair = GenPair&lt;Range, ','&gt;;

impl Range {
    fn contains(&amp;self, other: &amp;Range) -&gt; bool {
        self.left.0 &lt;= other.left.0 &amp;&amp; self.right.0 &gt;= other.right.0
    }

    fn overlap(&amp;self, other: &amp;Range) -&gt; bool {
        (self.left.0 &lt;= other.right.0 &amp;&amp; self.left.0 &gt;= other.left.0)
            || (self.right.0 &gt;= other.left.0 &amp;&amp; self.right.0 &lt;= other.right.0)
    }
}

impl Pair {
    pub fn full_overlap(&amp;self) -&gt; bool {
        self.left.contains(&amp;self.right) || self.right.contains(&amp;self.left)
    }

    pub fn partial_overlap(&amp;self) -&gt; bool {
        self.left.overlap(&amp;self.right) || self.right.overlap(&amp;self.left)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_4"><a class="anchor" href="#_how_to_run_4"></a><a class="link" href="#_how_to_run_4">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_05_supply_stacks"><a class="anchor" href="#_day_05_supply_stacks"></a><a class="link" href="#_day_05_supply_stacks">Day 05: Supply Stacks</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the supply stacks puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_overview"><a class="anchor" href="#_overview"></a><a class="link" href="#_overview">Overview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_4"><a class="anchor" href="#_solution_4"></a><a class="link" href="#_solution_4">Solution</a></h5>
<div class="paragraph">
<p>Once the inputs have been parsed, this one was straightforward to solve.
You simply have to follow the instructions.
Solving part 2 was particulary nice as I could just pass in a different crate
movement function.
I took the lazy approach for part 2 and implemented it via a temporary stack as
intermediary.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks was a bit harder, on the other hand, because there was no
separator string in place that would make it possible to easily distinguish the
different stacks.
I was tempted to preprocess the input via a shell script or even manually, which
would have simplified parsing.
But then I realised that a filter function each could be used to extract all the
lines belonging to either the stack definition or the definition of movement
instructions.
The use of inexact chunking then made it possible to easily read in the
different stacks.</p>
</div>
<div class="paragraph">
<p>Note that I have used two types to represent stacks: <code>Vec&lt;StackLine&gt;</code>, which is
the type representing the stack input, and <code>Vec&lt;Stack&gt;</code>, which is basically the
transpose of the first type.
Maybe using an actual matrix would have been a beter idea, but this works, too.</p>
</div>
<div class="paragraph">
<p>I noted that many of the terms used in this challenge are reserved words in rust
such as "crate" or "move".</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn lines_to_stacks(lines: &amp;Vec&lt;data::StackLine&gt;) -&gt; Result&lt;Vec&lt;data::Stack&gt;&gt; {
    if let Some(num_stacks) = lines.iter().map(|el| el.stacks.len()).max() {
        let mut stacks = vec![];

        for stack_idx in 0..num_stacks {
            let mut stack: data::Stack = vec![];

            // We reverse the iterator because we obtained the lines from top to bottom but we need
            // to build the stacks from the ground up. Thus, we iterate from the ground to the
            // bottom.
            for line in lines.iter().rev() {
                // We cannot be sure that every stack line contains the same number of entries.
                // Thus, we use the ".get" method to be able to catch the case where one line ends
                // before another. It turns out that every line has the same number of entries,
                // making this safeguard unnecessary...
                if let Some(Some(elem)) = line.stacks.get(stack_idx) {
                    stack.push(*elem);
                }
            }

            stacks.push(stack);
        }

        Ok(stacks)
    } else {
        Err(Error::msg("only empty stacks obtained"))
    }
}

fn check_bounds(idx: usize, len: usize, name: &amp;str) -&gt; Result&lt;()&gt; {
    if idx &gt; len {
        return Err(Error::msg(format!(
            "{} stack {} is out of bounds",
            name, idx
        )));
    } else {
        Ok(())
    }
}

fn apply_move_part1(stacks: &amp;mut Vec&lt;data::Stack&gt;, mov: &amp;data::Move) -&gt; Result&lt;()&gt; {
    // Thanks to these two bounds checks, we know that the index operations below will never panic.
    check_bounds(mov.src, stacks.len(), "source")?;
    check_bounds(mov.dest, stacks.len(), "dest")?;

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;stacks[mov.src].pop() {
            stacks[mov.dest].push(*moved_elem);
        } else {
            return Err(Error::msg(format!("cannot apply move {:?}", mov)));
        }
    }
    Ok(())
}

fn apply_move_part2(stacks: &amp;mut Vec&lt;data::Stack&gt;, mov: &amp;data::Move) -&gt; Result&lt;()&gt; {
    // Thanks to these two bounds checks, we know that the index operations below will never panic.
    check_bounds(mov.src, stacks.len(), "source")?;
    check_bounds(mov.dest, stacks.len(), "dest")?;

    // We are being lazy and are using a temporary stack to stash the crates away. That way, we
    // keep the order intact when putting them back from the temporary stash to the final stash.
    let mut temp_stack: data::Stack = vec![];

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;stacks[mov.src].pop() {
            temp_stack.push(*moved_elem);
        } else {
            return Err(Error::msg(format!(
                "cannot apply 1st half of move {:?}",
                mov
            )));
        }
    }

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;temp_stack.pop() {
            stacks[mov.dest].push(*moved_elem);
        } else {
            return Err(Error::msg(format!(
                "cannot apply 2nd half of move {:?}",
                mov
            )));
        }
    }
    Ok(())
}

fn solve(
    file: &amp;str,
    apply_move: fn(&amp;mut Vec&lt;data::Stack&gt;, &amp;data::Move) -&gt; Result&lt;()&gt;,
) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let moves =
        io::parse_lines_to_data::&lt;data::Move&gt;(file, "move", Some(|el| el.contains("move")), None)?;

    let stack_lines = io::parse_lines_to_data::&lt;data::StackLine&gt;(
        file,
        "stack line",
        Some(|el| el.contains("[")),
        None,
    )?;

    let mut stacks = lines_to_stacks(&amp;stack_lines)?;

    for mov in &amp;moves {
        apply_move(&amp;mut stacks, mov)?;
    }

    let mut errs = vec![];

    println!(
        "the top elements are: {}",
        stacks
            .iter()
            .enumerate()
            .map(|(idx, el)| el
                .last()
                .map(|el| el.to_string())
                .ok_or(Error::msg(format!("stack {} is empty", idx))))
            .filter_map(|el| io::filter_and_remember_errs(el, &amp;mut errs))
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("")
    );

    io::process_remembered_errs(errs)
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE, apply_move_part1)?;
    solve(REAL, apply_move_part1)?;

    solve(SAMPLE, apply_move_part2)?;
    solve(REAL, apply_move_part2)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use crate::io;
use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Move {
    pub num: usize,
    pub src: usize,
    pub dest: usize,
}

// We are using our own stack type here just so that the code is easier to read.
pub type Stack = Vec&lt;char&gt;;

// This is a temporary data type that we use to parse each line of the top part of the input.
#[derive(Debug)]
pub struct StackLine {
    pub stacks: Vec&lt;Option&lt;char&gt;&gt;,
}

impl FromStr for Move {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["move", num, "from", src, "to", dest] =&gt; Ok(Self {
                num: num.parse()?,
                // We use zero-based indexing but the example uses one-based indxing. Thus, we
                // convert here.
                src: src
                    .parse::&lt;usize&gt;()?
                    .checked_sub(1)
                    .ok_or(Error::msg(format!("{} is not &gt;1", src)))?,
                dest: dest
                    .parse::&lt;usize&gt;()?
                    .checked_sub(1)
                    .ok_or(Error::msg(format!("{} is not &gt;1", dest)))?,
            }),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as move", s))),
        }
    }
}

// A hybrid between a result and an option.
pub enum Hybrid&lt;T, E&gt; {
    Some(T),
    Err(E),
    None,
}

impl FromStr for StackLine {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let mut errs = vec![];

        let stacks = s
            .chars()
            .collect::&lt;Vec&lt;_&gt;&gt;()
            // Chunking is important here. Each stack entry contains at most 4 characters.
            // Thus, by chunking this way, we make sure to get exactly one chunk per stack.
            // Luckily, none of the stacks contains multi-letter crates ^^.
            .chunks(4)
            .map(|el| match el {
                // Case with data, can be 3 or 4 characters long.
                ['[', ch, ']', ' '] | ['[', ch, ']'] =&gt; Hybrid::Some(ch.clone()),
                // Case without data.
                [' ', ' ', ' ', ' '] | [' ', ' ', ' '] =&gt; Hybrid::None,
                // Error case.
                _ =&gt; Hybrid::Err(Error::msg(format!("cannot parse line {} as stack line", s))),
            })
            .map(|el| match el {
                Hybrid::Some(val) =&gt; Some(val),
                Hybrid::Err(err) =&gt; {
                    errs.push(format!("{:?}", err));
                    None
                }
                Hybrid::None =&gt; None,
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        io::process_remembered_errs(errs).map(|_| Self { stacks })
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>io.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Context, Error, Result};
use std::fmt::Debug;
use std::str::FromStr;

fn read_lines_from_file(path: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
    Ok(std::fs::read_to_string(path)
        .context("reading from disk")?
        .trim_end()
        .split('\n')
        .map(|el| String::from(el))
        .collect())
}

pub type Predicate = fn(&amp;String) -&gt; bool;
pub type Transform = fn(String) -&gt; String;

pub fn parse_lines_to_data&lt;T&gt;(
    file: &amp;str,
    type_name: &amp;str,
    filter: Option&lt;Predicate&gt;,
    transform: Option&lt;Transform&gt;,
) -&gt; Result&lt;Vec&lt;T&gt;&gt;
where
    T: FromStr&lt;Err = Error&gt;,
{
    let filter_fn = filter.unwrap_or(|_| true);
    let transformer = transform.unwrap_or(|el| el);

    let mut errs: Vec&lt;String&gt; = vec![];

    // Read file and convert into actions.
    let data = read_lines_from_file(file)
        .context("reading lines")?
        .into_iter()
        .filter(filter_fn)
        .map(transformer)
        .enumerate()
        .filter_map(|(idx, el)| {
            match el
                .parse::&lt;T&gt;()
                .with_context(|| format!("cannot parse line {} as {}: {}", idx, type_name, el))
            {
                Ok(val) =&gt; Some(val),
                Err(err) =&gt; {
                    errs.push(format!("{:?}", err));
                    None
                }
            }
        })
        .collect();

    if errs.len() == 0 {
        Ok(data)
    } else {
        // Concatenate errors into one giant error message in case there were any in the file.
        Err(Error::msg(errs.join("\n------------------\n")))
    }
}

// Convert Result to Option but make sure to add all errors messages to a vector of strings. Use
// "process_errs" to check whethere there are any errors in the vector.
pub fn filter_and_remember_errs&lt;I, E&gt;(item: Result&lt;I, E&gt;, errs: &amp;mut Vec&lt;String&gt;) -&gt; Option&lt;I&gt;
where
    E: Debug,
{
    match item {
        Ok(val) =&gt; Some(val),
        Err(err) =&gt; {
            errs.push(format!("{:?}", err));
            None
        }
    }
}

// If there is any element in the string vector, concatenate all ements into an error. Do not
// return an error otherwise.
pub fn process_remembered_errs(errs: Vec&lt;String&gt;) -&gt; Result&lt;()&gt; {
    if errs.len() == 0 {
        Ok(())
    } else {
        // Concatenate errors into one giant error message in case there were any in the file.
        Err(Error::msg(errs.join("\n------------------\n")))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_5"><a class="anchor" href="#_how_to_run_5"></a><a class="link" href="#_how_to_run_5">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_06_tuning_trouble"><a class="anchor" href="#_day_06_tuning_trouble"></a><a class="link" href="#_day_06_tuning_trouble">Day 06: Tuning Trouble</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the touning trouble puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_overview_2"><a class="anchor" href="#_overview_2"></a><a class="link" href="#_overview_2">Overview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_5"><a class="anchor" href="#_solution_5"></a><a class="link" href="#_solution_5">Solution</a></h5>
<div class="paragraph">
<p>For this one, input parsing was non-existent.
Processing, on the other hand, was a bit harder.
At first, I thought about implementing the uniqueness condition manually,
considering that we only had to compare four entries in a pairwise fashion.
I&#8217;m glad I didn&#8217;t do that, though, because of part two.
Instead, it became clear that a set (<code>HashSet</code> in rust) could be used.</p>
</div>
<div class="paragraph">
<p>A set is a collection of unique entris.
Imagine converting a list of somethings into a set of somethings
The only way both the list and the set can have the same number of entries is if
and only if all entries in the list are unique.
That&#8217;s what this code uses.</p>
</div>
<div class="paragraph">
<p>My biggest struggle was rust&#8217;s ownership system and unsatisfied trait bounds
that I didn&#8217;t even know existed.
After the first functioning implementation, I cleaned the code up a bit.
It&#8217;s surprisingly concise.</p>
</div>
<div class="paragraph">
<p>I was happy to have discovered the <code>windows(size)</code> method usable with slices
that produces an iterator over overlapping chunks of <code>size</code> elements.
Now, I only had to check each of them for uniqueness.
That involved some slice-vector-iterator comversions, which appear to be very
common in rust.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.

fn solve(file: &amp;str, win: usize) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file.
    let lines = io::read_lines_from_file(file)?;

    for line in lines {
        let first_match = line
            .chars()
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .as_slice()
            .windows(win)
            .enumerate()
            .filter_map(|(idx, el)| {
                // If the size of a set is equal to the window size, then we have only unique
                // entries. There is no other way.
                if HashSet::&lt;char&gt;::from_iter(el.to_vec().into_iter()).len() == win {
                    Some(idx)
                } else {
                    None
                }
            })
            .take(1)
            .next()
            .ok_or(Error::msg("cannot find matching entry"))?;

        println!("first line that fits: {}", first_match + win)
    }

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE, 4)?;
    solve(REAL, 4)?;

    solve(SAMPLE, 14)?;
    solve(REAL, 14)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_6"><a class="anchor" href="#_how_to_run_6"></a><a class="link" href="#_how_to_run_6">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_rust"><a class="anchor" href="#_day_07_rust"></a><a class="link" href="#_day_07_rust">Day 07: rust</a></h3>
<div class="sect3">
<h4 id="_day_07_no_space_left_on_device"><a class="anchor" href="#_day_07_no_space_left_on_device"></a><a class="link" href="#_day_07_no_space_left_on_device">Day 07: No Space Left On device</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_5"><a class="anchor" href="#_oveview_5"></a><a class="link" href="#_oveview_5">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_6"><a class="anchor" href="#_solution_6"></a><a class="link" href="#_solution_6">Solution</a></h5>
<div class="paragraph">
<p>This solution is not pretty but I kind of messed up a bit at first and then ran
out of time.
A lack of sleep could have contributed.</p>
</div>
<div class="paragraph">
<p>Parsing the input into a native data structure was straightforward thanks to
rust&#8217;s powerful enums.
But then the problems started.
For some reason, I decided to implement a fake directory structure manually as
an excercise and lost a lot of time that way.
As an alternative, I decided to take an idea from rsync&#8217;s cookbook and represent
files and directories a strings but ensure that direcotries always end with a
slash.
That way, I could have one set mapping paths to sizes but could easily determine
whether something was a file or a directory.</p>
</div>
<div class="paragraph">
<p>Then, the process was "just" building such a set of paths, finding all files
under a directory, and applying some operations to that.
I&#8217;m not happy with how the solution turned out but it works.
I was surprised by how much special care is needed when working with the root
directory <code>/</code>.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashMap;
// Constants.
// Part 1.
const MAX_SIZE: usize = 100000;
// Part 2.
const TOTAL_SIZE: usize = 70000000;
const REQUIRED_SIZE: usize = 30000000;

// We don'tuse a tree to represent the file system because trees are hard. Instead, we use a map
// mapping slash-separated strings to size values. An entry ending in a slash is a directory. That
// way, we can build everything up at once.
fn build_fs(entries: Vec&lt;data::Entry&gt;) -&gt; Result&lt;HashMap&lt;String, usize&gt;&gt; {
    let mut cwd = data::Stack::new();
    let mut fs = HashMap::&lt;String, usize&gt;::new();
    // This boolean serves as a way to check that we retrieve listed values only after the ls
    // command has been issued. It's just a sanity check for the input.
    let mut listing = false;

    fs.insert("/".to_string(), 0);

    // Build up the file system.
    for entry in entries {
        match entry {
            data::Entry::CD(dir) =&gt; {
                listing = false;
                match dir.as_str() {
                    ".." =&gt; cwd.popd(),
                    "/" =&gt; cwd.clear(),
                    _ =&gt; cwd.pushd(dir),
                }
                // Entries with a trailing slash are directories.
                let dir = cwd.pwd();
                if !fs.contains_key(&amp;dir) {
                    fs.insert(dir, 0);
                }
            }
            data::Entry::LS =&gt; {
                listing = true;
            }
            data::Entry::DIR(dir) =&gt; {
                if !listing {
                    return Err(Error::msg("found dir entry but not not in list mode"));
                }
                // Entries with a trailing slash are directories.
                fs.insert(format!("{}{}/", cwd.pwd(), dir), 0);
            }
            data::Entry::FILE { name, size } =&gt; {
                if !listing {
                    return Err(Error::msg("found file entry but not not in list mode"));
                }
                let dir = cwd.pwd();
                if !fs.contains_key(&amp;dir) {
                    return Err(Error::msg(format!("missing parent node {}", dir)));
                }
                // Entries without a trailing slash are files.
                fs.insert(format!("{}{}", dir, name), size);
                // Add directory sizes.
                for dir in &amp;mut cwd {
                    *fs.get_mut(&amp;dir)
                        .ok_or(Error::msg(format!("cannot read directory {}", dir)))? += size;
                }
            }
        }
    }

    Ok(fs)
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let entries = io::parse_lines_to_data::&lt;data::Entry&gt;(file, "entry", None, None)?;

    let filesystem = build_fs(entries)?;

    // Part 1.
    let result_part1 = filesystem
        .iter()
        .filter_map(|(name, size)| {
            if name.ends_with("/") &amp;&amp; size &lt;= &amp;MAX_SIZE {
                Some(size)
            } else {
                None
            }
        })
        .sum::&lt;usize&gt;();

    println!("requested size is {}", result_part1);

    // Part 2.
    // We already accumulated sizes, so getting this is easy. The amount of free space is the total
    // size minus what we currently occupy, which is the size of the root directory.
    // Note the use of checked_sub here because I wanted to try it out for subtracting from
    // unsigned values. Those checked_* methods allow graceful handling of overflows. Without them,
    // rust would panic if there was a violation of a type's value range.
    let used_space = *filesystem
        .get("/")
        .ok_or(Error::msg("cannot retrieve used space"))?;
    let free_space = TOTAL_SIZE
        .checked_sub(used_space)
        .ok_or(Error::msg("cannot compute free space"))?;
    let required_space = REQUIRED_SIZE
        .checked_sub(free_space)
        .ok_or(Error::msg("cannot compute required space"))?;

    eprintln!("need to free up at least {}", required_space);

    // Find the smallest directory that fulfils that condition.
    let min_free_size = filesystem
        .iter()
        .filter_map(|(name, size)| {
            if name.ends_with("/") &amp;&amp; size &gt;= &amp;required_space {
                Some(size)
            } else {
                None
            }
        })
        .min()
        .ok_or(Error::msg("cannot find any directory for part 2"))?;

    println!("freeing {} is enough", min_free_size);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use crate::io;
use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum Entry {
    CD(String),
    LS,
    DIR(String),
    FILE { name: String, size: usize },
}

impl FromStr for Entry {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["$", "cd", dir] =&gt; Ok(Self::CD(dir.to_string())),
            ["$", "ls"] =&gt; Ok(Self::LS),
            ["dir", dir] =&gt; Ok(Self::DIR(dir.to_string())),
            [size, name] =&gt; Ok(Self::FILE {
                name: name.to_string(),
                size: size.parse::&lt;usize&gt;()?,
            }),
            _ =&gt; Err(Error::msg(format!("canot parse {}", s))),
        }
    }
}

pub struct Stack {
    it_idx: usize,
    entries: Vec&lt;String&gt;,
}

impl Stack {
    pub fn new() -&gt; Self {
        Self {
            it_idx: 0,
            entries: vec![],
        }
    }

    pub fn pwd(&amp;self) -&gt; String {
        if self.entries.len() == 0 {
            "/".to_string()
        } else {
            format!("/{}/", self.entries.join("/"))
        }
    }

    pub fn pushd(&amp;mut self, dir: String) {
        self.entries.push(dir);
    }

    pub fn popd(&amp;mut self) {
        // Ignore this here.
        _ = self.entries.pop();
    }

    pub fn clear(&amp;mut self) {
        self.entries.clear();
    }
}

impl Iterator for Stack {
    type Item = String;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.it_idx &gt; self.entries.len() {
            self.it_idx = 0;
            None
        } else if self.it_idx == 0 {
            self.it_idx += 1;
            Some("/".to_string())
        } else {
            self.it_idx += 1;
            Some(format!("/{}/", self.entries[0..self.it_idx - 1].join("/")))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time, I&#8217;ve even added some tests for some helper functions.
Those tests lets me ensure that any special handling of the root direcotry works
as intended.
Adding tests to a file in rust was pretty easy and a nice experience.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_7"><a class="anchor" href="#_how_to_run_7"></a><a class="link" href="#_how_to_run_7">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_rust"><a class="anchor" href="#_day_08_rust"></a><a class="link" href="#_day_08_rust">Day 08: rust</a></h3>
<div class="sect3">
<h4 id="_day_08_treetop_tree_house"><a class="anchor" href="#_day_08_treetop_tree_house"></a><a class="link" href="#_day_08_treetop_tree_house">Day 08: Treetop Tree House</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_6"><a class="anchor" href="#_oveview_6"></a><a class="link" href="#_oveview_6">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_7"><a class="anchor" href="#_solution_7"></a><a class="link" href="#_solution_7">Solution</a></h5>
<div class="paragraph">
<p>I decided not to go the obvious route and use a <code>HashMap</code> mapping tree positions
to tree sizes instead.
I also increased all tree sizes by one so that I could use unsigned numbers for
tree sizes but still include the smallest trees.</p>
</div>
<div class="paragraph">
<p>The main part of this solution is a function that checks which trees are visible
and returns a <code>HashSet</code> of the positions of all visible trees.
I can then take the union of those sets to solve part 1.
The aforementioned function can scan several parallel lines one after the other.
The nice thing about using a <code>HashSet</code> is that I don&#8217;t have to cocern myself
with edges.
I can simply retrieve values until I can find none after displacing the checked
position and then stop iterating.</p>
</div>
<div class="paragraph">
<p>For part 2, I use the same function but modify the visibility condition.
That is, the maximum allowed height is that of the tree I look at.
Furthermore, we accept all trees smaller than our current tree.
I find that unrealistic, which caused some delay.
Imagine this (the tree height is at the top and the index at the bottom):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>4 3 3 1 4

|       |
| | |   |
| | |   |
| | | | |
0 1 2 3 4</pre>
</div>
</div>
<div class="paragraph">
<p>Tree 0 is the one we&#8217;re looking at.
For part 2, this would mean there are 4 trees visible from 0, namely 1, 2, 3,
and 4.
But, in my view, tree 3 is covered by trees 1 and 2 and should not be visible.
Anyway.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::{HashMap, HashSet};
// Constants.
// None yet.

// Count trees visible in a direction count_disp from all positions that can be reached from
// start_pos + n * outer_disp for all n that still yield a tree. If outer_disp is None, use only
// n==0. The search stops at the latest if no more trees can be found in that direction, assuming a
// dense forest.
//
// Whether a tree still counts as visible is defined by size_cmp. For part 1, it compares the
// current tree's size with the size of the largest tree found so far. For part 2, it always
// returns true because max_height has been set to that of the tree in consideration.
//
// A search in one direction stops early after a tree of max_height has been found because no trees
// behind it can be visible. The value for max_height differs between parts 1 and 2. For part 1,
// it's the global maximum and for part 2 it's the size of the tree in consideration.
fn count_visible(
    forest: &amp;HashMap&lt;(i64, i64), data::Tree&gt;,
    start_pos: &amp;data::Vec,
    count_disp: &amp;data::Vec,
    outer_disp: Option&lt;&amp;data::Vec&gt;,
    max_height: &amp;u8,
    size_cmp: fn(&amp;u8, &amp;u8) -&gt; bool,
) -&gt; HashSet&lt;(i64, i64)&gt; {
    let mut visible_forest = HashSet::&lt;(i64, i64)&gt;::new();

    let mut outer_start = start_pos.clone();

    // This will automatically stop if we cannot retrieve any more trees. Assuming a dense forest,
    // that means once we reached the edge.
    while let Some(_) = forest.get(&amp;outer_start.pos()) {
        let mut largest: u8 = 0;
        let mut pos = outer_start.clone();

        while &amp;largest &lt; max_height &amp;&amp; let Some(tree) = forest.get(&amp;pos.pos()) {
            let size = tree.size();
            // Remember the positions of trees that pass the size condition.
            if size_cmp(&amp;size, &amp;largest) {
                visible_forest.insert(pos.pos());
                largest = size;
            }
            pos = pos.add(&amp;count_disp);
        }

        // If we want to search in the same direction from different starting positions, update the
        // starting position and go on searching. If not, end the outer loop early.
        if let Some(disp) = outer_disp {
            outer_start = outer_start.add(disp);
        } else {
            break;
        }
    }

    visible_forest
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let forest = io::parse_chars_to_data::&lt;data::Tree&gt;(file, "tree")?;

    // Part 1.
    // Get dimensions of forest in all three directions. That could have been avoided by using some
    // matrix structure but I wanted to use a HashMap here, so this is necessary.
    let max_x = forest
        .keys()
        .map(|el| el.0)
        .max()
        .ok_or(Error::msg("cannot find max x index"))?;
    let max_y = forest
        .keys()
        .map(|el| el.1)
        .max()
        .ok_or(Error::msg("cannot find max y index"))?;
    let max_height = forest
        .values()
        .map(|val| val.size())
        .max()
        .ok_or(Error::msg("cannot find max height"))?;

    // Compute union of all visible forests (or rather, tree positions).
    let mut count = HashSet::&lt;(i64, i64)&gt;::new();
    // Top border rightwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(0, 0),
            &amp;data::Vec::new(0, 1),
            Some(&amp;data::Vec::new(1, 0)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );
    // Left border downwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(0, 0),
            &amp;data::Vec::new(1, 0),
            Some(&amp;data::Vec::new(0, 1)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );
    // Bottom border rightwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(0, max_y),
            &amp;data::Vec::new(0, -1),
            Some(&amp;data::Vec::new(1, 0)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );
    // Right border downwards.
    count = &amp;count
        | &amp;count_visible(
            &amp;forest,
            &amp;data::Vec::new(max_x, 0),
            &amp;data::Vec::new(-1, 0),
            Some(&amp;data::Vec::new(0, 1)),
            &amp;max_height,
            |size, largest| size &gt; largest,
        );

    println!("visible are {} trees", count.len());

    // Part 2.
    let disps = vec![
        data::Vec::new(0, -1),
        data::Vec::new(-1, 0),
        data::Vec::new(0, 1),
        data::Vec::new(1, 0),
    ];

    let best_view = forest
        .iter()
        .map(|(pos, height)| {
            disps
                .iter()
                .map(|disp| {
                    let tree_pos = data::Vec::new(pos.0, pos.1);
                    count_visible(
                        &amp;forest,
                        // Start searching at the first tree in the search direction from the
                        // starting position.
                        &amp;tree_pos.add(&amp;disp),
                        disp,
                        // Don't search along multiple parallel lines.
                        None,
                        &amp;height.size(),
                        |_size, _largest| true,
                    )
                    .len()
                })
                // The scenic score for a tree is the product of the number of trees it can see in
                // every direction.
                .product::&lt;usize&gt;()
        })
        .max()
        .ok_or(Error::msg("cannot find best view"))?;

    println!("best view is {}", best_view);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Tree(u8);

impl FromStr for Tree {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        // We increase the size by one to be able to perform simple unsigned size comparisons.
        Ok(Self(
            s.parse::&lt;u8&gt;()?
                .checked_add(1)
                .ok_or(Error::msg("cannot increase tree size"))?,
        ))
    }
}

impl Tree {
    pub fn size(&amp;self) -&gt; u8 {
        self.0
    }
}

#[derive(Debug, Clone)]
pub struct Vec {
    x: i64,
    y: i64,
}

impl Vec {
    pub fn add(&amp;self, other: &amp;Vec) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    pub fn pos(&amp;self) -&gt; (i64, i64) {
        (self.x, self.y)
    }

    pub fn new(x: i64, y: i64) -&gt; Self {
        Self { x, y }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_8"><a class="anchor" href="#_how_to_run_8"></a><a class="link" href="#_how_to_run_8">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day09" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_09_rust"><a class="anchor" href="#_day_09_rust"></a><a class="link" href="#_day_09_rust">Day 09: rust</a></h3>
<div class="sect3">
<h4 id="_day_09_rope_bridge"><a class="anchor" href="#_day_09_rope_bridge"></a><a class="link" href="#_day_09_rope_bridge">Day 09: Rope Bridge</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of this day&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_7"><a class="anchor" href="#_oveview_7"></a><a class="link" href="#_oveview_7">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_8"><a class="anchor" href="#_solution_8"></a><a class="link" href="#_solution_8">Solution</a></h5>
<div class="paragraph">
<p>Solving this was quite a bit of fun!</p>
</div>
<div class="paragraph">
<p>I created a <code>Vec</code> class to represent 2d vectors and was quite happy to have
outsourced a lot of the logic into that class.
For example, the class offers a <code>mv</code> method, which only ever lets it move by one
space, which is a safeguard against trying to move too far at once.
I haven&#8217;t tried moving by more than one space at a time because it seemed overly
complicated.</p>
</div>
<div class="paragraph">
<p>Furthermore, the custom <code>Vec</code> class has an <code>iter</code> method that provides an
iterator over unit-size steps (unit vectors in the sense of the manhattan
metric) that, if followed, ensure the same distance has been traveled as
described by the original vector.
That way, a simple iteration over iterators gave us all the steps we needed.</p>
</div>
<div class="paragraph">
<p>For solving part 2, one problem was borrowing two elements of the rope
simultaneously while one was even borrowed mutably.
That won&#8217;t work in rust.
Instead, I use a temporary variable to keep track of the updated position of the
previous knot in the rope.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve also played around with lifetimes a bit.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.
// None yet.

// Define some helper functions that allow easy conversions from an Option&lt;data::Vec&gt; to a
// Result&lt;data::Vec&gt; because the latter lets us use the question mark operator for unobstrusive
// error forwarding.
fn tail(rope: &amp;Vec&lt;data::Vec&gt;) -&gt; Result&lt;data::Vec&gt; {
    rope.last()
        .map(|el| el.clone())
        .ok_or(Error::msg("cannot get tail"))
}

// Yeah, playing with lifetimes.
fn get_mut&lt;'a&gt;(rope: &amp;'a mut Vec&lt;data::Vec&gt;, idx: usize) -&gt; Result&lt;&amp;'a mut data::Vec&gt; {
    rope.get_mut(idx)
        .ok_or(Error::msg("cannot get element mutably"))
}

fn get&lt;'a&gt;(rope: &amp;'a Vec&lt;data::Vec&gt;, idx: usize) -&gt; Result&lt;&amp;'a data::Vec&gt; {
    rope.get(idx).ok_or(Error::msg("cannot get element"))
}

fn solve(file: &amp;str, length: usize) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {} WITH LENGTH {}", file, length);

    // Read file and convert into data.
    let updates = io::parse_lines_to_data::&lt;data::Vec&gt;(file, "vec", None, None)?;

    // All knots start at the very same position.
    let mut rope = vec![data::NULL_VEC; length + 2];
    let mut visited_by_tail = HashSet::&lt;data::Vec&gt;::new();

    visited_by_tail.insert(tail(&amp;rope)?);

    // Part 1.
    // The `iter` method for a vector provides an iterator over a set of unit-size steps that, if
    // followed, will ensure that we have traveled the entire distance described by the vector.
    for update in updates.iter().map(|el| el.iter()).flatten() {
        // The mv method will make sure we never move the head farther than one space. This is just
        // a safeguard for errors in the code.
        get_mut(&amp;mut rope, 0)?.mv(&amp;update)?;
        // Remember only the position of the reference vector, which is the head so far. That
        // involves a clone.
        let mut ref_vec = *get(&amp;rope, 0)?;

        // Update all others with reference to their previous entry.
        for knot in rope.iter_mut() {
            // Move the knot with respect to the reference knot, which is always the previous one.
            *knot = knot.add(&amp;ref_vec.get_tail_update(&amp;knot));
            // Update the reference knot's position. Because we can only ever borrow one element as
            // mutable in rust and once we did so, we cannot borrow anything else, we clone it
            // here. That's inefficient but I couldn't find an easy way around it without resorting
            // to `unsafe`, which I want to avoid. Sadly, it seems as if `split_at_mut` involves
            // `unsafe`.
            ref_vec = *knot;
        }
        visited_by_tail.insert(tail(&amp;rope)?);
    }

    println!(
        "the tail visited {} unique spots for a rope of length {}",
        visited_by_tail.len(),
        rope.len(),
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Part 1.
    solve(SAMPLE1, 0)?;
    solve(SAMPLE2, 0)?;
    solve(REAL, 0)?;

    // Part 2.
    solve(SAMPLE1, 8)?;
    solve(SAMPLE2, 8)?;
    solve(REAL, 8)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug, Clone, Hash, PartialEq, Eq, Copy)]
pub struct Vec {
    x: i64,
    y: i64,
}

pub const NULL_VEC: Vec = Vec { x: 0, y: 0 };

impl FromStr for Vec {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s
            .split_whitespace()
            .collect::&lt;std::vec::Vec&lt;_&gt;&gt;()
            .as_slice()
        {
            ["R", dist] =&gt; Ok(Self {
                x: dist.parse()?,
                y: 0,
            }),
            ["L", dist] =&gt; Ok(Self {
                x: -dist.parse()?,
                y: 0,
            }),
            ["U", dist] =&gt; Ok(Self {
                x: 0,
                y: dist.parse()?,
            }),
            ["D", dist] =&gt; Ok(Self {
                x: 0,
                y: -dist.parse()?,
            }),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as vector", s))),
        }
    }
}

impl Vec {
    pub fn add(&amp;self, other: &amp;Vec) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }

    // Length in infinity metric.
    fn infinity_len(&amp;self) -&gt; usize {
        self.x.abs() as usize + self.y.abs() as usize
    }

    fn is_infinity_unit(&amp;self) -&gt; bool {
        self.infinity_len() == 1
    }

    // Map to the 2d unit sphere in manhattan metric. The null vector cannot be mapped and, thus,
    // remains unchanged.
    fn as_manhattan_unit(&amp;self) -&gt; Self {
        Self {
            x: self.x.clamp(-1, 1),
            y: self.y.clamp(-1, 1),
        }
    }

    // Move the vector exactly one space along one direction.
    pub fn mv(&amp;mut self, other: &amp;Vec) -&gt; Result&lt;()&gt; {
        if other.is_infinity_unit() {
            *self = self.add(other);
            Ok(())
        } else {
            Err(Error::msg(format!("cannot move by {:?}", other)))
        }
    }

    // Provide an iterator over unit-sized steps (unit in manhattan metric not infinity metric)
    // that, if followed, describes the same distance traveled as `self`.
    pub fn iter(&amp;self) -&gt; std::vec::IntoIter&lt;Self&gt; {
        let unit = self.as_manhattan_unit();
        let mut pos = self.as_manhattan_unit();
        // As this is my second time working with a custom iterator, I was not sure how to avoid
        // cloning here.
        let mut disps = vec![];
        while &amp;pos != self {
            let new_pos = pos.add(&amp;unit);
            disps.push(unit);
            pos = new_pos;
        }
        disps.push(unit);

        disps.into_iter()
    }

    pub fn get_tail_update(&amp;self, other: &amp;Self) -&gt; Self {
        let diff = Self {
            x: self.x - other.x,
            y: self.y - other.y,
        };

        // We want to update with a unit vector in manhattan metric, but only if that would not
        // mean that `other` is on the same space as `self`.
        if &amp;other.add(&amp;diff.as_manhattan_unit()) == self {
            NULL_VEC
        } else {
            diff.as_manhattan_unit()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_9"><a class="anchor" href="#_how_to_run_9"></a><a class="link" href="#_how_to_run_9">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day10" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_10_rust"><a class="anchor" href="#_day_10_rust"></a><a class="link" href="#_day_10_rust">Day 10: rust</a></h3>
<div class="sect3">
<h4 id="_day_10_cathode_ray_tube"><a class="anchor" href="#_day_10_cathode_ray_tube"></a><a class="link" href="#_day_10_cathode_ray_tube">Day 10: Cathode-Ray Tube</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of today&#8217;s puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_8"><a class="anchor" href="#_oveview_8"></a><a class="link" href="#_oveview_8">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_9"><a class="anchor" href="#_solution_9"></a><a class="link" href="#_solution_9">Solution</a></h5>
<div class="paragraph">
<p>It&#8217;s getting really interesting now.
I quite liked how part 2 didn&#8217;t require you to compute a number or a sequence of
letters but instead required you to render something on screen.
My solution is less nice, but there is not much time on the weekend.</p>
</div>
<div class="paragraph">
<p>Quite early on, I decided to ignore all the weirdness due to a noop taking one
cycle an an addition taking two cycles.
Instead, I moved to a parallel world where each instruction took exactly one
cycle, which meant replacing each 2-cycle addition by a noop followed by a
1-cycle addition.
So far so straightforward.</p>
</div>
<div class="paragraph">
<p>Furthermore, I ignored all the weirdness due to what is at the beginning,
during, or at the end of a cycle, but instead only looked at the register during
each cycle.
I also had my 1-cycle addition act during its cycle instead of at the cycle&#8217;s
end.
I also started cycle counting at 0 instead of 1.</p>
</div>
<div class="paragraph">
<p>To map the register value during a cycle from my ficticious world back to the
world of the puzzle, I only had to add 2 to the cycle count.
That also means my world had no real cycle one, which meant I had to treat that
one separately for part 2.
For part one, in order to look at the value during cycle 20, I had to skip only
the first 18 entries.</p>
</div>
<div class="paragraph">
<p>Today, I learnt that rust really will panic if you try to subtract 1 from an
unsigned value that is 0.
And off-by-one errors really are the two worst types of bugs that plague
software development.
I also played around with closures that move values into them for the first
time.
They are quite useful!</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::Result;
// Constants.
const WIDTH: usize = 40;

fn render(crt: &amp;Vec&lt;bool&gt;, width: usize, fill: char) -&gt; String {
    crt.iter()
        .enumerate()
        .map(|(idx, el)| {
            let ch = if *el { '#' } else { fill };
            if (idx + 1) % width == 0 {
                format!("{}\n", ch)
            } else {
                ch.to_string()
            }
        })
        .collect::&lt;String&gt;()
}

fn maybe_draw(crt: &amp;mut Vec&lt;bool&gt;, reg: isize, cycle: usize, width: usize) {
    let pixel_idx = cycle - 1;
    let horizontal_pos = (pixel_idx % width) as isize;

    // Used to avoid drawing past the edges. It turns out the register value is nice and those
    // checks would not have been needed.
    let sprite_at_left_edge = reg == 0;
    let sprite_at_right_edge = reg == width as isize - 1;

    if reg == horizontal_pos {
        crt[pixel_idx] = true;
    } else if reg + 1 == horizontal_pos &amp;&amp; !sprite_at_right_edge {
        crt[pixel_idx] = true;
    } else if reg - 1 == horizontal_pos &amp;&amp; !sprite_at_left_edge {
        crt[pixel_idx] = true;
    }
}

// This function likely performs a lot of allocations that are not needed but it makes the rest of
// the problem so much easier to solve.
fn extend(input: Vec&lt;data::Op&gt;) -&gt; Vec&lt;data::Op&gt; {
    input
        .into_iter()
        .map(|el| match el {
            data::Op::None =&gt; vec![data::Op::None].into_iter(),
            data::Op::Some(_) =&gt; vec![data::Op::None, el].into_iter(),
        })
        .flatten()
        .collect::&lt;Vec&lt;_&gt;&gt;()
}

fn solve(file: &amp;str, part1: bool, fill: char) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let ops = io::parse_lines_to_data::&lt;data::Op&gt;(file, "op", None, None)?;

    // We avoid that one-cycle-two-cycle weridness by replacing each addx operation by a noop and
    // an addx operation that is assumed to take only one cycle.
    let extended_ops = extend(ops);

    let mut reg = 1;
    let reg_vals = extended_ops.into_iter().map(move |el| {
        reg += match el {
            data::Op::None =&gt; 0,
            data::Op::Some(val) =&gt; val,
        };
        reg
    });

    if part1 {
        // There is a lot of potential for off-by-one errors in this one.
        //
        // We skip the first 18 entries here because we want to start with the value during cycle
        // 20, which is the value after cycle 19, and this solution ignores what happens during the
        // first cycle, because that is trivial.
        let skip = 18;
        let mut skipper: isize = -1;
        let interesting = reg_vals
            .skip(skip)
            .enumerate()
            .filter_map(move |(step, reg)| {
                // Now convert from our weird way of counting to that of the puzzle.
                // We wanted to skip the first 19 cycles (add skip + 1) and cycle counting starts
                // at one (add 1).
                let current_cycle = step + 1 + skip + 1;
                skipper += 1;
                if skipper % 40 == 0 {
                    Some(reg * current_cycle as isize)
                } else {
                    None
                }
            })
            .sum::&lt;isize&gt;();

        println!("{:?}", interesting);
    } else {
        let mut crt = vec![false; WIDTH * 6];

        // We need to handle the first cycle separately because the cycle number used here is
        // always that of the cycle we are in. During the first cycle, the register has a value of
        // 1.
        maybe_draw(&amp;mut crt, 1, 1, WIDTH);

        // Here, current_cycle is the cycle we are currently in. Thus, the number is one larger
        // than what the example shows because the example usually taks about the value after a
        // cycle but the value during a cycle is important. This also erroneously assumes the
        // existence 241'th cycle, but that's not really a problem because the value after the
        // 240'th cycle is the value during the 241th cycle, so it's consistent.
        for (current_cycle, reg) in reg_vals.enumerate().map(|(step, el)| (step + 2, el)) {
            maybe_draw(&amp;mut crt, reg, current_cycle, WIDTH);
        }
        println!("\n{}\n", render(&amp;crt, WIDTH, fill));
    }

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Part 1.
    // The last argument is not important here.
    solve(SAMPLE1, true, '.')?;
    solve(SAMPLE2, true, '.')?;
    solve(REAL, true, '.')?;

    // Part 2.
    solve(SAMPLE2, false, '.')?;
    // Use a space as filler for the real solution to make the letters easier to read.
    solve(REAL, false, ' ')?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug, Clone, Hash, PartialEq, Eq, Copy)]
pub enum Op {
    None,
    Some(isize),
}

impl FromStr for Op {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s
            .split_whitespace()
            .collect::&lt;std::vec::Vec&lt;_&gt;&gt;()
            .as_slice()
        {
            ["noop"] =&gt; Ok(Self::None),
            ["addx", val] =&gt; Ok(Self::Some(val.parse()?)),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as op", s))),
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no tests this time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_10"><a class="anchor" href="#_how_to_run_10"></a><a class="link" href="#_how_to_run_10">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>