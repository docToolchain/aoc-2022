<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: razziel89</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_razziel89">razziel89</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_01_rust">Day 01: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_01_calorie_counting">Day 01: Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_oveview">Oveview</a></li>
<li><a href="#_how_to_run">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_rust">Day 02: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_02_rock_paper_scissors">Day 02: Rock Paper Scissors</a>
<ul class="sectlevel4">
<li><a href="#_oveview_2">Oveview</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_how_to_run_2">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_03_rust">Day 03: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_03_rucksack_reorganization">Day 03: Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_oveview_3">Oveview</a></li>
<li><a href="#_solution_2">Solution</a></li>
<li><a href="#_how_to_run_3">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_rust">Day 04: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_04_camp_cleanup">Day 04: Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_oveview_4">Oveview</a></li>
<li><a href="#_solution_3">Solution</a></li>
<li><a href="#_how_to_run_4">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_rust">Day 05: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_05_supply_stacks">Day 05: Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_overview">Overview</a></li>
<li><a href="#_solution_4">Solution</a></li>
<li><a href="#_how_to_run_5">How to run</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_rust">Day 06: rust</a>
<ul class="sectlevel3">
<li><a href="#_day_06_tuning_trouble">Day 06: Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_overview_2">Overview</a></li>
<li><a href="#_solution_5">Solution</a></li>
<li><a href="#_how_to_run_6">How to run</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_razziel89"><a class="anchor" href="#_razziel89"></a><a class="link" href="#_razziel89">razziel89</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/10134766?v=4" alt="10134766?v=4"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>razziel89</strong><br>
<span class="icon"><i class="fa fa-github"></i></span>: <a href="https://github.com/razziel89">razziel89</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>Nothing here yet. Update your profile at <a href="https://github.com/docToolchain/aoc-2022/blob/master/profiles/razziel89.adoc">/profiles/razziel89.adoc</a></p>
</div>
<a id="day01" />
</div>
<div class="sect2">
<h3 id="_day_01_rust"><a class="anchor" href="#_day_01_rust"></a><a class="link" href="#_day_01_rust">Day 01: rust</a></h3>
<div class="sect3">
<h4 id="_day_01_calorie_counting"><a class="anchor" href="#_day_01_calorie_counting"></a><a class="link" href="#_day_01_calorie_counting">Day 01: Calorie Counting</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the calorie counting puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview"><a class="anchor" href="#_oveview"></a><a class="link" href="#_oveview">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.go</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
const NUM_ELVES: usize = 3;

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let baggage = io::parse_lines_to_data::&lt;data::Baggage&gt;(file, "baggage")?;

    let mut elves = data::baggages_to_elves(baggage);

    // Elf carrying the most calories will be first in line. It is inefficient to calculate total
    // calories for every comparison, but it's not really important for this exercise.
    elves.sort_by(|el1, el2| el2.total_calories().cmp(&amp;el1.total_calories()));

    match elves.len() {
        // Even though we could solve part 1 if we had 1..=2 elves, we ignore that case here.
        0..=2 =&gt; Err(Error::msg("somehow, we found too few elves :(")),
        _ =&gt; {
            // Part 1.
            println!(
                "elf carrying the most is num {} who carries {} calories",
                elves[0].get_idx(),
                elves[0].total_calories()
            );

            // Part 2.
            let total_calories: u64 = elves
                .iter()
                .take(NUM_ELVES)
                .map(|el| el.total_calories())
                .sum();

            println!(
                "the {} elves carrying the most carry {} in total\n",
                NUM_ELVES, total_calories
            );

            Ok(())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum Baggage {
    Calories(u64),
    EndOfElf,
}

#[derive(Debug)]
pub struct Elf {
    idx: usize,
    baggage: Vec&lt;Baggage&gt;,
}

impl FromStr for Baggage {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "" =&gt; Ok(Baggage::EndOfElf),
            val =&gt; Ok(Baggage::Calories(val.parse::&lt;u64&gt;()?)),
        }
    }
}

impl Elf {
    pub fn total_calories(&amp;self) -&gt; u64 {
        self.baggage
            .iter()
            .map(|el| match el {
                Baggage::Calories(val) =&gt; val,
                Baggage::EndOfElf =&gt; &amp;0,
            })
            .sum()
    }

    pub fn get_idx(&amp;self) -&gt; usize {
        self.idx
    }
}

pub fn baggages_to_elves(baggage: Vec&lt;Baggage&gt;) -&gt; Vec&lt;Elf&gt; {
    let mut elves = vec![];
    let mut elf = Elf {
        idx: 1,
        baggage: vec![],
    };

    for el in baggage {
        match el {
            Baggage::Calories(_) =&gt; {
                elf.baggage.push(el);
            }
            Baggage::EndOfElf =&gt; {
                let next_elf = Elf {
                    idx: elf.idx + 1,
                    baggage: vec![],
                };
                elves.push(elf);
                elf = next_elf;
            }
        }
    }

    elves
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run"><a class="anchor" href="#_how_to_run"></a><a class="link" href="#_how_to_run">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.</p>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_rust"><a class="anchor" href="#_day_02_rust"></a><a class="link" href="#_day_02_rust">Day 02: rust</a></h3>
<div class="sect3">
<h4 id="_day_02_rock_paper_scissors"><a class="anchor" href="#_day_02_rock_paper_scissors"></a><a class="link" href="#_day_02_rock_paper_scissors">Day 02: Rock Paper Scissors</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the RPS puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_2"><a class="anchor" href="#_oveview_2"></a><a class="link" href="#_oveview_2">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="paragraph">
<p>This one was pretty straightforward.
I might have taken enums in Rust a bit far, here, but I wanted to use them since
Go, the language used last year, doesn&#8217;t have enums.
I also tried out a custom trait so that I could use generics to determine which
round it was.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;
// Constants.
// None yet.

fn solve&lt;T&gt;(file: &amp;str) -&gt; Result&lt;()&gt;
where
    T: FromStr&lt;Err = Error&gt;,
    T: data::Round,
{
    eprintln!("PROCESSING {}", file);

    let mut scores = (0, 0);

    // Read file and convert into data.
    let rounds = io::parse_lines_to_data::&lt;T&gt;(file, "rounds")?;

    for round in rounds {
        let round_scores = round.score();
        scores = (scores.0 + round_scores.0, scores.1 + round_scores.1);
    }

    println!("scores are opponent: {}, you: {}\n", scores.0, scores.1);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.
    solve::&lt;data::RoundPart1&gt;(SAMPLE)?;
    solve::&lt;data::RoundPart1&gt;(REAL)?;

    solve::&lt;data::RoundPart2&gt;(SAMPLE)?;
    solve::&lt;data::RoundPart2&gt;(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub enum RPS {
    R,
    P,
    S,
}

#[derive(Debug)]
pub enum Outcome {
    Win,
    Loss,
    Draw,
}

// This trait is used so that we don't have to care which round we're scoring.
pub trait Round {
    fn score(&amp;self) -&gt; (usize, usize);
}

#[derive(Debug)]
pub struct RoundPart1 {
    other: RPS,
    me: RPS,
}

#[derive(Debug)]
pub struct RoundPart2 {
    other: RPS,
    outcome: Outcome,
}

impl FromStr for RPS {
    type Err = Error;

    // This parser can be used for rounds 1 and 2.
    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "A" | "X" =&gt; Ok(RPS::R),
            "B" | "Y" =&gt; Ok(RPS::P),
            "C" | "Z" =&gt; Ok(RPS::S),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as RPS", s))),
        }
    }
}

impl FromStr for Outcome {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s {
            "X" =&gt; Ok(Outcome::Loss),
            "Y" =&gt; Ok(Outcome::Draw),
            "Z" =&gt; Ok(Outcome::Win),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as Outcome", s))),
        }
    }
}

impl FromStr for RoundPart1 {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [other, me] =&gt; {
                // Other error.
                if !["A", "B", "C"].contains(other) {
                    Err(Error::msg(format!("unknown value {} for other", other)))
                // Me error.
                } else if !["X", "Y", "Z"].contains(me) {
                    Err(Error::msg(format!("unknown value {} for me", me)))
                // Success case.
                } else {
                    Ok(RoundPart1 {
                        other: other.parse::&lt;RPS&gt;()?,
                        me: me.parse::&lt;RPS&gt;()?,
                    })
                }
            }
            _ =&gt; Err(Error::msg(format!("cannot parse {}", s))),
        }
    }
}

impl FromStr for RoundPart2 {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [other, result] =&gt; {
                // Other error.
                if !["A", "B", "C"].contains(other) {
                    Err(Error::msg(format!("unknown value {} for other", other)))
                // Success case.
                } else {
                    Ok(RoundPart2 {
                        other: other.parse::&lt;RPS&gt;()?,
                        outcome: result.parse::&lt;Outcome&gt;()?,
                    })
                }
            }
            _ =&gt; Err(Error::msg(format!("cannot parse {}", s))),
        }
    }
}

impl Outcome {
    fn score(&amp;self) -&gt; usize {
        match &amp;self {
            Outcome::Loss =&gt; 0,
            Outcome::Draw =&gt; 3,
            Outcome::Win =&gt; 6,
        }
    }
}

impl RPS {
    fn score(&amp;self) -&gt; usize {
        match self {
            RPS::R =&gt; 1,
            RPS::P =&gt; 2,
            RPS::S =&gt; 3,
        }
    }

    // Needed for round 1. This function could benefit from testing so that we know the result if
    // called with (a, b) and (b, a) make sense.
    fn check_win(&amp;self, other: &amp;RPS) -&gt; Outcome {
        match (self, other) {
            // Self rock.
            (RPS::R, RPS::R) =&gt; Outcome::Draw,
            (RPS::R, RPS::P) =&gt; Outcome::Loss,
            (RPS::R, RPS::S) =&gt; Outcome::Win,
            // Self paper.
            (RPS::P, RPS::R) =&gt; Outcome::Win,
            (RPS::P, RPS::P) =&gt; Outcome::Draw,
            (RPS::P, RPS::S) =&gt; Outcome::Loss,
            // Self scissors.
            (RPS::S, RPS::R) =&gt; Outcome::Loss,
            (RPS::S, RPS::P) =&gt; Outcome::Win,
            (RPS::S, RPS::S) =&gt; Outcome::Draw,
        }
    }

    // Needed for round 2. This is called on the other's value with a desired outcome.
    fn get_reply(&amp;self, result: &amp;Outcome) -&gt; RPS {
        match (self, result) {
            // Rock.
            (RPS::R, Outcome::Loss) =&gt; RPS::S,
            (RPS::R, Outcome::Draw) =&gt; RPS::R,
            (RPS::R, Outcome::Win) =&gt; RPS::P,
            // Paper.
            (RPS::P, Outcome::Loss) =&gt; RPS::R,
            (RPS::P, Outcome::Draw) =&gt; RPS::P,
            (RPS::P, Outcome::Win) =&gt; RPS::S,
            // Scissors.
            (RPS::S, Outcome::Loss) =&gt; RPS::P,
            (RPS::S, Outcome::Draw) =&gt; RPS::S,
            (RPS::S, Outcome::Win) =&gt; RPS::R,
        }
    }
}

// It turns out we do not need to track the other's score, but we only knew that after the fact...
impl Round for RoundPart1 {
    fn score(&amp;self) -&gt; (usize, usize) {
        (
            self.other.score() + self.other.check_win(&amp;self.me).score(),
            self.me.score() + self.me.check_win(&amp;self.other).score(),
        )
    }
}

impl Round for RoundPart2 {
    fn score(&amp;self) -&gt; (usize, usize) {
        let reply = self.other.get_reply(&amp;self.outcome);
        (
            self.other.score() + self.other.check_win(&amp;reply).score(),
            reply.score() + reply.check_win(&amp;self.other).score(),
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_2"><a class="anchor" href="#_how_to_run_2"></a><a class="link" href="#_how_to_run_2">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day03" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_03_rust"><a class="anchor" href="#_day_03_rust"></a><a class="link" href="#_day_03_rust">Day 03: rust</a></h3>
<div class="sect3">
<h4 id="_day_03_rucksack_reorganization"><a class="anchor" href="#_day_03_rucksack_reorganization"></a><a class="link" href="#_day_03_rucksack_reorganization">Day 03: Rucksack Reorganization</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the rucksack reorganization puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_3"><a class="anchor" href="#_oveview_3"></a><a class="link" href="#_oveview_3">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_2"><a class="anchor" href="#_solution_2"></a><a class="link" href="#_solution_2">Solution</a></h5>
<div class="paragraph">
<p>This one was straightforward, but I am not too happy with how the solution
looks.
Working with the <code>HashSet</code> type was not as easy as I thought, e.g. when trying
to compute the overlap of multiple sets.
Furthermore, I somehow misunderstood part 2 at first, which lead me on a wild
goose chase.
Still, this works, but I lack the time to provid more details about the
implementation.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn ord(c: char) -&gt; Result&lt;usize&gt; {
    match c {
        'a'..='z' =&gt; Ok((c as usize - 'a' as usize) + 1),
        'A'..='Z' =&gt; Ok((c as usize - 'A' as usize) + 27),
        _ =&gt; Err(Error::msg(format!(
            "invalid character {} for ord conversion",
            c,
        ))),
    }
}

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let rucksacks = io::parse_lines_to_data::&lt;data::Rucksack&gt;(file, "rucksack")?;

    // Part 1.
    let common = rucksacks
        .iter()
        .map(|el| (&amp;el.left &amp; &amp;el.right).into_iter().collect::&lt;Vec&lt;_&gt;&gt;())
        .enumerate()
        .map(|(idx, el)| {
            if el.len() == 1 {
                ord(el[0])
            } else {
                Err(Error::msg(format!(
                    "entry {} has wrong length {}",
                    idx,
                    el.len()
                )))
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    {
        let mut has_err = false;
        for c in common.as_slice() {
            if let Err(err) = c {
                eprintln!("{:?}", err);
                has_err = true;
            }
        }
        if has_err {
            return Err(Error::msg("encountered at least one error"));
        }
    }

    println!(
        "part 1, total value is {}",
        common.iter().flatten().sum::&lt;usize&gt;()
    );

    // Part 2.
    let badges = rucksacks
        .iter()
        .map(|el| el.everything())
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .chunks_exact(3)
        .into_iter()
        .map(|sets| {
            if let [set1, set2, set3] = sets {
                (&amp;(set1 &amp; set2) &amp; set3).into_iter().collect::&lt;Vec&lt;_&gt;&gt;()
            } else {
                panic!("this will never happen due to the use of exact_chunk")
            }
        })
        .enumerate()
        .map(|(idx, el)| {
            if el.len() == 1 {
                ord(el[0])
            } else {
                Err(Error::msg(format!(
                    "entry {} has wrong length {}",
                    idx,
                    el.len()
                )))
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "part 2, total value is {}",
        badges.iter().flatten().sum::&lt;usize&gt;()
    );

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    // Funny that the example for part 1 would end in a draw, but that's not mentioned anywhere.
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
use std::str::FromStr;

#[derive(Debug)]
pub struct Rucksack {
    pub left: HashSet&lt;char&gt;,
    pub right: HashSet&lt;char&gt;,
}

impl Rucksack {
    pub fn everything(&amp;self) -&gt; HashSet&lt;char&gt; {
        &amp;self.left | &amp;self.right
    }
}

impl FromStr for Rucksack {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let left = str_to_set(&amp;s[..s.len() / 2]);
        let right = str_to_set(&amp;s[s.len() / 2..]);
        Ok(Rucksack { left, right })
    }
}

fn str_to_set(s: &amp;str) -&gt; HashSet&lt;char&gt; {
    HashSet::from_iter(s.chars())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_3"><a class="anchor" href="#_how_to_run_3"></a><a class="link" href="#_how_to_run_3">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_rust"><a class="anchor" href="#_day_04_rust"></a><a class="link" href="#_day_04_rust">Day 04: rust</a></h3>
<div class="sect3">
<h4 id="_day_04_camp_cleanup"><a class="anchor" href="#_day_04_camp_cleanup"></a><a class="link" href="#_day_04_camp_cleanup">Day 04: Camp Cleanup</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the camp cleanup puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_oveview_4"><a class="anchor" href="#_oveview_4"></a><a class="link" href="#_oveview_4">Oveview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_3"><a class="anchor" href="#_solution_3"></a><a class="link" href="#_solution_3">Solution</a></h5>
<div class="paragraph">
<p>This one was straightforward, which is why I tried my luck with a generic pair
type.
It worked out nicely as I only had to implemeng the parsing logic once but could
use it for two concrete types.
Then, it was just a matter of creating the methods that compute whether there is
a full (part 1) or partial (part 2) overlap between two ranges and to check for
overlaps in both directions (which is strictly not needed for part 2 but doesn&#8217;t
hurt).</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn solve(file: &amp;str) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let pairs = io::parse_lines_to_data::&lt;data::Pair&gt;(file, "pair")?;

    let full_overlaps = pairs
        .iter()
        .filter_map(|el| if el.full_overlap() { Some(el) } else { None })
        .count();

    println!("there are {} full overlaps", full_overlaps);

    let partial_overlaps = pairs
        .iter()
        .filter_map(|el| if el.partial_overlap() { Some(el) } else { None })
        .count();

    println!("there are {} partial overlaps", partial_overlaps);

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE)?;
    solve(REAL)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct GenPair&lt;T, const SEP: char&gt; {
    pub left: T,
    pub right: T,
}

#[derive(Debug)]
pub struct Num(usize);

impl FromStr for Num {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        Ok(Self(s.parse::&lt;usize&gt;()?))
    }
}

impl&lt;T, const SEP: char&gt; FromStr for GenPair&lt;T, { SEP }&gt;
where
    T: FromStr&lt;Err = Error&gt;,
{
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split(SEP).collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [left_str, right_str] =&gt; Ok(Self {
                left: left_str.parse::&lt;T&gt;()?,
                right: right_str.parse::&lt;T&gt;()?,
            }),
            _ =&gt; Err(Error::msg(format!(
                "cannot parse {} as pair with sep {}",
                s, SEP
            ))),
        }
    }
}

pub type Range = GenPair&lt;Num, '-'&gt;;
pub type Pair = GenPair&lt;Range, ','&gt;;

impl Range {
    fn contains(&amp;self, other: &amp;Range) -&gt; bool {
        self.left.0 &lt;= other.left.0 &amp;&amp; self.right.0 &gt;= other.right.0
    }

    fn overlap(&amp;self, other: &amp;Range) -&gt; bool {
        (self.left.0 &lt;= other.right.0 &amp;&amp; self.left.0 &gt;= other.left.0)
            || (self.right.0 &gt;= other.left.0 &amp;&amp; self.right.0 &lt;= other.right.0)
    }
}

impl Pair {
    pub fn full_overlap(&amp;self) -&gt; bool {
        self.left.contains(&amp;self.right) || self.right.contains(&amp;self.left)
    }

    pub fn partial_overlap(&amp;self) -&gt; bool {
        self.left.overlap(&amp;self.right) || self.right.overlap(&amp;self.left)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_4"><a class="anchor" href="#_how_to_run_4"></a><a class="link" href="#_how_to_run_4">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_rust"><a class="anchor" href="#_day_05_rust"></a><a class="link" href="#_day_05_rust">Day 05: rust</a></h3>
<div class="sect3">
<h4 id="_day_05_supply_stacks"><a class="anchor" href="#_day_05_supply_stacks"></a><a class="link" href="#_day_05_supply_stacks">Day 05: Supply Stacks</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the supply stacks puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_overview"><a class="anchor" href="#_overview"></a><a class="link" href="#_overview">Overview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_4"><a class="anchor" href="#_solution_4"></a><a class="link" href="#_solution_4">Solution</a></h5>
<div class="paragraph">
<p>Once the inputs have been parsed, this one was straightforward to solve.
You simply have to follow the instructions.
Solving part 2 was particulary nice as I could just pass in a different crate
movement function.
I took the lazy approach for part 2 and implemented it via a temporary stack as
intermediary.</p>
</div>
<div class="paragraph">
<p>Parsing the stacks was a bit harder, on the other hand, because there was no
separator string in place that would make it possible to easily distinguish the
different stacks.
I was tempted to preprocess the input via a shell script or even manually, which
would have simplified parsing.
But then I realised that a filter function each could be used to extract all the
lines belonging to either the stack definition or the definition of movement
instructions.
The use of inexact chunking then made it possible to easily read in the
different stacks.</p>
</div>
<div class="paragraph">
<p>Note that I have used two types to represent stacks: <code>Vec&lt;StackLine&gt;</code>, which is
the type representing the stack input, and <code>Vec&lt;Stack&gt;</code>, which is basically the
transpose of the first type.
Maybe using an actual matrix would have been a beter idea, but this works, too.</p>
</div>
<div class="paragraph">
<p>I noted that many of the terms used in this challenge are reserved words in rust
such as "crate" or "move".</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
// Constants.
// None yet.

fn lines_to_stacks(lines: &amp;Vec&lt;data::StackLine&gt;) -&gt; Result&lt;Vec&lt;data::Stack&gt;&gt; {
    if let Some(num_stacks) = lines.iter().map(|el| el.stacks.len()).max() {
        let mut stacks = vec![];

        for stack_idx in 0..num_stacks {
            let mut stack: data::Stack = vec![];

            // We reverse the iterator because we obtained the lines from top to bottom but we need
            // to build the stacks from the ground up. Thus, we iterate from the ground to the
            // bottom.
            for line in lines.iter().rev() {
                // We cannot be sure that every stack line contains the same number of entries.
                // Thus, we use the ".get" method to be able to catch the case where one line ends
                // before another. It turns out that every line has the same number of entries,
                // making this safeguard unnecessary...
                if let Some(Some(elem)) = line.stacks.get(stack_idx) {
                    stack.push(*elem);
                }
            }

            stacks.push(stack);
        }

        Ok(stacks)
    } else {
        Err(Error::msg("only empty stacks obtained"))
    }
}

fn check_bounds(idx: usize, len: usize, name: &amp;str) -&gt; Result&lt;()&gt; {
    if idx &gt; len {
        return Err(Error::msg(format!(
            "{} stack {} is out of bounds",
            name, idx
        )));
    } else {
        Ok(())
    }
}

fn apply_move_part1(stacks: &amp;mut Vec&lt;data::Stack&gt;, mov: &amp;data::Move) -&gt; Result&lt;()&gt; {
    // Thanks to these two bounds checks, we know that the index operations below will never panic.
    check_bounds(mov.src, stacks.len(), "source")?;
    check_bounds(mov.dest, stacks.len(), "dest")?;

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;stacks[mov.src].pop() {
            stacks[mov.dest].push(*moved_elem);
        } else {
            return Err(Error::msg(format!("cannot apply move {:?}", mov)));
        }
    }
    Ok(())
}

fn apply_move_part2(stacks: &amp;mut Vec&lt;data::Stack&gt;, mov: &amp;data::Move) -&gt; Result&lt;()&gt; {
    // Thanks to these two bounds checks, we know that the index operations below will never panic.
    check_bounds(mov.src, stacks.len(), "source")?;
    check_bounds(mov.dest, stacks.len(), "dest")?;

    // We are being lazy and are using a temporary stack to stash the crates away. That way, we
    // keep the order intact when putting them back from the temporary stash to the final stash.
    let mut temp_stack: data::Stack = vec![];

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;stacks[mov.src].pop() {
            temp_stack.push(*moved_elem);
        } else {
            return Err(Error::msg(format!(
                "cannot apply 1st half of move {:?}",
                mov
            )));
        }
    }

    for _ in 0..mov.num {
        if let Some(moved_elem) = &amp;temp_stack.pop() {
            stacks[mov.dest].push(*moved_elem);
        } else {
            return Err(Error::msg(format!(
                "cannot apply 2nd half of move {:?}",
                mov
            )));
        }
    }
    Ok(())
}

fn solve(
    file: &amp;str,
    apply_move: fn(&amp;mut Vec&lt;data::Stack&gt;, &amp;data::Move) -&gt; Result&lt;()&gt;,
) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file and convert into data.
    let moves =
        io::parse_lines_to_data::&lt;data::Move&gt;(file, "move", Some(|el| el.contains("move")), None)?;

    let stack_lines = io::parse_lines_to_data::&lt;data::StackLine&gt;(
        file,
        "stack line",
        Some(|el| el.contains("[")),
        None,
    )?;

    let mut stacks = lines_to_stacks(&amp;stack_lines)?;

    for mov in &amp;moves {
        apply_move(&amp;mut stacks, mov)?;
    }

    let mut errs = vec![];

    println!(
        "the top elements are: {}",
        stacks
            .iter()
            .enumerate()
            .map(|(idx, el)| el
                .last()
                .map(|el| el.to_string())
                .ok_or(Error::msg(format!("stack {} is empty", idx))))
            .filter_map(|el| io::filter_and_remember_errs(el, &amp;mut errs))
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("")
    );

    io::process_remembered_errs(errs)
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE, apply_move_part1)?;
    solve(REAL, apply_move_part1)?;

    solve(SAMPLE, apply_move_part2)?;
    solve(REAL, apply_move_part2)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>data.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use crate::io;
use anyhow::{Error, Result};
use std::str::FromStr;

#[derive(Debug)]
pub struct Move {
    pub num: usize,
    pub src: usize,
    pub dest: usize,
}

// We are using our own stack type here just so that the code is easier to read.
pub type Stack = Vec&lt;char&gt;;

// This is a temporary data type that we use to parse each line of the top part of the input.
#[derive(Debug)]
pub struct StackLine {
    pub stacks: Vec&lt;Option&lt;char&gt;&gt;,
}

impl FromStr for Move {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        match s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            ["move", num, "from", src, "to", dest] =&gt; Ok(Self {
                num: num.parse()?,
                // We use zero-based indexing but the example uses one-based indxing. Thus, we
                // convert here.
                src: src
                    .parse::&lt;usize&gt;()?
                    .checked_sub(1)
                    .ok_or(Error::msg(format!("{} is not &gt;1", src)))?,
                dest: dest
                    .parse::&lt;usize&gt;()?
                    .checked_sub(1)
                    .ok_or(Error::msg(format!("{} is not &gt;1", dest)))?,
            }),
            _ =&gt; Err(Error::msg(format!("cannot parse {} as move", s))),
        }
    }
}

// A hybrid between a result and an option.
pub enum Hybrid&lt;T, E&gt; {
    Some(T),
    Err(E),
    None,
}

impl FromStr for StackLine {
    type Err = Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self&gt; {
        let mut errs = vec![];

        let stacks = s
            .chars()
            .collect::&lt;Vec&lt;_&gt;&gt;()
            // Chunking is important here. Each stack entry contains at most 4 characters.
            // Thus, by chunking this way, we make sure to get exactly one chunk per stack.
            // Luckily, none of the stacks contains multi-letter crates ^^.
            .chunks(4)
            .map(|el| match el {
                // Case with data, can be 3 or 4 characters long.
                ['[', ch, ']', ' '] | ['[', ch, ']'] =&gt; Hybrid::Some(ch.clone()),
                // Case without data.
                [' ', ' ', ' ', ' '] | [' ', ' ', ' '] =&gt; Hybrid::None,
                // Error case.
                _ =&gt; Hybrid::Err(Error::msg(format!("cannot parse line {} as stack line", s))),
            })
            .map(|el| match el {
                Hybrid::Some(val) =&gt; Some(val),
                Hybrid::Err(err) =&gt; {
                    errs.push(format!("{:?}", err));
                    None
                }
                Hybrid::None =&gt; None,
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        io::process_remembered_errs(errs).map(|_| Self { stacks })
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>io.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Context, Error, Result};
use std::fmt::Debug;
use std::str::FromStr;

fn read_lines_from_file(path: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
    Ok(std::fs::read_to_string(path)
        .context("reading from disk")?
        .trim_end()
        .split('\n')
        .map(|el| String::from(el))
        .collect())
}

pub type Predicate = fn(&amp;String) -&gt; bool;
pub type Transform = fn(String) -&gt; String;

pub fn parse_lines_to_data&lt;T&gt;(
    file: &amp;str,
    type_name: &amp;str,
    filter: Option&lt;Predicate&gt;,
    transform: Option&lt;Transform&gt;,
) -&gt; Result&lt;Vec&lt;T&gt;&gt;
where
    T: FromStr&lt;Err = Error&gt;,
{
    let filter_fn = filter.unwrap_or(|_| true);
    let transformer = transform.unwrap_or(|el| el);

    let mut errs: Vec&lt;String&gt; = vec![];

    // Read file and convert into actions.
    let data = read_lines_from_file(file)
        .context("reading lines")?
        .into_iter()
        .filter(filter_fn)
        .map(transformer)
        .enumerate()
        .filter_map(|(idx, el)| {
            match el
                .parse::&lt;T&gt;()
                .with_context(|| format!("cannot parse line {} as {}: {}", idx, type_name, el))
            {
                Ok(val) =&gt; Some(val),
                Err(err) =&gt; {
                    errs.push(format!("{:?}", err));
                    None
                }
            }
        })
        .collect();

    if errs.len() == 0 {
        Ok(data)
    } else {
        // Concatenate errors into one giant error message in case there were any in the file.
        Err(Error::msg(errs.join("\n------------------\n")))
    }
}

// Convert Result to Option but make sure to add all errors messages to a vector of strings. Use
// "process_errs" to check whethere there are any errors in the vector.
pub fn filter_and_remember_errs&lt;I, E&gt;(item: Result&lt;I, E&gt;, errs: &amp;mut Vec&lt;String&gt;) -&gt; Option&lt;I&gt;
where
    E: Debug,
{
    match item {
        Ok(val) =&gt; Some(val),
        Err(err) =&gt; {
            errs.push(format!("{:?}", err));
            None
        }
    }
}

// If there is any element in the string vector, concatenate all ements into an error. Do not
// return an error otherwise.
pub fn process_remembered_errs(errs: Vec&lt;String&gt;) -&gt; Result&lt;()&gt; {
    if errs.len() == 0 {
        Ok(())
    } else {
        // Concatenate errors into one giant error message in case there were any in the file.
        Err(Error::msg(errs.join("\n------------------\n")))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_5"><a class="anchor" href="#_how_to_run_5"></a><a class="link" href="#_how_to_run_5">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_rust"><a class="anchor" href="#_day_06_rust"></a><a class="link" href="#_day_06_rust">Day 06: rust</a></h3>
<div class="sect3">
<h4 id="_day_06_tuning_trouble"><a class="anchor" href="#_day_06_tuning_trouble"></a><a class="link" href="#_day_06_tuning_trouble">Day 06: Tuning Trouble</a></h4>
<div class="paragraph">
<p>This is my implementation for both rounds of the touning trouble puzzle.
This year, I am using Rust to solve the challenges.
My first priority is learning more about the language, while the creation of
easily readable code is a second priority, this time.
Wiriting fast code is a far-away third priority.</p>
</div>
<div class="sect4">
<h5 id="_overview_2"><a class="anchor" href="#_overview_2"></a><a class="link" href="#_overview_2">Overview</a></h5>
<div class="paragraph">
<p>All source code lives in the <code>src</code> directory.
This solution contains a <code>main.rs</code>, which defines the main executable.
There is also a <code>data.rs</code>, which specifies data types important for this
solution as well as associated functions, methods, and traits.
There is also an <code>io.rs</code>, which contains helper functions related to input
parsing and output processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="_solution_5"><a class="anchor" href="#_solution_5"></a><a class="link" href="#_solution_5">Solution</a></h5>
<div class="paragraph">
<p>For this one, input parsing was non-existent.
Processing, on the other hand, was a bit harder.
At first, I thought about implementing the uniqueness condition manually,
considering that we only had to compare four entries in a pairwise fashion.
I&#8217;m glad I didn&#8217;t do that, though, because of part two.
Instead, it became clear that a set (<code>HashSet</code> in rust) could be used.</p>
</div>
<div class="paragraph">
<p>A set is a collection of unique entris.
Imagine converting a list of somethings into a set of somethings
The only way both the list and the set can have the same number of entries is if
and only if all entries in the list are unique.
That&#8217;s what this code uses.</p>
</div>
<div class="paragraph">
<p>My biggest struggle was rust&#8217;s ownership system and unsatisfied trait bounds
that I didn&#8217;t even know existed.
After the first functioning implementation, I cleaned the code up a bit.
It&#8217;s surprisingly concise.</p>
</div>
<div class="paragraph">
<p>I was happy to have discovered the <code>windows(size)</code> method usable with slices
that produces an iterator over overlapping chunks of <code>size</code> elements.
Now, I only had to check each of them for uniqueness.
That involved some slice-vector-iterator comversions, which appear to be very
common in rust.</p>
</div>
<div class="paragraph">
<p><code>main.rs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight linenums"><code class="language-rust" data-lang="rust">use anyhow::{Error, Result};
use std::collections::HashSet;
// Constants.

fn solve(file: &amp;str, win: usize) -&gt; Result&lt;()&gt; {
    eprintln!("PROCESSING {}", file);

    // Read file.
    let lines = io::read_lines_from_file(file)?;

    for line in lines {
        let first_match = line
            .chars()
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .as_slice()
            .windows(win)
            .enumerate()
            .filter_map(|(idx, el)| {
                // If the size of a set is equal to the window size, then we have only unique
                // entries. There is no other way.
                if HashSet::&lt;char&gt;::from_iter(el.to_vec().into_iter()).len() == win {
                    Some(idx)
                } else {
                    None
                }
            })
            .take(1)
            .next()
            .ok_or(Error::msg("cannot find matching entry"))?;

        println!("first line that fits: {}", first_match + win)
    }

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    solve(SAMPLE, 4)?;
    solve(REAL, 4)?;

    solve(SAMPLE, 14)?;
    solve(REAL, 14)?;

    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are currently no tests.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_to_run_6"><a class="anchor" href="#_how_to_run_6"></a><a class="link" href="#_how_to_run_6">How to run</a></h5>
<div class="paragraph">
<p>Please have a look at <code>src/main.rs</code> for expeced names of input files.
Assuming the expected files are present, you only need to execute <code>cargo run</code> to
run the solution.
The expected input files are ususally called <code>sample.dat</code> and <code>stage_1.dat</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>