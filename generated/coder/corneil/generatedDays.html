<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: corneil</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_corneil">corneil</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_kotlin">Day 00: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_hello_world">Hello World!</a></li>
</ul>
</li>
<li><a href="#_day_01_kotlin">Day 01: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_calorie_counting">Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_parsing">Parsing</a></li>
<li><a href="#_part_1">Part 1</a></li>
<li><a href="#_part_2">Part 2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_kotlin">Day 02: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_rock_paper_scissors">Rock Paper Scissors</a></li>
</ul>
</li>
<li><a href="#_day_03_kotlin">Day 03: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_rucksack_reorganization">Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_calculating_the_priority">Calculating the priority</a></li>
<li><a href="#_part1">Part1</a></li>
<li><a href="#_part_2_2">Part 2</a></li>
<li><a href="#_takeaways">Takeaways</a></li>
<li><a href="#_full_source">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_kotlin">Day 04: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_camp_cleanup">Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2">Part 1</a></li>
<li><a href="#_part_2_3">Part 2</a></li>
<li><a href="#_takeaways_2">Takeaways</a></li>
<li><a href="#_full_source_2">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_kotlin">Day 05: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_supply_stacks">Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_data_structures">Data Structures</a></li>
<li><a href="#_parsing_2">Parsing</a></li>
<li><a href="#_part_1_3">Part 1</a></li>
<li><a href="#_part_2_4">Part 2</a></li>
<li><a href="#_takeaways_3">Takeaways</a></li>
<li><a href="#_full_source_3">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_06_kotlin">Day 06: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_tuning_trouble">Tuning Trouble</a>
<ul class="sectlevel4">
<li><a href="#_solution">Solution</a></li>
<li><a href="#_full_source_4">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_07_kotlin">Day 07: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_no_space_left_on_device">No Space Left On Device</a>
<ul class="sectlevel4">
<li><a href="#_data_model">Data Model</a></li>
<li><a href="#_parsing_3">Parsing</a></li>
<li><a href="#_solutions">Solutions</a></li>
<li><a href="#_full_source_5">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_08_kotlin">Day 08: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_treetop_tree_house">Treetop Tree House</a>
<ul class="sectlevel4">
<li><a href="#_model">Model</a></li>
<li><a href="#_parsing_4">Parsing</a></li>
<li><a href="#_part_1_5">Part 1</a></li>
<li><a href="#_part_2_6">Part 2</a></li>
<li><a href="#_full_source_6">Full source</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_corneil"><a class="anchor" href="#_corneil"></a><a class="link" href="#_corneil">corneil</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/466422?v=4" alt="466422?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>corneil</strong><br>
Corneil du Plessis<br>
Github: <a href="https://github.com/corneil">corneil</a><br>
Twitter: <a href="https://twitter.com/corneil">@corneil</a><br>
Mastodon: <a href="https://hachyderm.io/@corneil">@<a href="mailto:corneil@hachyderm.io">corneil@hachyderm.io</a></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a Staff Software Engineer at VMware working on the Spring Cloud Data Flow team. I enjoyed AoC 2019 and decided to give it another go this year.</p>
</div>
<div class="paragraph">
<p>I love coding in Kotlin and I try write the code solving the puzzles in a way that someone else can understand the solution.</p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_kotlin"><a class="anchor" href="#_day_00_kotlin"></a><a class="link" href="#_day_00_kotlin">Day 00: kotlin</a></h3>
<div class="sect3">
<h4 id="_hello_world"><a class="anchor" href="#_hello_world"></a><a class="link" href="#_hello_world">Hello World!</a></h4>
<div class="paragraph">
<p>This is a simple Hello World program in <a href="https://kotlinlang.org">Kotlin</a>, if you want to experiment with Kotlin use the <a href="https://play.kotlinlang.org">Kotlin Playground</a></p>
</div>
<div class="paragraph">
<p>My aim with <a href="https://adventofcode.com/2021">Advent of Code</a> is to write code solving the puzzles in a way that is understandable to a wide audience.
Feel free to reach out with comments at the links above.</p>
</div>
<a id="day01" />
</div>
</div>
<div class="sect2">
<h3 id="_day_01_kotlin"><a class="anchor" href="#_day_01_kotlin"></a><a class="link" href="#_day_01_kotlin">Day 01: kotlin</a></h3>
<div class="sect3">
<h4 id="_calorie_counting"><a class="anchor" href="#_calorie_counting"></a><a class="link" href="#_calorie_counting">Calorie Counting</a></h4>
<div class="paragraph">
<p>In order to follow these solutions you will need to login to <a href="https://adventofcode.com/2022">Advent of Code</a> and complete each day.</p>
</div>
<div class="paragraph">
<p>The day was lines representing the calories of food items carried by elves and separated by blank lines.
Kotlin File has a readLines function that makes it easy to parse the input, calculate the calories for each elf and add to a list.</p>
</div>
<div class="sect4">
<h5 id="_parsing"><a class="anchor" href="#_parsing"></a><a class="link" href="#_parsing">Parsing</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  fun findCalories(input: List&lt;String&gt;): List&lt;Int&gt; {
    val elves = mutableListOf&lt;Int&gt;()
    var calories = 0
    for (line in input) {
      if (line.isBlank()) {
        elves.add(calories)
        calories = 0
      } else {
        calories += line.toInt()
      }
    }
    elves.add(calories)
    return elves
  }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_1"><a class="anchor" href="#_part_1"></a><a class="link" href="#_part_1">Part 1</a></h5>
<div class="paragraph">
<p>For part one the max value it the answer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  fun findMaxCalories(input: List&lt;String&gt;): Int {
    val calories = findCalories(input)
    return calories.max()
  }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2"><a class="anchor" href="#_part_2"></a><a class="link" href="#_part_2">Part 2</a></h5>
<div class="paragraph">
<p>For part two the result is the sum of the first three when sorted in descending order. Kotlin has the <code>take</code> method on collections which is very useful in this case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  fun topThree(input: List&lt;String&gt;): Int {
    val calories = findCalories(input)
    return calories.sortedDescending().take(3).sum()
  }</code></pre>
</div>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_kotlin"><a class="anchor" href="#_day_02_kotlin"></a><a class="link" href="#_day_02_kotlin">Day 02: kotlin</a></h3>
<div class="sect3">
<h4 id="_rock_paper_scissors"><a class="anchor" href="#_rock_paper_scissors"></a><a class="link" href="#_rock_paper_scissors">Rock Paper Scissors</a></h4>
<div class="paragraph">
<p>Part 1 meant we needed to parse input representing an opponent hand when playing RPS, and we had to assume the 2nd input was an answer we needed to provide while "cheating".</p>
</div>
<div class="paragraph">
<p>Part 2 came with a curveball in that the 2nd input should be treated as an outcome. This means we needed to find the correct hand for the outcome.
The score calculation was a function of the outcome and the hand we selected.</p>
</div>
<div class="paragraph">
<p>Below is the final code and there are loaders for creating the rounds for part 1 and part 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">enum class Rps(val identifiers: String, val shapeScore: Int) {
  ROCK("AX", 1),
  PAPER("BY", 2),
  SCISSORS("CZ", 3)
}

enum class Outcome(val identifier: String, val score: Int) {
  LOSE("X", 0),
  DRAW("Y", 3),
  WIN("Z", 6)
}

data class Hand(val them: Rps, val me: Rps)

object Rules {

  data class Rule(val loser: Rps, val winner: Rps)

  private val beats = mapOf(
    Rps.ROCK to Rule(Rps.SCISSORS, Rps.PAPER),
    Rps.PAPER to Rule(Rps.ROCK, Rps.SCISSORS),
    Rps.SCISSORS to Rule(Rps.PAPER, Rps.ROCK)
  )

  fun winner(shape: Rps): Rps {
    val winner = beats[shape] ?: error("Cannot find $shape")
    return winner.winner
  }

  fun loser(shape: Rps): Rps {
    val loser = beats[shape] ?: error("Cannot find $shape")
    return loser.loser
  }

  fun didIWin(round: Hand): Boolean {
    val shape = loser(round.me)
    return shape == round.them
  }

}

fun main() {

  fun toRps(hint: String): Rps {
    return Rps.values().find { it.identifiers.contains(hint) } ?: error("Invalid RPS $hint")
  }

  fun toOutcome(outcome: String): Outcome {
    return Outcome.values().find { it.identifier == outcome } ?: error("Invalid Outcome:$outcome")
  }

  fun readRounds(input: List&lt;String&gt;): List&lt;Hand&gt; {
    return input.map {
      val hints = it.split(" ")
      Hand(toRps(hints[0]), toRps(hints[1]))
    }
  }

  // choose a shape to match the outcome
  fun chooseShape(shape: Rps, outcome: Outcome): Rps {
    return when (outcome) {
      Outcome.DRAW -&gt; shape
      Outcome.WIN -&gt; Rules.winner(shape)
      Outcome.LOSE -&gt; Rules.loser(shape)
    }
  }

  // convert 2nd to outcome and then find a shape to match outcome given 1st
  fun readRounds2(input: List&lt;String&gt;): List&lt;Hand&gt; {
    return input.map {
      val hints = it.split(" ")
      Pair(toRps(hints[0]), toOutcome(hints[1]))
    }.map {
      Hand(it.first, chooseShape(it.first, it.second))
    }
  }

  fun calcRound(round: Hand): Int {
    return when {
      round.them == round.me -&gt; Outcome.DRAW.score
      Rules.didIWin(round) -&gt; Outcome.WIN.score
      else -&gt; Outcome.LOSE.score
    }
  }

  fun calcScore(round: Hand): Int {
    return round.me.shapeScore + calcRound(round)
  }

  fun calcTotal(rounds: List&lt;Hand&gt;): Int {
    return rounds.sumOf { calcScore(it) }
  }

  fun part1() {

    val testScore = calcTotal(readRounds(readInput("day02_test")))
    println("Test Total = $testScore")
    check(testScore == 15)

    val total = calcTotal(readRounds(readInput("day02")))
    println("Total = $total")

  }

  fun part2() {

    val testScore2 = calcTotal(readRounds2(readInput("day02_test")))
    println("Test Total 2 = $testScore2")
    check(testScore2 == 12)

    val total2 = calcTotal(readRounds2(readInput("day02")))
    println("Total 2 = $total2")
  }

  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day03" />
</div>
</div>
<div class="sect2">
<h3 id="_day_03_kotlin"><a class="anchor" href="#_day_03_kotlin"></a><a class="link" href="#_day_03_kotlin">Day 03: kotlin</a></h3>
<div class="sect3">
<h4 id="_rucksack_reorganization"><a class="anchor" href="#_rucksack_reorganization"></a><a class="link" href="#_rucksack_reorganization">Rucksack Reorganization</a></h4>
<div class="paragraph">
<p>Today puzzle was about manipulating strings and calculating the values of characters according rules.</p>
</div>
<div class="sect4">
<h5 id="_calculating_the_priority"><a class="anchor" href="#_calculating_the_priority"></a><a class="link" href="#_calculating_the_priority">Calculating the priority</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcPriority(value: Char): Int = when (value) {
  in 'a'..'z' -&gt; value - 'a' + 1
  in 'A'..'Z' -&gt; value - 'A' + 27
  else -&gt; error("Invalid input $value")
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part1"><a class="anchor" href="#_part1"></a><a class="link" href="#_part1">Part1</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcRucksacks(input: List&lt;String&gt;): Int =
  input.map { Pair(it.substring(0 until it.length / 2), it.substring(it.length / 2)) }  <i class="conum" data-value="1"></i><b>(1)</b>
    .map { it.first.toSet().intersect(it.second.toSet()).first() }                      <i class="conum" data-value="2"></i><b>(2)</b>
    .sumOf { calcPriority(it) }                                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Split string into equal parts to represent compartments</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Determine common character by converting to set of characters and finding union</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Calculate the sum of the priorities</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_2"><a class="anchor" href="#_part_2_2"></a><a class="link" href="#_part_2_2">Part 2</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcBadges(input: List&lt;String&gt;): Int =
  input.mapIndexed { index, s -&gt; index / 3 to s }
    .groupBy({ it.first }, { it.second })           <i class="conum" data-value="1"></i><b>(1)</b>
    .map { e -&gt;
      e.value
        .map { it.toSet() }
        .reduce { a, b -&gt; a.intersect(b) }
        .first()                                    <i class="conum" data-value="2"></i><b>(2)</b>
    }
    .sumOf { calcPriority(it) }                     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Group strings by 3.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Determine common character from all 3 strings.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Calculate the sum of the priorities</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_takeaways"><a class="anchor" href="#_takeaways"></a><a class="link" href="#_takeaways">Takeaways</a></h5>
<div class="ulist">
<ul>
<li>
<p><code>String.toSet</code> gives to a <code>Set</code> of <code>Char</code></p>
</li>
<li>
<p><code>reduce</code> is a great way to determine the intersection on multiple sets.</p>
</li>
<li>
<p><code>groupBy</code> can take two parameters and with the second parameter you can determine the type of the value.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_full_source"><a class="anchor" href="#_full_source"></a><a class="link" href="#_full_source">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {

  fun calcPriority(value: Char): Int = when (value) {
    in 'a'..'z' -&gt; value - 'a' + 1
    in 'A'..'Z' -&gt; value - 'A' + 27
    else -&gt; error("Invalid input $value")
  }

  fun calcRucksacks(input: List&lt;String&gt;): Int =
    input.map { Pair(it.substring(0 until it.length / 2), it.substring(it.length / 2)) }
      .map { it.first.toSet().intersect(it.second.toSet()).first() }
      .sumOf { calcPriority(it) }

  fun calcBadges(input: List&lt;String&gt;): Int =
    input.mapIndexed { index, s -&gt; index / 3 to s }
      .groupBy({ it.first }, { it.second })
      .map { e -&gt; e.value.map { it.toSet() }.reduce { a, b -&gt; a.intersect(b) }.first() }
      .sumOf { calcPriority(it) }

  fun part1() {
    val testPriorities = calcRucksacks(readInput("day03_test"))
    println("Test Priorities = $testPriorities")
    check(testPriorities == 157)

    val priorities = calcRucksacks(readInput("day03"))
    println("Priorities = $priorities")
    check(priorities == 8123)
  }

  fun part2() {
    val testPriorities = calcBadges(readInput("day03_test"))
    println("Test Priorities = $testPriorities")
    check(testPriorities == 70)

    val priorities = calcBadges(readInput("day03"))
    println("Priorities = $priorities")
    check(priorities == 2620)
  }
  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_kotlin"><a class="anchor" href="#_day_04_kotlin"></a><a class="link" href="#_day_04_kotlin">Day 04: kotlin</a></h3>
<div class="sect3">
<h4 id="_camp_cleanup"><a class="anchor" href="#_camp_cleanup"></a><a class="link" href="#_camp_cleanup">Camp Cleanup</a></h4>
<div class="paragraph">
<p>I wasted some time today because I misunderstood the <strong>fully contains</strong> applying to a pair of assignments. I was trying to check across assignments. Re-reading when I got the wrong answer meant some <em>facepalms</em>.</p>
</div>
<div class="paragraph">
<p>We needed to convert the input depicting 2 ranges into sets of sections representing by numbers. So that meant converting <code>2-4,6-8</code> to a <code>Pair</code> of <code>IntRange</code> and then to a <code>Pair</code> of <code>Set&lt;Int&gt;</code> which it as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun convertRange(input: String): IntRange {
  val values = input.split("-")
  return values[0].toInt()..values[1].toInt()
}

fun convertRanges(input: List&lt;String&gt;): List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt; =
  input.map { it.split(",") }
    .map { Pair(convertRange(it[0]).toSet(), convertRange(it[1]).toSet()) }</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_part_1_2"><a class="anchor" href="#_part_1_2"></a><a class="link" href="#_part_1_2">Part 1</a></h5>
<div class="paragraph">
<p>Determining <strong>fully contains</strong> for part 1 was as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcContains(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
  return ranges.count {
    it.first.containsAll(it.second) || it.second.containsAll(it.first)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_3"><a class="anchor" href="#_part_2_3"></a><a class="link" href="#_part_2_3">Part 2</a></h5>
<div class="paragraph">
<p>And determining an <strong>overlap</strong> for part1 was as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcOverlap(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
  return ranges.count { it.first.intersect(it.second).isNotEmpty() }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_takeaways_2"><a class="anchor" href="#_takeaways_2"></a><a class="link" href="#_takeaways_2">Takeaways</a></h5>
<div class="paragraph">
<p>Re-read the problem because a lot of effort was made to explain with a complete example.</p>
</div>
<div class="paragraph">
<p><strong>If you first answer is incorrect you may have misunderstood something.</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_2"><a class="anchor" href="#_full_source_2"></a><a class="link" href="#_full_source_2">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
  fun convertRange(input: String): IntRange {
    val values = input.split("-")
    return values[0].toInt()..values[1].toInt()
  }

  fun convertRanges(input: List&lt;String&gt;): List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt; =
    input.map { it.split(",") }
      .map { Pair(convertRange(it[0]).toSet(), convertRange(it[1]).toSet()) }

  fun calcContains(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
    return ranges.count {
      it.first.containsAll(it.second) || it.second.containsAll(it.first)
    }
  }

  fun calcOverlap(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
    return ranges.count { it.first.intersect(it.second).isNotEmpty() }
  }

  fun part1() {
    val testInput = readInput("day04_test")
    val testCount = calcContains(convertRanges(testInput))
    println("Part 1 Test Count = $testCount")
    check(testCount == 2)

    val input = readInput("day04")
    val count = calcContains(convertRanges(input))
    println("Part 1 Count = $count")
    check(count == 524)
  }

  fun part2() {
    val testInput = readInput("day04_test")
    val testCount = calcOverlap(convertRanges(testInput))
    println("Part 2 Test Count = $testCount")
    check(testCount == 4)

    val input = readInput("day04")
    val count = calcOverlap(convertRanges(input))
    println("Part 2 Count = $count")
    check(count == 798)
  }
  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_kotlin"><a class="anchor" href="#_day_05_kotlin"></a><a class="link" href="#_day_05_kotlin">Day 05: kotlin</a></h3>
<div class="sect3">
<h4 id="_supply_stacks"><a class="anchor" href="#_supply_stacks"></a><a class="link" href="#_supply_stacks">Supply Stacks</a></h4>
<div class="paragraph">
<p>Today we had to implement a parser to read the state of stacks of containers and instructions for moving the containers. The result was a list of the top container labels.
I decided to create a data structure for the instructions and a simple Stack.</p>
</div>
<div class="sect4">
<h5 id="_data_structures"><a class="anchor" href="#_data_structures"></a><a class="link" href="#_data_structures">Data Structures</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">data class Instruction(val count: Int, val from: Int, val to: Int)

class Stack&lt;T&gt;(private val elements: MutableList&lt;T&gt; = mutableListOf&lt;T&gt;()) {
  fun empty(): Boolean = elements.isEmpty()
  fun peek(): T = elements[elements.lastIndex]
  fun pop(): T = elements.removeAt(elements.lastIndex)
  fun push(value: T) {
    elements.add(value)
  }

  fun items() = elements.toList()
  fun size() = elements.size
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_parsing_2"><a class="anchor" href="#_parsing_2"></a><a class="link" href="#_parsing_2">Parsing</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun readStack(lines: List&lt;String&gt;, stack: Int): Stack&lt;Char&gt; {
  val result = mutableListOf&lt;Char&gt;()
  val offset = stack * 4 + 1
  for (line in lines) {
    if (line.length &gt; offset) {
      val crate = line[offset]
      if (crate in 'A'..'Z') {
        result.add(crate)
      }
    }
  }
  result.reverse()
  println("Stack[${stack + 1}]=${result.joinToString("")}")
  return Stack(result)
}

fun loadStacks(input: List&lt;String&gt;): List&lt;Stack&lt;Char&gt;&gt; {
  val lines = input.toMutableList()
  val numbers = lines.last().split(" ").mapNotNull { if(it.isNotBlank()) it.toInt() else null }
  lines.removeAt(lines.lastIndex)
  val stacks = mutableListOf&lt;Stack&lt;Char&gt;&gt;()
  for (stack in numbers.indices) {
    stacks.add(readStack(lines, stack))
  }
  return stacks.toList()
}

fun loadInstructions(input: List&lt;String&gt;): List&lt;Instruction&gt; {
  val regex = """move (\d+) from (\d+) to (\d+)""".toRegex()
  return input.mapNotNull { line -&gt;
    regex.find(line)?.let {
      val (count, from, to) = it.destructured
      Instruction(count.toInt(), from.toInt(), to.toInt())
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_1_3"><a class="anchor" href="#_part_1_3"></a><a class="link" href="#_part_1_3">Part 1</a></h5>
<div class="paragraph">
<p>Perform all the instructions and provide the list of top level crates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun perform(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
  for (i in 1..instruction.count) {
    val crate = stacks[instruction.from - 1].pop()
    stacks[instruction.to - 1].push(crate)
  }
}
fun performAndFindTops(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
  instructions.forEach {
    perform(stacks, it)
  }
  return stacks.joinToString("") { it.peek().toString() }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_4"><a class="anchor" href="#_part_2_4"></a><a class="link" href="#_part_2_4">Part 2</a></h5>
<div class="paragraph">
<p>The crane can now move multiple containers at the same time retaining their order.
I decided to use a local stack to pop all the container and then push them again which will retain the order. The alternative would have been to adjust the Stack to remove multiple items at once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun perform9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
  println(instruction)
  val tmp = Stack&lt;Char&gt;()
  for (i in 1..instruction.count) {
    val crate = stacks[instruction.from - 1].pop()
    tmp.push(crate)
  }
  while (!tmp.empty()) {
    stacks[instruction.to - 1].push(tmp.pop())
  }
}
fun performAndFindTops9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
  instructions.forEach {
    perform9001(stacks, it)
  }
  return stacks.joinToString("") { it.peek().toString() }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_takeaways_3"><a class="anchor" href="#_takeaways_3"></a><a class="link" href="#_takeaways_3">Takeaways</a></h5>
<div class="paragraph">
<p>Sometimes a requirement change can impact your data structures in huge ways. Using a stack to represent the piles of crates was fine until we needed to move multiple crates at a time. In a real system the performance differences of moving multiple crates at the same time will be huge if it is a core part of the system.</p>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_3"><a class="anchor" href="#_full_source_3"></a><a class="link" href="#_full_source_3">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">data class Instruction(val count: Int, val from: Int, val to: Int)
class Stack&lt;T&gt;(private val elements: MutableList&lt;T&gt; = mutableListOf&lt;T&gt;()) {
  fun empty(): Boolean = elements.isEmpty()
  fun peek(): T = elements[elements.lastIndex]
  fun pop(): T = elements.removeAt(elements.lastIndex)
  fun push(value: T) {
    elements.add(value)
  }

  fun items() = elements.toList()
  fun size() = elements.size
}

fun main() {

  fun readStack(lines: List&lt;String&gt;, stack: Int): Stack&lt;Char&gt; {
    val result = mutableListOf&lt;Char&gt;()
    val offset = stack * 4 + 1
    for (line in lines) {
      if (line.length &gt; offset) {
        val crate = line[offset]
        if (crate in 'A'..'Z') {
          result.add(crate)
        }
      }
    }
    result.reverse()
    println("Stack[${stack + 1}]=${result.joinToString("")}")
    return Stack(result)
  }

  fun loadStacks(input: List&lt;String&gt;): List&lt;Stack&lt;Char&gt;&gt; {
    val lines = input.toMutableList()
    val numbers = lines.last().split(" ").mapNotNull { if(it.isNotBlank()) it.toInt() else null }
    lines.removeAt(lines.lastIndex)
    val stacks = mutableListOf&lt;Stack&lt;Char&gt;&gt;()
    for (stack in numbers.indices) {
      stacks.add(readStack(lines, stack))
    }
    return stacks.toList()
  }

  fun loadInstructions(input: List&lt;String&gt;): List&lt;Instruction&gt; {
    val regex = """move (\d+) from (\d+) to (\d+)""".toRegex()
    return input.mapNotNull { line -&gt;
      regex.find(line)?.let {
        val (count, from, to) = it.destructured
        Instruction(count.toInt(), from.toInt(), to.toInt())
      }
    }
  }

  fun perform(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
    for (i in 1..instruction.count) {
      val crate = stacks[instruction.from - 1].pop()
      stacks[instruction.to - 1].push(crate)
    }
  }

  fun perform9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
    val tmp = Stack&lt;Char&gt;()
    for (i in 1..instruction.count) {
      val crate = stacks[instruction.from - 1].pop()
      tmp.push(crate)
    }
    while (!tmp.empty()) {
      stacks[instruction.to - 1].push(tmp.pop())
    }
  }

  fun performAndFindTops(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
    instructions.forEach {
      perform(stacks, it)
    }
    stacks.forEach { stack -&gt; println("[${stack.items().joinToString("")}]") }
    return stacks.joinToString("") { it.peek().toString() }
  }

  fun performAndFindTops9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
    instructions.forEach {
      perform9001(stacks, it)
    }
    stacks.forEach { stack -&gt; println("[${stack.items().joinToString("")}]") }
    return stacks.joinToString("") { it.peek().toString() }
  }

  val test = """    [D]
[N] [C]
[Z] [M] [P]
 1   2   3

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
"""

  val testInputs = test.split("\n\n").map { readText(it) }
  val input = readFileGroup("day05")
  fun part1() {
    val testTops = performAndFindTops(loadStacks(testInputs[0]), loadInstructions(testInputs[1]))
    println("Part 1 Test Tops = $testTops")
    check(testTops == "CMZ")
    val tops = performAndFindTops(loadStacks(input[0]), loadInstructions(input[1]))
    println("Part 1 Tops = $tops")
    check(tops == "PTWLTDSJV")
  }

  fun part2() {
    val testTops = performAndFindTops9001(loadStacks(testInputs[0]), loadInstructions(testInputs[1]))
    println("Part 2 Test Tops = $testTops")
    check(testTops == "MCD")
    val tops = performAndFindTops9001(loadStacks(input[0]), loadInstructions(input[1]))
    println("Part 2 Tops = $tops")
    check(tops == "WZMFVGGZP")
  }

  part1()
  part2()

}</code></pre>
</div>
</div>
<a id="day06" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_06_kotlin"><a class="anchor" href="#_day_06_kotlin"></a><a class="link" href="#_day_06_kotlin">Day 06: kotlin</a></h3>
<div class="sect3">
<h4 id="_tuning_trouble"><a class="anchor" href="#_tuning_trouble"></a><a class="link" href="#_tuning_trouble">Tuning Trouble</a></h4>
<div class="paragraph">
<p>Today was probably the easiest one so far from my perspective. We had to write a simple parser to find the first unique sequence of characters with a given length and report the number of characters read.</p>
</div>
<div class="paragraph">
<p>The Kotlin collections method <code>windowed</code> provides a way to create a window over an <code>Iterable</code> and provides a simple way to solve this. Checking that the content of the window as a unique set is the same size as the window.</p>
</div>
<div class="sect4">
<h5 id="_solution"><a class="anchor" href="#_solution"></a><a class="link" href="#_solution">Solution</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun findUniquePacketEnd(input: String, packetSize: Int): Int {
  return input.toList()
    .windowed(packetSize)
    .indexOfFirst { it.toSet().size == packetSize } + packetSize
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_4"><a class="anchor" href="#_full_source_4"></a><a class="link" href="#_full_source_4">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
  fun findUniquePacketEnd(input: String, packetSize: Int): Int {
    return input.toList()
      .windowed(packetSize)
      .indexOfFirst { it.toSet().size == packetSize } + packetSize
  }

  val input = readFileToString("day06")

  fun part1() {
    val testStart = findUniquePacketEnd("nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg", 4)
    println("Part1 Test Start = $testStart")
    check(testStart == 10)
    val start = findUniquePacketEnd(input, 4)
    println("Part1 Start = $start")
    check(start == 1965)
  }

  fun part2() {
    val testStart = findUniquePacketEnd("nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg", 14)
    println("Part 2 Test Message = $testStart")
    check(testStart == 29)
    val start = findUniquePacketEnd(input, 14)
    println("Part 2 Start = $start")
    check(start == 2773)
  }
  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day07" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_07_kotlin"><a class="anchor" href="#_day_07_kotlin"></a><a class="link" href="#_day_07_kotlin">Day 07: kotlin</a></h3>
<div class="sect3">
<h4 id="_no_space_left_on_device"><a class="anchor" href="#_no_space_left_on_device"></a><a class="link" href="#_no_space_left_on_device">No Space Left On Device</a></h4>
<div class="paragraph">
<p>We had to parse a series of commands and output representing changing to and listing directories as in the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-shell" data-lang="shell">$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k</code></pre>
</div>
</div>
<div class="paragraph">
<p>The aim was to determine directory sizes.
In the first case the challenge was to find directories with a total size including children of below a threshold and the second problem was to find the smallest directory above a certain size.</p>
</div>
<div class="sect4">
<h5 id="_data_model"><a class="anchor" href="#_data_model"></a><a class="link" href="#_data_model">Data Model</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  data class FileInfo(val name: String, val size: Int)

  class Directory(val name: String) {
    private val files = mutableMapOf&lt;String, FileInfo&gt;()
    private val directories = mutableMapOf&lt;String, Directory&gt;()
    fun listDirectories() = directories.values.toList()
    fun hasDir(dirname: String): Boolean = directories.containsKey(dirname)
    fun getDir(dirname: String) = directories[dirname]
    fun addDir(dirname: String): Directory = directories.getOrPut(dirname) { Directory(dirname) }
    fun addFile(name: String, size: Int): FileInfo {
      val file = FileInfo(name, size)
      files[name] = file
      return file
    }
    fun listFiles(): List&lt;FileInfo&gt; = files.values.toList()
    fun fileSizes(): Int = files.values.sumOf { it.size }
    fun totalSize(): Int = fileSizes() + directories.values.sumOf { it.totalSize() }

    override fun toString(): String {
      return "Directory(name='$name'," +
                "directories=${directories.values.map { it.name }.toList()}," +
                "files=${files.values.map { "${it.name}:${it.size}" }}" +
              ")"
    }
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (javaClass != other?.javaClass) return false

      other as Directory

      if (name != other.name) return false

      return true
    }
    override fun hashCode(): Int {
      return name.hashCode()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_parsing_3"><a class="anchor" href="#_parsing_3"></a><a class="link" href="#_parsing_3">Parsing</a></h5>
<div class="paragraph">
<p>The parsing meant keeping track of the directory tree and the current directory.
I used the <code>Stack</code> from Day 05 to maintain the parent directories.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun parseCommandsAndOutput(lines: List&lt;String&gt;): Directory {
  val root = Directory("/")
  val dirs = Stack&lt;Directory&gt;()
  dirs.push(root)
  var current = root
  for(line in lines) {
    val data = line.split(" ")
    when {
      data[0] == "$" &amp;&amp; data[1] == "cd" &amp;&amp; data[2] == "/" -&gt; { dirs.clear(); dirs.push(root) }
      data[0] == "$" &amp;&amp; data[1] == "cd" &amp;&amp; data[2] == ".." -&gt; { dirs.pop(); current = dirs.peek()}
      data[0] == "$" &amp;&amp; data[1] == "cd" -&gt; { dirs.push(current.addDir(data[2])); current = dirs.peek() }
      data[0] == "$" &amp;&amp; data[1] == "ls" -&gt; println("listing ${dirs.items().joinToString("/") { it.name }}")
      data[0] == "dir" -&gt; current.addDir(data[1])
      else -&gt; {
        val file = current.addFile(data[1], data[0].toInt())
        println("file=dir:${current.name} + ${file.name}:${file.size}")
      }
    }
  }
  return root
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solutions"><a class="anchor" href="#_solutions"></a><a class="link" href="#_solutions">Solutions</a></h5>
<div class="paragraph">
<p>Both solutions need to obtain a list of all directories.</p>
</div>
<div class="sect5">
<h6 id="_shared"><a class="anchor" href="#_shared"></a><a class="link" href="#_shared">Shared</a></h6>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun listAllDirectories(directories: Directory): List&lt;Directory&gt; {
  val result = mutableListOf&lt;Directory&gt;()
  directories.listDirectories().forEach {
    result.add(it)
    result.addAll(listAllDirectories(it))
  }
  return result
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_part_1_4"><a class="anchor" href="#_part_1_4"></a><a class="link" href="#_part_1_4">Part 1</a></h6>
<div class="paragraph">
<p>Find the directory sizes at most 100000 and calculate the total.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcDirectoriesBelow(input: List&lt;String&gt;, maxValue: Int): Int {
  val root = parseCommandsAndOutput(input)
  val directories = listAllDirectories(root)
  return directories.map { it.totalSize() }.filter { it &lt;= maxValue }.sum()
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_part_2_5"><a class="anchor" href="#_part_2_5"></a><a class="link" href="#_part_2_5">Part 2</a></h6>
<div class="paragraph">
<p>Find the small of the directories large enough to delete in order to free up enough space so that at least 30000000 of 70000000 is unused.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcDirectoriesToFree(input: List&lt;String&gt;, diskSize: Int, freeSpace: Int): Int {
  val root = parseCommandsAndOutput(input)
  val directories = listAllDirectories(root)
  val unused = diskSize - root.totalSize()
  val requiredDelete = freeSpace - unused
  return directories.map { it.totalSize() }.filter { it &gt; requiredDelete }.min()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_5"><a class="anchor" href="#_full_source_5"></a><a class="link" href="#_full_source_5">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
  val test = readFile("day07_test")
  val input = readFile("day07")

  data class FileInfo(val name: String, val size: Int)
  class Directory(val name: String) {
    private val files = mutableMapOf&lt;String, FileInfo&gt;()
    private val directories = mutableMapOf&lt;String, Directory&gt;()
    fun listDirectories() = directories.values.toList()

    fun hasDir(dirname: String): Boolean = directories.containsKey(dirname)
    fun getDir(dirname: String) = directories[dirname]
    fun addDir(dirname: String): Directory = directories.getOrPut(dirname) { Directory(dirname) }
    fun addFile(name: String, size: Int): FileInfo {
      val file = FileInfo(name, size)
      files[name] = file
      return file
    }

    fun listFiles(): List&lt;FileInfo&gt; = files.values.toList()
    fun fileSizes(): Int = files.values.sumOf { it.size }
    fun totalSize(): Int = fileSizes() + directories.values.sumOf { it.totalSize() }
    override fun toString(): String {
      return "Directory(name='$name',directories=${
        directories.values.map { it.name }.toList()
      },files=${files.values.map { "${it.name}:${it.size}" }})"
    }

    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (javaClass != other?.javaClass) return false

      other as Directory

      if (name != other.name) return false

      return true
    }

    override fun hashCode(): Int {
      return name.hashCode()
    }

    private fun printTree(dir: Directory, depth: Int) {
      println("- ${dir.name} (dir)")
      val prefix = 0 until depth
      dir.listDirectories().forEach {
        prefix.forEach { _ -&gt; print(' ') }
        printTree(it, depth + 2)
      }
      dir.listFiles().forEach {
        prefix.forEach { _ -&gt; print(' ') }
        println("- ${it.name} (file, size = ${it.size})")
      }
    }

    fun printTree() = printTree(this, 0)
  }

  fun listAllDirectories(directories: Directory): List&lt;Directory&gt; {
    val result = mutableListOf&lt;Directory&gt;()
    directories.listDirectories().forEach {
      result.add(it)
      result.addAll(listAllDirectories(it))
    }
    return result
  }

  fun parseCommandsAndOutput(input: List&lt;String&gt;): Directory {
    val root = Directory("/")
    val dirs = Stack&lt;Directory&gt;()
    dirs.push(root)
    var current = root
    input.forEach { line -&gt;
      val data = line.split(" ")
      when {
        data[0] == "$" &amp;&amp; data[1] == "cd" &amp;&amp; data[2] == "/" -&gt; { dirs.clear(); dirs.push(root) }
        data[0] == "$" &amp;&amp; data[1] == "cd" &amp;&amp; data[2] == ".." -&gt; { dirs.pop(); current = dirs.peek()}
        data[0] == "$" &amp;&amp; data[1] == "cd" -&gt; { dirs.push(current.addDir(data[2])); current = dirs.peek() }
        data[0] == "$" &amp;&amp; data[1] == "ls" -&gt; println("listing ${dirs.items().joinToString("/") { it.name }}")
        data[0] == "dir" -&gt; current.addDir(data[1])
        else -&gt; {
          val file = current.addFile(data[1], data[0].toInt())
          println("file=dir:${current.name} + ${file.name}:${file.size}")
        }
      }
    }
    return root
  }


  fun calcDirectoriesBelow(input: List&lt;String&gt;, maxValue: Int): Int {
    val root = parseCommandsAndOutput(input)
    root.printTree()
    val directories = listAllDirectories(root)
    return directories.map { it.totalSize() }.filter { it &lt;= maxValue }.sum()
  }

  fun calcDirectoriesToFree(input: List&lt;String&gt;, diskSize: Int, freeSpace: Int): Int {
    val root = parseCommandsAndOutput(input)
    val directories = listAllDirectories(root)
    val unused = diskSize - root.totalSize()
    val requiredDelete = freeSpace - unused
    return directories.map { it.totalSize() }.filter { it &gt; requiredDelete }.min()
  }


  fun part1() {
    val testResult = calcDirectoriesBelow(test, 100000)
    println("Part 1 Answer = $testResult")
    check(testResult == 95437)
    separator()
    val result = calcDirectoriesBelow(input, 100000)
    check(result == 1792222)
    println("Part 1 Answer = $result")
    separator()
  }

  fun part2() {
    val testResult = calcDirectoriesToFree(test, 70000000, 30000000)
    println("Part 2 Answer = $testResult")
    check(testResult == 24933642)
    separator()
    val result = calcDirectoriesToFree(input, 70000000, 30000000)
    println("Part 2 Answer = $result")
    check(result == 1112963)
    separator()
  }
  println("Day - 07")
  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day08" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_08_kotlin"><a class="anchor" href="#_day_08_kotlin"></a><a class="link" href="#_day_08_kotlin">Day 08: kotlin</a></h3>
<div class="sect3">
<h4 id="_treetop_tree_house"><a class="anchor" href="#_treetop_tree_house"></a><a class="link" href="#_treetop_tree_house">Treetop Tree House</a></h4>
<div class="paragraph">
<p>Today&#8217;s puzzle was all about creating a grid and determining the state of coordinates given certain conditions.</p>
</div>
<div class="sect4">
<h5 id="_model"><a class="anchor" href="#_model"></a><a class="link" href="#_model">Model</a></h5>
<div class="paragraph">
<p>I decided to create a class to represent the grid as an array of int array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">class Grid(val lines: Array&lt;IntArray&gt;) {
    fun width() = lines[0].size
    fun height() = lines.size
    fun get(x: Int, y: Int) = lines[x][y]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_parsing_4"><a class="anchor" href="#_parsing_4"></a><a class="link" href="#_parsing_4">Parsing</a></h5>
<div class="paragraph">
<p>The data was presents as lines of digits, each digits represented a tree and the value was the height of the tree.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-text" data-lang="text">30373
25512
65332
33549
35390</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parsing meant converting each line to an array of int by converting each character to it&#8217;s integer representation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun parseGrid(input: List&lt;String&gt;): Grid {
  return Grid(input.map { line -&gt; line.toList().map { it - '0' }.toIntArray() }.toTypedArray())
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_1_5"><a class="anchor" href="#_part_1_5"></a><a class="link" href="#_part_1_5">Part 1</a></h5>
<div class="paragraph">
<p>We had to determine how many trees are visible considering it is invisible it there is a tree of similar or greater height above or below, to the left or right.</p>
</div>
<div class="paragraph">
<p>I added a visible method to Grid</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun visible(x: Int, y: Int): Boolean {
  val treeHeight = get(x, y)
  var bottom = true
  var top = true
  var left = true
  var right = true
  for (i in 0 until x) {
    val tree = get(i, y)
    if (tree &gt;= treeHeight) {
      top = false
      break
    }
  }
  for (i in x + 1 until height()) {
   if (get(i, y) &gt;= treeHeight) {
      bottom = false
      break
    }
  }
 for (i in y + 1 until width()) {
   if (get(x, i) &gt;= treeHeight) {
      right = false
      break
    }
  }
  for (i in 0 until y) {
    if (get(x, i) &gt;= treeHeight) {
      left = false
      break
    }
  }
  return top || bottom || left || right
}

fun calcVisible(grid: Grid): Int {
  val height = grid.height()
  val width = grid.width()
  var result = (height * 2) + (width * 2) - 4
  for (x in 1 until height - 1) {
    for (y in 1 until width - 1) {
      if (grid.visible(x, y)) {
        result += 1
      }
    }
  }
  return result
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_6"><a class="anchor" href="#_part_2_6"></a><a class="link" href="#_part_2_6">Part 2</a></h5>
<div class="paragraph">
<p>We had to calculate a scenic value for each tree and determine the answer was maximum scenic.
The scenic value was determined by how many trees were visible from a given tree.</p>
</div>
<div class="paragraph">
<p>I added a scenic method to Grid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun scenic(x: Int, y: Int): Int {
  val treeHeight = get(x, y)
  var bottom = 0
  var top = 0
  var left = 0
  var right = 0
  for (i in x + 1 until height()) {
    bottom += 1
    if (get(i, y) &gt;= treeHeight) {
      break
    }
  }
  for (i in x - 1 downTo  0 ) {
    top += 1
    if (get(i, y) &gt;= treeHeight) {
      break
    }
  }
  for (i in y + 1 until width()) {
    right += 1
    if (get(x, i) &gt;= treeHeight) {
      break
    }
  }
  for (i in y - 1 downTo  0 ) {
    left += 1
    if (get(x, i) &gt;= treeHeight) {
      break
    }
  }
  return bottom * left * right * top
}

fun calcMaxScenic(grid: Grid): Int {
  val height = grid.height()
  val width = grid.width()
  var result = 0
  for (x in 1 until height - 1) {
    for (y in 1 until width - 1) {
      result = max(result, grid.scenic(x, y))
    }
  }
  return result
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_6"><a class="anchor" href="#_full_source_6"></a><a class="link" href="#_full_source_6">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">import kotlin.math.max

fun main() {
  val test = readLines(
    """30373
25512
65332
33549
35390"""
  )
  val input = readFile("day08")

  class Grid(val lines: Array&lt;IntArray&gt;) {
    fun width() = lines[0].size
    fun height() = lines.size
    fun get(x: Int, y: Int) = lines[x][y]
    fun visible(x: Int, y: Int): Boolean {
      val treeHeight = get(x, y)
      var bottom = true
      var top = true
      var left = true
      var right = true
      for (i in 0 until x) {
        val tree = get(i, y)
        if (tree &gt;= treeHeight) {
          top = false
          break
        }
      }
      for (i in x + 1 until height()) {
        if (get(i, y) &gt;= treeHeight) {
          bottom = false
          break
        }
      }
      for (i in y + 1 until width()) {
        if (get(x, i) &gt;= treeHeight) {
          right = false
          break
        }
      }
      for (i in 0 until y) {
        if (get(x, i) &gt;= treeHeight) {
          left = false
          break
        }
      }
      return top || bottom || left || right
    }

    fun scenic(x: Int, y: Int): Int {
      val treeHeight = get(x, y)
      var bottom = 0
      var top = 0
      var left = 0
      var right = 0
      for (i in x + 1 until height()) {
        bottom += 1
        if (get(i, y) &gt;= treeHeight) {
          break
        }
      }
      for (i in x - 1 downTo  0 ) {
        top += 1
        if (get(i, y) &gt;= treeHeight) {
          break
        }
      }
      for (i in y + 1 until width()) {
        right += 1
        if (get(x, i) &gt;= treeHeight) {
          break
        }
      }
      for (i in y - 1 downTo  0 ) {
        left += 1
        if (get(x, i) &gt;= treeHeight) {
          break
        }
      }
      return bottom * left * right * top
    }
  }

  fun parseGrid(input: List&lt;String&gt;): Grid {
    return Grid(input.map { line -&gt; line.toList().map { it - '0' }.toIntArray() }.toTypedArray())
  }

  fun calcVisible(grid: Grid): Int {
    val height = grid.height()
    val width = grid.width()
    var result = (height * 2) + (width * 2) - 4
    for (x in 1 until height - 1) {
      for (y in 1 until width - 1) {
        if (grid.visible(x, y)) {
          result += 1
        }
      }
    }
    return result
  }

  fun calcMaxScenic(grid: Grid): Int {
    val height = grid.height()
    val width = grid.width()
    var result = 0
    for (x in 1 until height - 1) {
      for (y in 1 until width - 1) {
        result = max(result, grid.scenic(x, y))
      }
    }
    return result
  }

  fun part1() {
    val testResult = calcVisible(parseGrid(test))
    println("Part 1 Answer = $testResult")
    check(testResult == 21)
    val result = calcVisible(parseGrid(input))
    println("Part 1 Answer = $result")
    check(result == 1851)
  }

  fun part2() {
    val testResult = calcMaxScenic(parseGrid(test))
    println("Part 2 Answer = $testResult")
    check(testResult == 8)
    val result = calcMaxScenic(parseGrid(input))
    println("Part 1 Answer = $result")
    check(result == 574080)
  }
  println("Day - 08")
  separator()
  part1()
  separator()
  part2()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>