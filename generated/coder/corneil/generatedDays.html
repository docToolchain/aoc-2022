<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Aoc 2022: corneil</title>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="JZ7jk3duxzxHDLuOHKPxc-uoz0JPlSBLeaAxh3wGn9Q" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Just for fun">
    <meta name="author" content="Ralf D. MÃ¼ller">
    <meta name="keywords" content="aoc">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">
      <link href="../../../css/retro.css" rel="stylesheet">
      <style>
      @media only screen and (min-width:768px){
          #toctitle{font-size:1.375em}
          #toc.toc{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto; padding-top: 60px;}
          #toc.toc #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
          #toc.toc>ul{font-size:.9em;margin-bottom:0}
          #toc.toc ul ul{margin-left:0;padding-left:1em}
          #toc.toc ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
          body.toc2{ padding-left: 15.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:15em; padding-top: 60px;}
      }
      @media only screen and (min-width:1280px){
          body.toc2{ padding-left: 20.5em;padding-right:0; width: 100% !important;}
          body.toc2 div#wrap div.content {width: auto !important;}
          #toc.toc{width:20em; padding-top: 60px;}
          #toc.toc #toctitle{font-size:1.375em}
          #toc.toc>ul{font-size:.95em}
          #toc.toc ul ul{padding-left:1.25em}
      }
      body {
          overflow-y: scroll;
      }
      html, body {
          font-size: 1.06rem;
      }
      body.toc2{ overflow-x: auto}
      #toc.toc ul {
          padding-inline-start: 0;
      }
      :target::before {
          content: "";
          display: block;
          height: 60px; /* fixed header height*/
          margin: -60px 0 0; /* negative fixed header height */
      }
      .navbar {
          background-image: url(/aoc-2022/images/treeback.png);
          background-size: contain;
          background-repeat: repeat-x;
          border-bottom: 0;
          padding-bottom: 20px;
          background-color: transparent;
          box-shadow: none;
      }
      html {
          background: url(/aoc-2022/images/snowback.png) no-repeat center center fixed;
          -webkit-background-size: cover;
          -moz-background-size: cover;
          -o-background-size: cover;
          background-size: cover;
      }

      </style>
      <script>
          //smart redirectg
          if (document.location.href.includes("netlify")) {
              document.location.href=document.location.href.replace("aoc-2022.netlify.app/","doctoolchain.org/aoc-2022/");
          }
      </script>
<!-- /aoc-2022/ -->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

      <link rel="apple-touch-icon" sizes="180x180" href="/aoc-2022//apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/aoc-2022//favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/aoc-2022//favicon-16x16.png">
      <link rel="manifest" href="/aoc-2022//site.webmanifest">
      <link rel="mask-icon" href="/aoc-2022//safari-pinned-tab.svg" color="#5bbad5">
      <meta name="msapplication-TileColor" content="#da532c">
      <meta name="theme-color" content="#ffffff">
  </head>

<body onload="prettyPrint()" class="toc2 toc-left" >
<div id="wrap">

	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">AoC-2022</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
              
                
                  <li><a href="../../../rules/">Rules</a></li>
                
              
                
                  <li><a href="../../../solutions/">Solutions</a></li>
                
              
                
                  <li><a href="../../../about/">About</a></li>
                
              
          </ul>
            <!-- tag::search[] -->
            <form class="navbar-form navbar-right" action="https://google.de/search" style="border: none;">
                <div class="form-group">
                    <input type="hidden" name="q" value="site:doctoolchain.org/aoc-2022">
                    <input type="text" name="q" class="form-control" id="search">
                    <button type="submit" class="btn btn-default hidden-sm ">Find</button>
                </div>
            </form>
            <!-- end::search[] -->
        </div><!--/.nav-collapse -->
      </div>
    </div>

	<div class="container content">
	<p><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_corneil">corneil</a>
<ul class="sectlevel2">
<li><a href="#_about_me">About me</a></li>
<li><a href="#_day_00_kotlin">Day 00: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_hello_world">Hello World!</a></li>
</ul>
</li>
<li><a href="#_day_01_kotlin">Day 01: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_calorie_counting">Calorie Counting</a>
<ul class="sectlevel4">
<li><a href="#_parsing">Parsing</a></li>
<li><a href="#_part_1">Part 1</a></li>
<li><a href="#_part_2">Part 2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_02_kotlin">Day 02: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_rock_paper_scissors">Rock Paper Scissors</a></li>
</ul>
</li>
<li><a href="#_day_03_kotlin">Day 03: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_rucksack_reorganization">Rucksack Reorganization</a>
<ul class="sectlevel4">
<li><a href="#_calculating_the_priority">Calculating the priority</a></li>
<li><a href="#_part1">Part1</a></li>
<li><a href="#_part_2_2">Part 2</a></li>
<li><a href="#_takeaways">Takeaways</a></li>
<li><a href="#_full_source">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_04_kotlin">Day 04: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_camp_cleanup">Camp Cleanup</a>
<ul class="sectlevel4">
<li><a href="#_part_1_2">Part 1</a></li>
<li><a href="#_part_2_3">Part 2</a></li>
<li><a href="#_takeaways_2">Takeaways</a></li>
<li><a href="#_full_source_2">Full source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_day_05_kotlin">Day 05: kotlin</a>
<ul class="sectlevel3">
<li><a href="#_supply_stacks">Supply Stacks</a>
<ul class="sectlevel4">
<li><a href="#_data_structures">Data Structures</a></li>
<li><a href="#_parsing_2">Parsing</a></li>
<li><a href="#_part_1_3">Part 1</a></li>
<li><a href="#_part_2_4">Part 2</a></li>
<li><a href="#_takeaways_3">Takeaways</a></li>
<li><a href="#_full_source_3">Full source</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_corneil"><a class="anchor" href="#_corneil"></a><a class="link" href="#_corneil">corneil</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="https://avatars.githubusercontent.com/u/466422?v=4" alt="466422?v=4" width="100px"></span></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>corneil</strong><br>
Corneil du Plessis<br>
Github: <a href="https://github.com/corneil">corneil</a><br>
Twitter: <a href="https://twitter.com/corneil">@corneil</a><br>
Mastodon: <a href="https://mastodon.social/@corneil">@corneil@mastodon.social</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_about_me"><a class="anchor" href="#_about_me"></a><a class="link" href="#_about_me">About me</a></h3>
<div class="paragraph">
<p>I am a Staff Software Engineer at VMware working on the Spring Cloud Data Flow team. I enjoyed AoC 2019 and decided to give it another go this year.</p>
</div>
<div class="paragraph">
<p>I love coding in Kotlin and I try write the code solving the puzzles in a way that someone else can understand the solution.</p>
</div>
<a id="day00" />
</div>
<div class="sect2">
<h3 id="_day_00_kotlin"><a class="anchor" href="#_day_00_kotlin"></a><a class="link" href="#_day_00_kotlin">Day 00: kotlin</a></h3>
<div class="sect3">
<h4 id="_hello_world"><a class="anchor" href="#_hello_world"></a><a class="link" href="#_hello_world">Hello World!</a></h4>
<div class="paragraph">
<p>This is a simple Hello World program in <a href="https://kotlinlang.org">Kotlin</a>, if you want to experiment with Kotlin use the <a href="https://play.kotlinlang.org">Kotlin Playground</a></p>
</div>
<div class="paragraph">
<p>My aim with <a href="https://adventofcode.com/2021">Advent of Code</a> is to write code solving the puzzles in a way that is understandable to a wide audience.
Feel free to reach out with comments at the links above.</p>
</div>
<a id="day01" />
</div>
</div>
<div class="sect2">
<h3 id="_day_01_kotlin"><a class="anchor" href="#_day_01_kotlin"></a><a class="link" href="#_day_01_kotlin">Day 01: kotlin</a></h3>
<div class="sect3">
<h4 id="_calorie_counting"><a class="anchor" href="#_calorie_counting"></a><a class="link" href="#_calorie_counting">Calorie Counting</a></h4>
<div class="paragraph">
<p>In order to follow these solutions you will need to login to <a href="https://adventofcode.com/2022">Advent of Code</a> and complete each day.</p>
</div>
<div class="paragraph">
<p>The day was lines representing the calories of food items carried by elves and separated by blank lines.
Kotlin File has a readLines function that makes it easy to parse the input, calculate the calories for each elf and add to a list.</p>
</div>
<div class="sect4">
<h5 id="_parsing"><a class="anchor" href="#_parsing"></a><a class="link" href="#_parsing">Parsing</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  fun findCalories(input: List&lt;String&gt;): List&lt;Int&gt; {
    val elves = mutableListOf&lt;Int&gt;()
    var calories = 0
    for (line in input) {
      if (line.isBlank()) {
        elves.add(calories)
        calories = 0
      } else {
        calories += line.toInt()
      }
    }
    elves.add(calories)
    return elves
  }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_1"><a class="anchor" href="#_part_1"></a><a class="link" href="#_part_1">Part 1</a></h5>
<div class="paragraph">
<p>For part one the max value it the answer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  fun findMaxCalories(input: List&lt;String&gt;): Int {
    val calories = findCalories(input)
    return calories.max()
  }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2"><a class="anchor" href="#_part_2"></a><a class="link" href="#_part_2">Part 2</a></h5>
<div class="paragraph">
<p>For part two the result is the sum of the first three when sorted in descending order. Kotlin has the <code>take</code> method on collections which is very useful in this case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">  fun topThree(input: List&lt;String&gt;): Int {
    val calories = findCalories(input)
    return calories.sortedDescending().take(3).sum()
  }</code></pre>
</div>
</div>
<a id="day02" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_02_kotlin"><a class="anchor" href="#_day_02_kotlin"></a><a class="link" href="#_day_02_kotlin">Day 02: kotlin</a></h3>
<div class="sect3">
<h4 id="_rock_paper_scissors"><a class="anchor" href="#_rock_paper_scissors"></a><a class="link" href="#_rock_paper_scissors">Rock Paper Scissors</a></h4>
<div class="paragraph">
<p>Part 1 meant we needed to parse input representing an opponent hand when playing RPS, and we had to assume the 2nd input was an answer we needed to provide while "cheating".</p>
</div>
<div class="paragraph">
<p>Part 2 came with a curveball in that the 2nd input should be treated as an outcome. This means we needed to find the correct hand for the outcome.
The score calculation was a function of the outcome and the hand we selected.</p>
</div>
<div class="paragraph">
<p>Below is the final code and there are loaders for creating the rounds for part 1 and part 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">enum class Rps(val identifiers: String, val shapeScore: Int) {
  ROCK("AX", 1),
  PAPER("BY", 2),
  SCISSORS("CZ", 3)
}

enum class Outcome(val identifier: String, val score: Int) {
  LOSE("X", 0),
  DRAW("Y", 3),
  WIN("Z", 6)
}

data class Hand(val them: Rps, val me: Rps)

object Rules {

  data class Rule(val loser: Rps, val winner: Rps)

  private val beats = mapOf(
    Rps.ROCK to Rule(Rps.SCISSORS, Rps.PAPER),
    Rps.PAPER to Rule(Rps.ROCK, Rps.SCISSORS),
    Rps.SCISSORS to Rule(Rps.PAPER, Rps.ROCK)
  )

  fun winner(shape: Rps): Rps {
    val winner = beats[shape] ?: error("Cannot find $shape")
    return winner.winner
  }

  fun loser(shape: Rps): Rps {
    val loser = beats[shape] ?: error("Cannot find $shape")
    return loser.loser
  }

  fun didIWin(round: Hand): Boolean {
    val shape = loser(round.me)
    return shape == round.them
  }

}

fun main() {

  fun toRps(hint: String): Rps {
    return Rps.values().find { it.identifiers.contains(hint) } ?: error("Invalid RPS $hint")
  }

  fun toOutcome(outcome: String): Outcome {
    return Outcome.values().find { it.identifier == outcome } ?: error("Invalid Outcome:$outcome")
  }

  fun readRounds(input: List&lt;String&gt;): List&lt;Hand&gt; {
    return input.map {
      val hints = it.split(" ")
      Hand(toRps(hints[0]), toRps(hints[1]))
    }
  }

  // choose a shape to match the outcome
  fun chooseShape(shape: Rps, outcome: Outcome): Rps {
    return when (outcome) {
      Outcome.DRAW -&gt; shape
      Outcome.WIN -&gt; Rules.winner(shape)
      Outcome.LOSE -&gt; Rules.loser(shape)
    }
  }

  // convert 2nd to outcome and then find a shape to match outcome given 1st
  fun readRounds2(input: List&lt;String&gt;): List&lt;Hand&gt; {
    return input.map {
      val hints = it.split(" ")
      Pair(toRps(hints[0]), toOutcome(hints[1]))
    }.map {
      Hand(it.first, chooseShape(it.first, it.second))
    }
  }

  fun calcRound(round: Hand): Int {
    return when {
      round.them == round.me -&gt; Outcome.DRAW.score
      Rules.didIWin(round) -&gt; Outcome.WIN.score
      else -&gt; Outcome.LOSE.score
    }
  }

  fun calcScore(round: Hand): Int {
    return round.me.shapeScore + calcRound(round)
  }

  fun calcTotal(rounds: List&lt;Hand&gt;): Int {
    return rounds.sumOf { calcScore(it) }
  }

  fun part1() {

    val testScore = calcTotal(readRounds(readInput("day02_test")))
    println("Test Total = $testScore")
    check(testScore == 15)

    val total = calcTotal(readRounds(readInput("day02")))
    println("Total = $total")

  }

  fun part2() {

    val testScore2 = calcTotal(readRounds2(readInput("day02_test")))
    println("Test Total 2 = $testScore2")
    check(testScore2 == 12)

    val total2 = calcTotal(readRounds2(readInput("day02")))
    println("Total 2 = $total2")
  }

  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day03" />
</div>
</div>
<div class="sect2">
<h3 id="_day_03_kotlin"><a class="anchor" href="#_day_03_kotlin"></a><a class="link" href="#_day_03_kotlin">Day 03: kotlin</a></h3>
<div class="sect3">
<h4 id="_rucksack_reorganization"><a class="anchor" href="#_rucksack_reorganization"></a><a class="link" href="#_rucksack_reorganization">Rucksack Reorganization</a></h4>
<div class="paragraph">
<p>Today puzzle was about manipulating strings and calculating the values of characters according rules.</p>
</div>
<div class="sect4">
<h5 id="_calculating_the_priority"><a class="anchor" href="#_calculating_the_priority"></a><a class="link" href="#_calculating_the_priority">Calculating the priority</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcPriority(value: Char): Int = when (value) {
  in 'a'..'z' -&gt; value - 'a' + 1
  in 'A'..'Z' -&gt; value - 'A' + 27
  else -&gt; error("Invalid input $value")
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part1"><a class="anchor" href="#_part1"></a><a class="link" href="#_part1">Part1</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcRucksacks(input: List&lt;String&gt;): Int =
  input.map { Pair(it.substring(0 until it.length / 2), it.substring(it.length / 2)) }  <i class="conum" data-value="1"></i><b>(1)</b>
    .map { it.first.toSet().intersect(it.second.toSet()).first() }                      <i class="conum" data-value="2"></i><b>(2)</b>
    .sumOf { calcPriority(it) }                                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Split string into equal parts to represent compartments</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Determine common character by converting to set of characters and finding union</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Calculate the sum of the priorities</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_2"><a class="anchor" href="#_part_2_2"></a><a class="link" href="#_part_2_2">Part 2</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcBadges(input: List&lt;String&gt;): Int =
  input.mapIndexed { index, s -&gt; index / 3 to s }
    .groupBy({ it.first }, { it.second })           <i class="conum" data-value="1"></i><b>(1)</b>
    .map { e -&gt;
      e.value
        .map { it.toSet() }
        .reduce { a, b -&gt; a.intersect(b) }
        .first()                                    <i class="conum" data-value="2"></i><b>(2)</b>
    }
    .sumOf { calcPriority(it) }                     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Group strings by 3.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Determine common character from all 3 strings.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Calculate the sum of the priorities</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_takeaways"><a class="anchor" href="#_takeaways"></a><a class="link" href="#_takeaways">Takeaways</a></h5>
<div class="ulist">
<ul>
<li>
<p><code>String.toSet</code> gives to a <code>Set</code> of <code>Char</code></p>
</li>
<li>
<p><code>reduce</code> is a great way to determine the intersection on multiple sets.</p>
</li>
<li>
<p><code>groupBy</code> can take two parameters and with the second parameter you can determine the type of the value.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_full_source"><a class="anchor" href="#_full_source"></a><a class="link" href="#_full_source">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {

  fun calcPriority(value: Char): Int = when (value) {
    in 'a'..'z' -&gt; value - 'a' + 1
    in 'A'..'Z' -&gt; value - 'A' + 27
    else -&gt; error("Invalid input $value")
  }

  fun calcRucksacks(input: List&lt;String&gt;): Int =
    input.map { Pair(it.substring(0 until it.length / 2), it.substring(it.length / 2)) }
      .map { it.first.toSet().intersect(it.second.toSet()).first() }
      .sumOf { calcPriority(it) }

  fun calcBadges(input: List&lt;String&gt;): Int =
    input.mapIndexed { index, s -&gt; index / 3 to s }
      .groupBy({ it.first }, { it.second })
      .map { e -&gt; e.value.map { it.toSet() }.reduce { a, b -&gt; a.intersect(b) }.first() }
      .sumOf { calcPriority(it) }

  fun part1() {
    val testPriorities = calcRucksacks(readInput("day03_test"))
    println("Test Priorities = $testPriorities")
    check(testPriorities == 157)

    val priorities = calcRucksacks(readInput("day03"))
    println("Priorities = $priorities")
    check(priorities == 8123)
  }

  fun part2() {
    val testPriorities = calcBadges(readInput("day03_test"))
    println("Test Priorities = $testPriorities")
    check(testPriorities == 70)

    val priorities = calcBadges(readInput("day03"))
    println("Priorities = $priorities")
    check(priorities == 2620)
  }
  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day04" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_04_kotlin"><a class="anchor" href="#_day_04_kotlin"></a><a class="link" href="#_day_04_kotlin">Day 04: kotlin</a></h3>
<div class="sect3">
<h4 id="_camp_cleanup"><a class="anchor" href="#_camp_cleanup"></a><a class="link" href="#_camp_cleanup">Camp Cleanup</a></h4>
<div class="paragraph">
<p>I wasted some time today because I misunderstood the <strong>fully contains</strong> applying to a pair of assignments. I was trying to check across assignments. Re-reading when I got the wrong answer meant some <em>facepalms</em>.</p>
</div>
<div class="paragraph">
<p>We needed to convert the input depicting 2 ranges into sets of sections representing by numbers. So that meant converting <code>2-4,6-8</code> to a <code>Pair</code> of <code>IntRange</code> and then to a <code>Pair</code> of <code>Set&lt;Int&gt;</code> which it as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun convertRange(input: String): IntRange {
  val values = input.split("-")
  return values[0].toInt()..values[1].toInt()
}

fun convertRanges(input: List&lt;String&gt;): List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt; =
  input.map { it.split(",") }
    .map { Pair(convertRange(it[0]).toSet(), convertRange(it[1]).toSet()) }</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_part_1_2"><a class="anchor" href="#_part_1_2"></a><a class="link" href="#_part_1_2">Part 1</a></h5>
<div class="paragraph">
<p>Determining <strong>fully contains</strong> for part 1 was as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcContains(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
  return ranges.count {
    it.first.containsAll(it.second) || it.second.containsAll(it.first)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_3"><a class="anchor" href="#_part_2_3"></a><a class="link" href="#_part_2_3">Part 2</a></h5>
<div class="paragraph">
<p>And determining an <strong>overlap</strong> for part1 was as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun calcOverlap(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
  return ranges.count { it.first.intersect(it.second).isNotEmpty() }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_takeaways_2"><a class="anchor" href="#_takeaways_2"></a><a class="link" href="#_takeaways_2">Takeaways</a></h5>
<div class="paragraph">
<p>Re-read the problem because a lot of effort was made to explain with a complete example.</p>
</div>
<div class="paragraph">
<p><strong>If you first answer is incorrect you may have misunderstood something.</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_2"><a class="anchor" href="#_full_source_2"></a><a class="link" href="#_full_source_2">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
  fun convertRange(input: String): IntRange {
    val values = input.split("-")
    return values[0].toInt()..values[1].toInt()
  }

  fun convertRanges(input: List&lt;String&gt;): List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt; =
    input.map { it.split(",") }
      .map { Pair(convertRange(it[0]).toSet(), convertRange(it[1]).toSet()) }

  fun calcContains(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
    return ranges.count {
      it.first.containsAll(it.second) || it.second.containsAll(it.first)
    }
  }

  fun calcOverlap(ranges: List&lt;Pair&lt;Set&lt;Int&gt;, Set&lt;Int&gt;&gt;&gt;): Int {
    return ranges.count { it.first.intersect(it.second).isNotEmpty() }
  }

  fun part1() {
    val testInput = readInput("day04_test")
    val testCount = calcContains(convertRanges(testInput))
    println("Part 1 Test Count = $testCount")
    check(testCount == 2)

    val input = readInput("day04")
    val count = calcContains(convertRanges(input))
    println("Part 1 Count = $count")
    check(count == 524)
  }

  fun part2() {
    val testInput = readInput("day04_test")
    val testCount = calcOverlap(convertRanges(testInput))
    println("Part 2 Test Count = $testCount")
    check(testCount == 4)

    val input = readInput("day04")
    val count = calcOverlap(convertRanges(input))
    println("Part 2 Count = $count")
    check(count == 798)
  }
  part1()
  part2()
}</code></pre>
</div>
</div>
<a id="day05" />
</div>
</div>
</div>
<div class="sect2">
<h3 id="_day_05_kotlin"><a class="anchor" href="#_day_05_kotlin"></a><a class="link" href="#_day_05_kotlin">Day 05: kotlin</a></h3>
<div class="sect3">
<h4 id="_supply_stacks"><a class="anchor" href="#_supply_stacks"></a><a class="link" href="#_supply_stacks">Supply Stacks</a></h4>
<div class="paragraph">
<p>Today we had to implement a parser to read the state of stacks of containers and instructions for moving the containers. The result was a list of the top container labels.
I decided to create a data structure for the instructions and a simple Stack.</p>
</div>
<div class="sect4">
<h5 id="_data_structures"><a class="anchor" href="#_data_structures"></a><a class="link" href="#_data_structures">Data Structures</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">data class Instruction(val count: Int, val from: Int, val to: Int)

class Stack&lt;T&gt;(private val elements: MutableList&lt;T&gt; = mutableListOf&lt;T&gt;()) {
  fun empty(): Boolean = elements.isEmpty()
  fun peek(): T = elements[elements.lastIndex]
  fun pop(): T = elements.removeAt(elements.lastIndex)
  fun push(value: T) {
    elements.add(value)
  }

  fun items() = elements.toList()
  fun size() = elements.size
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_parsing_2"><a class="anchor" href="#_parsing_2"></a><a class="link" href="#_parsing_2">Parsing</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun readStack(lines: List&lt;String&gt;, stack: Int): Stack&lt;Char&gt; {
  val result = mutableListOf&lt;Char&gt;()
  val offset = stack * 4 + 1
  for (line in lines) {
    if (line.length &gt; offset) {
      val crate = line[offset]
      if (crate in 'A'..'Z') {
        result.add(crate)
      }
    }
  }
  result.reverse()
  println("Stack[${stack + 1}]=${result.joinToString("")}")
  return Stack(result)
}

fun loadStacks(input: List&lt;String&gt;): List&lt;Stack&lt;Char&gt;&gt; {
  val lines = input.toMutableList()
  val numbers = lines.last().split(" ").mapNotNull { if(it.isNotBlank()) it.toInt() else null }
  lines.removeAt(lines.lastIndex)
  val stacks = mutableListOf&lt;Stack&lt;Char&gt;&gt;()
  for (stack in numbers.indices) {
    stacks.add(readStack(lines, stack))
  }
  return stacks.toList()
}

fun loadInstructions(input: List&lt;String&gt;): List&lt;Instruction&gt; {
  val regex = """move (\d+) from (\d+) to (\d+)""".toRegex()
  return input.mapNotNull { line -&gt;
    regex.find(line)?.let {
      val (count, from, to) = it.destructured
      Instruction(count.toInt(), from.toInt(), to.toInt())
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_1_3"><a class="anchor" href="#_part_1_3"></a><a class="link" href="#_part_1_3">Part 1</a></h5>
<div class="paragraph">
<p>Perform all the instructions and provide the list of top level crates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun perform(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
  for (i in 1..instruction.count) {
    val crate = stacks[instruction.from - 1].pop()
    stacks[instruction.to - 1].push(crate)
  }
}
fun performAndFindTops(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
  instructions.forEach {
    perform(stacks, it)
  }
  return stacks.joinToString("") { it.peek().toString() }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_part_2_4"><a class="anchor" href="#_part_2_4"></a><a class="link" href="#_part_2_4">Part 2</a></h5>
<div class="paragraph">
<p>The crane can now move multiple containers at the same time retaining their order.
I decided to use a local stack to pop all the container and then push them again which will retain the order. The alternative would have been to adjust the Stack to remove multiple items at once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">fun perform9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
  println(instruction)
  val tmp = Stack&lt;Char&gt;()
  for (i in 1..instruction.count) {
    val crate = stacks[instruction.from - 1].pop()
    tmp.push(crate)
  }
  while (!tmp.empty()) {
    stacks[instruction.to - 1].push(tmp.pop())
  }
}
fun performAndFindTops9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
  instructions.forEach {
    perform9001(stacks, it)
  }
  return stacks.joinToString("") { it.peek().toString() }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_takeaways_3"><a class="anchor" href="#_takeaways_3"></a><a class="link" href="#_takeaways_3">Takeaways</a></h5>
<div class="paragraph">
<p>Sometimes a requirement change can impact your data structures in huge ways. Using a stack to represent the piles of crates was fine until we needed to move multiple crates at a time. In a real system the performance differences of moving multiple crates at the same time will be huge if it is a core part of the system.</p>
</div>
</div>
<div class="sect4">
<h5 id="_full_source_3"><a class="anchor" href="#_full_source_3"></a><a class="link" href="#_full_source_3">Full source</a></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">data class Instruction(val count: Int, val from: Int, val to: Int)
class Stack&lt;T&gt;(private val elements: MutableList&lt;T&gt; = mutableListOf&lt;T&gt;()) {
  fun empty(): Boolean = elements.isEmpty()
  fun peek(): T = elements[elements.lastIndex]
  fun pop(): T = elements.removeAt(elements.lastIndex)
  fun push(value: T) {
    elements.add(value)
  }

  fun items() = elements.toList()
  fun size() = elements.size
}

fun main() {

  fun readStack(lines: List&lt;String&gt;, stack: Int): Stack&lt;Char&gt; {
    val result = mutableListOf&lt;Char&gt;()
    val offset = stack * 4 + 1
    for (line in lines) {
      if (line.length &gt; offset) {
        val crate = line[offset]
        if (crate in 'A'..'Z') {
          result.add(crate)
        }
      }
    }
    result.reverse()
    println("Stack[${stack + 1}]=${result.joinToString("")}")
    return Stack(result)
  }

  fun loadStacks(input: List&lt;String&gt;): List&lt;Stack&lt;Char&gt;&gt; {
    val lines = input.toMutableList()
    val numbers = lines.last().split(" ").mapNotNull { if(it.isNotBlank()) it.toInt() else null }
    lines.removeAt(lines.lastIndex)
    val stacks = mutableListOf&lt;Stack&lt;Char&gt;&gt;()
    for (stack in numbers.indices) {
      stacks.add(readStack(lines, stack))
    }
    return stacks.toList()
  }

  fun loadInstructions(input: List&lt;String&gt;): List&lt;Instruction&gt; {
    val regex = """move (\d+) from (\d+) to (\d+)""".toRegex()
    return input.mapNotNull { line -&gt;
      regex.find(line)?.let {
        val (count, from, to) = it.destructured
        Instruction(count.toInt(), from.toInt(), to.toInt())
      }
    }
  }

  fun perform(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
    for (i in 1..instruction.count) {
      val crate = stacks[instruction.from - 1].pop()
      stacks[instruction.to - 1].push(crate)
    }
  }

  fun perform9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instruction: Instruction) {
    val tmp = Stack&lt;Char&gt;()
    for (i in 1..instruction.count) {
      val crate = stacks[instruction.from - 1].pop()
      tmp.push(crate)
    }
    while (!tmp.empty()) {
      stacks[instruction.to - 1].push(tmp.pop())
    }
  }

  fun performAndFindTops(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
    instructions.forEach {
      perform(stacks, it)
    }
    stacks.forEach { stack -&gt; println("[${stack.items().joinToString("")}]") }
    return stacks.joinToString("") { it.peek().toString() }
  }

  fun performAndFindTops9001(stacks: List&lt;Stack&lt;Char&gt;&gt;, instructions: List&lt;Instruction&gt;): String {
    instructions.forEach {
      perform9001(stacks, it)
    }
    stacks.forEach { stack -&gt; println("[${stack.items().joinToString("")}]") }
    return stacks.joinToString("") { it.peek().toString() }
  }

  val test = """    [D]
[N] [C]
[Z] [M] [P]
 1   2   3

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
"""

  val testInputs = test.split("\n\n").map { readText(it) }
  val input = readFileGroup("day05")
  fun part1() {
    val testTops = performAndFindTops(loadStacks(testInputs[0]), loadInstructions(testInputs[1]))
    println("Part 1 Test Tops = $testTops")
    check(testTops == "CMZ")
    val tops = performAndFindTops(loadStacks(input[0]), loadInstructions(input[1]))
    println("Part 1 Tops = $tops")
    check(tops == "PTWLTDSJV")
  }

  fun part2() {
    val testTops = performAndFindTops9001(loadStacks(testInputs[0]), loadInstructions(testInputs[1]))
    println("Part 2 Test Tops = $testTops")
    check(testTops == "MCD")
    val tops = performAndFindTops9001(loadStacks(input[0]), loadInstructions(input[1]))
    println("Part 2 Tops = $tops")
    check(tops == "WZMFVGGZP")
  }

  part1()
  part2()

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div></p>

	</div>

</div>
<div id="push"></div>
</div>


    <div id="footer">
      <div class="container">
          <p class="muted credit">&copy; 2022 | Mixed with Bootstrap v3.1.1 | generated with <a href="https://doctoolchain.org">docToolchain</a> | Baked with JBake v2.6.4</p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    


</body>
</html>